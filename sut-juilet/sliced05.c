/* Generated by Frama-C */
typedef int wchar_t;
typedef unsigned int size_t;
/*@
axiomatic MemCmp {
  logic â„¤ memcmp{L1, L2}(char *s1, char *s2, â„¤ n) 
    reads \at(*(s1+(0 .. n-1)),L1), \at(*(s2+(0 .. n-1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      memcmp{L1, L2}(s1, s2, n) â‰¡ 0 â‡”
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ \at(*(s1+i),L1) â‰¡ \at(*(s2+i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic ð”¹ memchr{L}(char *s, â„¤ c, â„¤ n) 
    reads *(s+(0 .. n-1));
  
  axiom memchr_def{L}:
    âˆ€ char *s;
    âˆ€ â„¤ c;
    âˆ€ â„¤ n;
      memchr{L}(s, c, n) â‰¡ \true â‡”
      (âˆƒ int i; 0 â‰¤ i < n âˆ§ *(s+i) â‰¡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic ð”¹ memset{L}(char *s, â„¤ c, â„¤ n) 
    reads *(s+(0 .. n-1));
  
  axiom memset_def{L}:
    âˆ€ char *s;
    âˆ€ â„¤ c;
    âˆ€ â„¤ n;
      memset{L}(s, c, n) â‰¡ \true â‡”
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ *(s+i) â‰¡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic â„¤ strlen{L}(char *s) 
    reads *(s+(0 ..));
  
  axiom strlen_pos_or_null{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
      0 â‰¤ i âˆ§ (âˆ€ â„¤ j; 0 â‰¤ j < i â‡’ *(s+j) â‰¢ '\000') âˆ§
      *(s+i) â‰¡ '\000' â‡’ strlen{L}(s) â‰¡ i;
  
  axiom strlen_neg{L}:
    âˆ€ char *s;
      (âˆ€ â„¤ i; 0 â‰¤ i â‡’ *(s+i) â‰¢ '\000') â‡’ strlen{L}(s) < 0;
  
  axiom strlen_before_null{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i < strlen{L}(s) â‡’ *(s+i) â‰¢ '\000';
  
  axiom strlen_at_null{L}:
    âˆ€ char *s; 0 â‰¤ strlen{L}(s) â‡’ *(s+strlen{L}(s)) â‰¡ '\000';
  
  axiom strlen_not_zero{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
      0 â‰¤ i â‰¤ strlen{L}(s) âˆ§ *(s+i) â‰¢ '\000' â‡’ i < strlen{L}(s);
  
  axiom strlen_zero{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
      0 â‰¤ i â‰¤ strlen{L}(s) âˆ§ *(s+i) â‰¡ '\000' â‡’ i â‰¡ strlen{L}(s);
  
  axiom strlen_sup{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i âˆ§ *(s+i) â‰¡ '\000' â‡’ 0 â‰¤ strlen{L}(s) â‰¤ i;
  
  axiom strlen_shift{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i â‰¤ strlen{L}(s) â‡’ strlen{L}(s+i) â‰¡ strlen{L}(s)-i;
  
  axiom strlen_create{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i; 0 â‰¤ i âˆ§ *(s+i) â‰¡ '\000' â‡’ 0 â‰¤ strlen{L}(s) â‰¤ i;
  
  axiom strlen_create_shift{L}:
    âˆ€ char *s;
    âˆ€ â„¤ i;
    âˆ€ â„¤ k;
      0 â‰¤ k â‰¤ i âˆ§ *(s+i) â‰¡ '\000' â‡’ 0 â‰¤ strlen{L}(s+k) â‰¤ i-k;
  
  axiom memcmp_strlen_left{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      memcmp{L, L}(s1, s2, n) â‰¡ 0 âˆ§ strlen{L}(s1) < n â‡’
      strlen{L}(s1) â‰¡ strlen{L}(s2);
  
  axiom memcmp_strlen_right{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      memcmp{L, L}(s1, s2, n) â‰¡ 0 âˆ§ strlen{L}(s2) < n â‡’
      strlen{L}(s1) â‰¡ strlen{L}(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ k, â„¤ n;
      memcmp{L, L}(s1, s2+k, n) â‰¡ 0 â‰¤ k âˆ§ strlen{L}(s1) < n â‡’
      0 â‰¤ strlen{L}(s2) â‰¤ k+strlen{L}(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ k, â„¤ n;
      memcmp{L, L}(s1+k, s2, n) â‰¡ 0 â‰¤ k âˆ§ strlen{L}(s2) < n â‡’
      0 â‰¤ strlen{L}(s1) â‰¤ k+strlen{L}(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic â„¤ strcmp{L}(char *s1, char *s2) 
    reads *(s1+(0 .. strlen{L}(s1))), *(s2+(0 .. strlen{L}(s2)));
  
  axiom strcmp_zero{L}:
    âˆ€ char *s1, char *s2;
      strcmp{L}(s1, s2) â‰¡ 0 â‡”
      strlen{L}(s1) â‰¡ strlen{L}(s2) âˆ§
      (âˆ€ â„¤ i; 0 â‰¤ i â‰¤ strlen{L}(s1) â‡’ *(s1+i) â‰¡ *(s2+i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic â„¤ strncmp{L}(char *s1, char *s2, â„¤ n) 
    reads *(s1+(0 .. n-1)), *(s2+(0 .. n-1));
  
  axiom strncmp_zero{L}:
    âˆ€ char *s1, char *s2;
    âˆ€ â„¤ n;
      strncmp{L}(s1, s2, n) â‰¡ 0 â‡”
      (strlen{L}(s1) < n âˆ§ strcmp{L}(s1, s2) â‰¡ 0) âˆ¨
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ *(s1+i) â‰¡ *(s2+i));
  
  }
 */
/*@
axiomatic StrChr {
  logic ð”¹ strchr{L}(char *s, â„¤ c) 
    reads *(s+(0 .. strlen{L}(s)));
  
  axiom strchr_def{L}:
    âˆ€ char *s;
    âˆ€ â„¤ c;
      strchr{L}(s, c) â‰¡ \true â‡”
      (âˆƒ â„¤ i; 0 â‰¤ i â‰¤ strlen{L}(s) âˆ§ *(s+i) â‰¡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic â„¤ wcslen{L}(wchar_t *s) 
    reads *(s+(0 ..));
  
  axiom wcslen_pos_or_null{L}:
    âˆ€ wchar_t *s;
    âˆ€ â„¤ i;
      0 â‰¤ i âˆ§ (âˆ€ â„¤ j; 0 â‰¤ j < i â‡’ *(s+j) â‰¢ 0) âˆ§ *(s+i) â‰¡ 0 â‡’
      wcslen{L}(s) â‰¡ i;
  
  axiom wcslen_neg{L}:
    âˆ€ wchar_t *s;
      (âˆ€ â„¤ i; 0 â‰¤ i â‡’ *(s+i) â‰¢ 0) â‡’ wcslen{L}(s) < 0;
  
  axiom wcslen_before_null{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i; 0 â‰¤ i < wcslen{L}(s) â‡’ *(s+i) â‰¢ 0;
  
  axiom wcslen_at_null{L}:
    âˆ€ wchar_t *s; 0 â‰¤ wcslen{L}(s) â‡’ *(s+wcslen{L}(s)) â‰¡ 0;
  
  axiom wcslen_not_zero{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i; 0 â‰¤ i â‰¤ wcslen{L}(s) âˆ§ *(s+i) â‰¢ 0 â‡’ i < wcslen{L}(s);
  
  axiom wcslen_zero{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i;
      0 â‰¤ i â‰¤ wcslen{L}(s) âˆ§ *(s+i) â‰¡ 0 â‡’ i â‰¡ wcslen{L}(s);
  
  axiom wcslen_sup{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i; 0 â‰¤ i âˆ§ *(s+i) â‰¡ 0 â‡’ 0 â‰¤ wcslen{L}(s) â‰¤ i;
  
  axiom wcslen_shift{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i; 0 â‰¤ i â‰¤ wcslen{L}(s) â‡’ wcslen{L}(s+i) â‰¡ wcslen{L}(s)-i;
  
  axiom wcslen_create{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i; 0 â‰¤ i âˆ§ *(s+i) â‰¡ 0 â‡’ 0 â‰¤ wcslen{L}(s) â‰¤ i;
  
  axiom wcslen_create_shift{L}:
    âˆ€ wchar_t *s;
    âˆ€ int i;
    âˆ€ int k;
      0 â‰¤ k â‰¤ i âˆ§ *(s+i) â‰¡ 0 â‡’ 0 â‰¤ wcslen{L}(s+k) â‰¤ i-k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic â„¤ wcscmp{L}(wchar_t *s1, wchar_t *s2) 
    reads *(s1+(0 .. wcslen{L}(s1))), *(s2+(0 .. wcslen{L}(s2)));
  
  axiom wcscmp_zero{L}:
    âˆ€ wchar_t *s1, wchar_t *s2;
      wcscmp{L}(s1, s2) â‰¡ 0 â‡”
      wcslen{L}(s1) â‰¡ wcslen{L}(s2) âˆ§
      (âˆ€ â„¤ i; 0 â‰¤ i â‰¤ wcslen{L}(s1) â‡’ *(s1+i) â‰¡ *(s2+i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic â„¤ wcsncmp{L}(wchar_t *s1, wchar_t *s2, â„¤ n) 
    reads *(s1+(0 .. n-1)), *(s2+(0 .. n-1));
  
  axiom wcsncmp_zero{L}:
    âˆ€ wchar_t *s1, wchar_t *s2;
    âˆ€ â„¤ n;
      wcsncmp{L}(s1, s2, n) â‰¡ 0 â‡”
      (wcslen{L}(s1) < n âˆ§ wcscmp{L}(s1, s2) â‰¡ 0) âˆ¨
      (âˆ€ â„¤ i; 0 â‰¤ i < n â‡’ *(s1+i) â‰¡ *(s2+i));
  
  }
 */
/*@ logic â„¤ minimum(â„¤ i, â„¤ j) = i<j? i: j;
 */
/*@ logic â„¤ maximum(â„¤ i, â„¤ j) = i<j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 â‰¤ strlen{L}(s) âˆ§ \valid{L}(s+(0 .. strlen{L}(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 â‰¤ strlen{L}(s) âˆ§ \valid_read{L}(s+(0 .. strlen{L}(s)));
 */
/*@
predicate valid_string_or_null{L}(char *s) =
  s â‰¡ \null âˆ¨ valid_string{L}(s);
 */
/*@
predicate valid_wstring{L}(wchar_t *s) =
  0 â‰¤ wcslen{L}(s) âˆ§ \valid{L}(s+(0 .. wcslen{L}(s)));
 */
/*@
predicate valid_wstring_or_null{L}(wchar_t *s) =
  s â‰¡ \null âˆ¨ valid_wstring{L}(s);
 */
/*@ ghost extern int __fc_heap_status __attribute__((__FRAMA_C_MODEL__)); */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
    
    behavior no_allocation:
      assumes Â¬is_allocable(size);
      ensures \result â‰¡ \null;
      allocates \nothing;
 */
extern void *malloc(size_t size);

/*@ behavior deallocation:
      assumes p â‰¢ \null;
      requires freeable: \freeable(p);
      ensures \allocable(\old(p));
    
    behavior no_deallocation:
      assumes p â‰¡ \null;
      assigns \nothing;
      allocates \nothing;
 */
extern void free(void *p);

static void goodB2G2_slice_1(void)
{
  wchar_t *data;
  data = (wchar_t *)malloc((unsigned int)100 * sizeof(wchar_t));
  /*@ slice pragma ctrl; */ ;
  /*@ slice pragma stmt; */
  free((void *)data);
  return;
}

void main(void)
{
  goodB2G2_slice_1();
  return;
}


