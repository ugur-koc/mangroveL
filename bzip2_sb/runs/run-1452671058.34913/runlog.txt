01001000000011110000100101000011000011001010101101101011010101110
--add-pass pass_clang_binsrch remove-unused-function 34 --add-pass pass_clang local-to-global 202 --add-pass pass_clang rename-class 993 --add-pass pass_clang rename-cxx-method 994 --add-pass pass_clang return-void 212 --add-pass pass_clang simple-inliner 213 --add-pass pass_clang replace-callexpr 218 --add-pass pass_clang remove-unused-enum-member 221 --add-pass pass_clang remove-unused-var 223 --add-pass pass_clang simplify-comma-expr 228 --add-pass pass_clang simplify-dependent-typedef 229 --add-pass pass_clang instantiate-template-type-param-to-int 234 --add-pass pass_clang instantiate-template-param 235 --add-pass pass_clang reduce-class-template-param 238 --add-pass pass_clang class-template-to-class 240 --add-pass pass_clang replace-derived-class 242 --add-pass pass_clang remove-ctor-initializer 244 --add-pass pass_clang replace-class-with-base-template-spec 245 --add-pass pass_clang remove-unused-outer-class 247 --add-pass pass_clang empty-struct-to-int 248 --add-pass pass_clang remove-pointer-pairs 250 --add-pass pass_clang remove-addr-taken 252 --add-pass pass_clang simplify-struct 253 --add-pass pass_clang replace-array-index-var 255 --add-pass pass_clang simplify-recursive-template-instantiation 257 --add-pass pass_clang combine-local-var 996 --add-pass pass_clang simplify-struct-union-decl 997 --add-pass pass_clang move-global-var 998
===< 32478 >===
running 2 interestingness tests in parallel
===< pass_clang_binsrch :: remove-unused-function >===
(4.4 %, 195992 bytes)
===< pass_clang :: local-to-global >===
(4.3 %, 196208 bytes)
(4.1 %, 196500 bytes)
(4.1 %, 196632 bytes)
(4.0 %, 196728 bytes)
(3.9 %, 196944 bytes)
(3.8 %, 197070 bytes)
(3.8 %, 197168 bytes)
(3.7 %, 197251 bytes)
(3.7 %, 197310 bytes)
(3.7 %, 197363 bytes)
(3.6 %, 197538 bytes)
(3.6 %, 197635 bytes)
(3.5 %, 197758 bytes)
(3.5 %, 197816 bytes)
(3.4 %, 197874 bytes)
(3.4 %, 197914 bytes)
(3.4 %, 197946 bytes)
(3.2 %, 198441 bytes)
(2.9 %, 198928 bytes)
(2.8 %, 199136 bytes)
(2.7 %, 199336 bytes)
(2.6 %, 199553 bytes)
(2.4 %, 199935 bytes)
sh: 0: getcwd() failed: No such file or directory
(2.3 %, 200167 bytes)
(2.3 %, 200234 bytes)
(2.2 %, 200351 bytes)
(2.2 %, 200502 bytes)
(2.2 %, 200521 bytes)
(2.1 %, 200670 bytes)
(2.0 %, 200753 bytes)
(2.0 %, 200803 bytes)
(1.9 %, 200952 bytes)
(1.9 %, 201039 bytes)
(1.9 %, 201060 bytes)
(1.9 %, 201081 bytes)
(1.9 %, 201102 bytes)
(1.9 %, 201123 bytes)
(1.9 %, 201144 bytes)
(1.8 %, 201165 bytes)
(1.8 %, 201186 bytes)
(1.8 %, 201207 bytes)
(1.8 %, 201228 bytes)
(1.8 %, 201249 bytes)
(1.8 %, 201270 bytes)
(1.8 %, 201291 bytes)
(1.8 %, 201312 bytes)
(1.8 %, 201333 bytes)
(1.7 %, 201354 bytes)
(1.7 %, 201375 bytes)
(1.7 %, 201396 bytes)
(1.7 %, 201417 bytes)
(1.7 %, 201438 bytes)
(1.7 %, 201459 bytes)
(1.7 %, 201480 bytes)
(1.7 %, 201501 bytes)
(1.7 %, 201522 bytes)
(1.7 %, 201543 bytes)
(1.6 %, 201564 bytes)
(1.6 %, 201585 bytes)
(1.6 %, 201606 bytes)
(1.6 %, 201627 bytes)
(1.6 %, 201648 bytes)
(1.6 %, 201669 bytes)
(1.6 %, 201690 bytes)
(1.6 %, 201711 bytes)
(1.6 %, 201732 bytes)
(1.6 %, 201753 bytes)
(1.5 %, 201774 bytes)
(1.5 %, 201795 bytes)
(1.5 %, 201816 bytes)
(1.5 %, 201837 bytes)
(1.5 %, 201858 bytes)
(1.5 %, 201879 bytes)
(1.5 %, 201900 bytes)
(1.5 %, 201921 bytes)
(1.5 %, 201942 bytes)
(1.5 %, 201963 bytes)
(1.4 %, 201984 bytes)
(1.4 %, 202005 bytes)
(1.4 %, 202026 bytes)
(1.4 %, 202047 bytes)
(1.4 %, 202068 bytes)
(1.4 %, 202089 bytes)
(1.4 %, 202110 bytes)
(1.4 %, 202131 bytes)
(1.4 %, 202152 bytes)
(1.3 %, 202173 bytes)
(1.3 %, 202194 bytes)
(1.3 %, 202215 bytes)
(1.3 %, 202236 bytes)
(1.3 %, 202257 bytes)
(1.3 %, 202278 bytes)
(1.3 %, 202299 bytes)
(1.3 %, 202320 bytes)
(1.3 %, 202341 bytes)
(1.3 %, 202362 bytes)
(1.2 %, 202383 bytes)
(1.2 %, 202404 bytes)
(1.2 %, 202425 bytes)
(1.2 %, 202446 bytes)
(1.2 %, 202467 bytes)
(1.2 %, 202488 bytes)
(1.2 %, 202509 bytes)
(1.2 %, 202530 bytes)
(1.2 %, 202551 bytes)
(1.2 %, 202572 bytes)
(1.1 %, 202593 bytes)
(1.1 %, 202614 bytes)
(1.1 %, 202635 bytes)
(1.1 %, 202656 bytes)
(1.1 %, 202677 bytes)
(1.1 %, 202698 bytes)
(1.1 %, 202719 bytes)
(1.1 %, 202740 bytes)
(1.1 %, 202761 bytes)
(1.1 %, 202782 bytes)
(1.0 %, 202803 bytes)
(1.0 %, 202824 bytes)
(1.0 %, 202845 bytes)
(1.0 %, 202866 bytes)
(1.0 %, 202887 bytes)
(1.0 %, 202908 bytes)
(1.0 %, 202929 bytes)
(1.0 %, 202950 bytes)
(1.0 %, 202971 bytes)
(0.9 %, 202992 bytes)
(0.9 %, 203013 bytes)
(0.9 %, 203034 bytes)
(0.9 %, 203055 bytes)
(0.9 %, 203076 bytes)
(0.9 %, 203097 bytes)
(0.9 %, 203118 bytes)
sh: 0: getcwd() failed: No such file or directory
(0.9 %, 203139 bytes)
(0.9 %, 203160 bytes)
(0.9 %, 203181 bytes)
(0.8 %, 203202 bytes)
(0.8 %, 203223 bytes)
(0.8 %, 203244 bytes)
(0.8 %, 203265 bytes)
(0.8 %, 203286 bytes)
(0.8 %, 203307 bytes)
(0.8 %, 203328 bytes)
(0.8 %, 203349 bytes)
(0.8 %, 203370 bytes)
sh: 0: getcwd() failed: No such file or directory
(0.8 %, 203391 bytes)
(0.7 %, 203412 bytes)
(0.7 %, 203433 bytes)
(0.7 %, 203454 bytes)
(0.7 %, 203475 bytes)
(0.7 %, 203496 bytes)
(0.7 %, 203517 bytes)
(0.7 %, 203538 bytes)
(0.7 %, 203559 bytes)
(0.7 %, 203580 bytes)
(0.7 %, 203601 bytes)
(0.6 %, 203622 bytes)
(0.6 %, 203643 bytes)
(0.6 %, 203664 bytes)
(0.6 %, 203685 bytes)
(0.6 %, 203706 bytes)
(0.6 %, 203727 bytes)
(0.6 %, 203748 bytes)
(0.6 %, 203769 bytes)
(0.6 %, 203790 bytes)
(0.5 %, 203811 bytes)
(0.5 %, 203832 bytes)
(0.5 %, 203853 bytes)
(0.5 %, 203874 bytes)
(0.5 %, 203895 bytes)
(0.5 %, 203916 bytes)
(0.5 %, 203937 bytes)
(0.5 %, 203958 bytes)
(0.5 %, 203979 bytes)
(0.5 %, 204000 bytes)
(0.4 %, 204021 bytes)
(0.4 %, 204042 bytes)
(0.4 %, 204063 bytes)
(0.4 %, 204084 bytes)
(0.4 %, 204105 bytes)
(0.4 %, 204126 bytes)
(0.4 %, 204147 bytes)
(0.4 %, 204168 bytes)
(0.4 %, 204189 bytes)
(0.4 %, 204210 bytes)
(0.3 %, 204231 bytes)
(0.3 %, 204252 bytes)
(0.3 %, 204273 bytes)
(0.3 %, 204294 bytes)
(0.3 %, 204315 bytes)
(0.3 %, 204336 bytes)
(0.3 %, 204357 bytes)
(0.3 %, 204378 bytes)
(0.3 %, 204399 bytes)
(0.3 %, 204420 bytes)
(0.2 %, 204441 bytes)
(0.2 %, 204462 bytes)
(0.2 %, 204483 bytes)
(0.2 %, 204504 bytes)
(0.2 %, 204525 bytes)
(0.2 %, 204546 bytes)
(0.2 %, 204567 bytes)
(0.2 %, 204588 bytes)
(0.2 %, 204609 bytes)
(0.1 %, 204630 bytes)
(0.1 %, 204651 bytes)
(0.1 %, 204672 bytes)
(0.1 %, 204693 bytes)
(0.1 %, 204714 bytes)
(0.1 %, 204735 bytes)
(0.1 %, 204756 bytes)
(0.1 %, 204777 bytes)
(0.1 %, 204798 bytes)
(0.1 %, 204819 bytes)
(0.0 %, 204840 bytes)
(0.0 %, 204861 bytes)
(0.0 %, 204882 bytes)
(0.0 %, 204903 bytes)
(0.0 %, 204924 bytes)
(-0.0 %, 204945 bytes)
(-0.0 %, 204966 bytes)
(-0.0 %, 204987 bytes)
(-0.0 %, 205008 bytes)
(-0.0 %, 205029 bytes)
(-0.1 %, 205050 bytes)
(-0.1 %, 205071 bytes)
(-0.1 %, 205092 bytes)
(-0.1 %, 205113 bytes)
(-0.1 %, 205134 bytes)
(-0.1 %, 205155 bytes)
(-0.1 %, 205176 bytes)
(-0.1 %, 205197 bytes)
(-0.1 %, 205218 bytes)
(-0.1 %, 205239 bytes)
(-0.2 %, 205260 bytes)
(-0.2 %, 205281 bytes)
(-0.2 %, 205302 bytes)
(-0.2 %, 205323 bytes)
(-0.2 %, 205344 bytes)
(-0.2 %, 205365 bytes)
(-0.2 %, 205386 bytes)
(-0.2 %, 205407 bytes)
(-0.2 %, 205428 bytes)
(-0.3 %, 205449 bytes)
(-0.3 %, 205470 bytes)
(-0.3 %, 205491 bytes)
(-0.3 %, 205512 bytes)
(-0.3 %, 205533 bytes)
(-0.3 %, 205554 bytes)
(-0.3 %, 205575 bytes)
(-0.3 %, 205596 bytes)
(-0.3 %, 205617 bytes)
(-0.3 %, 205638 bytes)
(-0.4 %, 205659 bytes)
(-0.4 %, 205680 bytes)
(-0.4 %, 205701 bytes)
(-0.4 %, 205722 bytes)
(-0.4 %, 205743 bytes)
(-0.4 %, 205764 bytes)
(-0.4 %, 205785 bytes)
(-0.4 %, 205806 bytes)
(-0.4 %, 205827 bytes)
(-0.4 %, 205848 bytes)
(-0.5 %, 205869 bytes)
(-0.5 %, 205890 bytes)
(-0.5 %, 205911 bytes)
(-0.5 %, 205932 bytes)
(-0.5 %, 205953 bytes)
(-0.5 %, 205974 bytes)
(-0.5 %, 205995 bytes)
(-0.5 %, 206016 bytes)
(-0.5 %, 206037 bytes)
(-0.5 %, 206058 bytes)
(-0.6 %, 206079 bytes)
(-0.6 %, 206100 bytes)
(-0.6 %, 206121 bytes)
(-0.6 %, 206142 bytes)
(-0.6 %, 206163 bytes)
(-0.6 %, 206184 bytes)
(-0.6 %, 206205 bytes)
(-0.6 %, 206226 bytes)
(-0.6 %, 206247 bytes)
(-0.6 %, 206268 bytes)
(-0.7 %, 206289 bytes)
(-0.7 %, 206310 bytes)
(-0.7 %, 206331 bytes)
(-0.7 %, 206352 bytes)
(-0.7 %, 206373 bytes)
(-0.7 %, 206394 bytes)
(-0.7 %, 206415 bytes)
(-0.7 %, 206436 bytes)
(-0.7 %, 206457 bytes)
(-0.8 %, 206478 bytes)
(-0.8 %, 206499 bytes)
(-0.8 %, 206520 bytes)
(-0.8 %, 206541 bytes)
(-0.8 %, 206562 bytes)
(-0.8 %, 206583 bytes)
(-0.8 %, 206604 bytes)
(-0.8 %, 206625 bytes)
(-0.8 %, 206646 bytes)
(-0.8 %, 206667 bytes)
(-0.9 %, 206688 bytes)
(-0.9 %, 206709 bytes)
(-0.9 %, 206730 bytes)
(-0.9 %, 206751 bytes)
(-0.9 %, 206772 bytes)
(-0.9 %, 206793 bytes)
(-0.9 %, 206814 bytes)
(-0.9 %, 206835 bytes)
(-0.9 %, 206856 bytes)
(-0.9 %, 206877 bytes)
sh: 0: getcwd() failed: No such file or directory
(-1.0 %, 206898 bytes)
(-1.0 %, 206919 bytes)
(-1.0 %, 206940 bytes)
(-1.0 %, 206961 bytes)
(-1.0 %, 206982 bytes)
(-1.0 %, 207003 bytes)
(-1.0 %, 207024 bytes)
(-1.0 %, 207045 bytes)
(-1.0 %, 207066 bytes)
(-1.0 %, 207087 bytes)
(-1.1 %, 207108 bytes)
(-1.1 %, 207129 bytes)
(-1.1 %, 207150 bytes)
(-1.1 %, 207171 bytes)
(-1.1 %, 207192 bytes)
(-1.1 %, 207213 bytes)
(-1.1 %, 207234 bytes)
(-1.1 %, 207255 bytes)
(-1.1 %, 207276 bytes)
(-1.2 %, 207297 bytes)
(-1.2 %, 207318 bytes)
(-1.2 %, 207339 bytes)
(-1.2 %, 207360 bytes)
(-1.2 %, 207381 bytes)
sh: 0: getcwd() failed: No such file or directory
(-1.2 %, 207402 bytes)
(-1.2 %, 207423 bytes)
(-1.2 %, 207444 bytes)
(-1.2 %, 207465 bytes)
(-1.2 %, 207486 bytes)
(-1.3 %, 207507 bytes)
(-1.3 %, 207528 bytes)
sh: 0: getcwd() failed: No such file or directory
(-1.3 %, 207549 bytes)
(-1.3 %, 207570 bytes)
(-1.3 %, 207591 bytes)
(-1.3 %, 207612 bytes)
(-1.3 %, 207633 bytes)
(-1.3 %, 207654 bytes)
(-1.3 %, 207675 bytes)
(-1.3 %, 207696 bytes)
(-1.4 %, 207717 bytes)
(-1.4 %, 207738 bytes)
(-1.4 %, 207759 bytes)
(-1.4 %, 207780 bytes)
(-1.4 %, 207801 bytes)
(-1.4 %, 207822 bytes)
(-1.4 %, 207843 bytes)
(-1.4 %, 207864 bytes)
(-1.4 %, 207885 bytes)
(-1.4 %, 207906 bytes)
(-1.5 %, 207927 bytes)
(-1.5 %, 207948 bytes)
(-1.5 %, 207969 bytes)
(-1.5 %, 207990 bytes)
(-1.5 %, 208011 bytes)
(-1.5 %, 208032 bytes)
(-1.5 %, 208053 bytes)
(-1.5 %, 208074 bytes)
(-1.5 %, 208095 bytes)
(-1.6 %, 208116 bytes)
(-1.6 %, 208137 bytes)
(-1.6 %, 208158 bytes)
(-1.6 %, 208179 bytes)
(-1.6 %, 208200 bytes)
(-1.6 %, 208221 bytes)
(-1.6 %, 208242 bytes)
(-1.6 %, 208263 bytes)
(-1.6 %, 208284 bytes)
(-1.6 %, 208305 bytes)
(-1.7 %, 208326 bytes)
(-1.7 %, 208347 bytes)
(-1.7 %, 208368 bytes)
(-1.7 %, 208389 bytes)
(-1.7 %, 208410 bytes)
(-1.7 %, 208431 bytes)
(-1.7 %, 208452 bytes)
(-1.7 %, 208473 bytes)
(-1.7 %, 208494 bytes)
(-1.7 %, 208515 bytes)
(-1.8 %, 208536 bytes)
(-1.8 %, 208557 bytes)
(-1.8 %, 208578 bytes)
(-1.8 %, 208599 bytes)
(-1.8 %, 208620 bytes)
(-1.8 %, 208641 bytes)
sh: 0: getcwd() failed: No such file or directory
(-1.8 %, 208662 bytes)
(-1.8 %, 208683 bytes)
(-1.8 %, 208704 bytes)
(-1.8 %, 208725 bytes)
(-1.9 %, 208746 bytes)
(-1.9 %, 208767 bytes)
(-1.9 %, 208788 bytes)
(-1.9 %, 208809 bytes)
(-1.9 %, 208830 bytes)
(-1.9 %, 208851 bytes)
(-1.9 %, 208872 bytes)
(-1.9 %, 208893 bytes)
(-1.9 %, 208914 bytes)
(-2.0 %, 208935 bytes)
(-2.0 %, 208956 bytes)
(-2.0 %, 208977 bytes)
(-2.0 %, 208998 bytes)
(-2.0 %, 209019 bytes)
(-2.0 %, 209040 bytes)
(-2.0 %, 209061 bytes)
(-2.0 %, 209082 bytes)
(-2.0 %, 209103 bytes)
(-2.0 %, 209124 bytes)
(-2.1 %, 209145 bytes)
(-2.1 %, 209166 bytes)
(-2.1 %, 209187 bytes)
(-2.1 %, 209208 bytes)
(-2.1 %, 209229 bytes)
(-2.1 %, 209250 bytes)
(-2.1 %, 209271 bytes)
(-2.1 %, 209292 bytes)
(-2.1 %, 209313 bytes)
(-2.1 %, 209334 bytes)
(-2.2 %, 209355 bytes)
(-2.2 %, 209376 bytes)
(-2.2 %, 209397 bytes)
(-2.2 %, 209418 bytes)
(-2.2 %, 209439 bytes)
(-2.2 %, 209460 bytes)
(-2.2 %, 209481 bytes)
(-2.2 %, 209502 bytes)
(-2.2 %, 209523 bytes)
(-2.2 %, 209544 bytes)
(-2.3 %, 209565 bytes)
(-2.3 %, 209586 bytes)
(-2.3 %, 209607 bytes)
(-2.3 %, 209628 bytes)
(-2.3 %, 209649 bytes)
(-2.3 %, 209670 bytes)
(-2.3 %, 209691 bytes)
(-2.3 %, 209712 bytes)
(-2.3 %, 209733 bytes)
(-2.4 %, 209754 bytes)
(-2.4 %, 209775 bytes)
(-2.4 %, 209796 bytes)
(-2.4 %, 209817 bytes)
(-2.4 %, 209838 bytes)
(-2.4 %, 209859 bytes)
(-2.4 %, 209880 bytes)
(-2.4 %, 209901 bytes)
(-2.4 %, 209922 bytes)
(-2.4 %, 209943 bytes)
(-2.5 %, 209964 bytes)
(-2.5 %, 209985 bytes)
(-2.5 %, 210006 bytes)
(-2.5 %, 210027 bytes)
(-2.5 %, 210048 bytes)
(-2.5 %, 210069 bytes)
(-2.5 %, 210090 bytes)
(-2.5 %, 210111 bytes)
(-2.5 %, 210132 bytes)
(-2.5 %, 210153 bytes)
(-2.6 %, 210174 bytes)
(-2.6 %, 210195 bytes)
(-2.6 %, 210216 bytes)
(-2.6 %, 210237 bytes)
(-2.6 %, 210258 bytes)
(-2.6 %, 210279 bytes)
(-2.6 %, 210300 bytes)
(-2.6 %, 210321 bytes)
(-2.6 %, 210342 bytes)
(-2.6 %, 210363 bytes)
(-2.7 %, 210384 bytes)
(-2.7 %, 210405 bytes)
(-2.7 %, 210426 bytes)
(-2.7 %, 210447 bytes)
(-2.7 %, 210468 bytes)
(-2.7 %, 210489 bytes)
(-2.7 %, 210510 bytes)
(-2.7 %, 210531 bytes)
(-2.7 %, 210552 bytes)
(-2.8 %, 210573 bytes)
(-2.8 %, 210594 bytes)
(-2.8 %, 210615 bytes)
(-2.8 %, 210636 bytes)
(-2.8 %, 210657 bytes)
(-2.8 %, 210678 bytes)
(-2.8 %, 210699 bytes)
(-2.8 %, 210720 bytes)
(-2.8 %, 210741 bytes)
(-2.8 %, 210762 bytes)
(-2.9 %, 210783 bytes)
(-2.9 %, 210804 bytes)
(-2.9 %, 210825 bytes)
(-2.9 %, 210846 bytes)
(-2.9 %, 210867 bytes)
(-2.9 %, 210888 bytes)
(-2.9 %, 210909 bytes)
(-2.9 %, 210930 bytes)
(-2.9 %, 210951 bytes)
(-2.9 %, 210972 bytes)
(-3.0 %, 210993 bytes)
(-3.0 %, 211014 bytes)
(-3.0 %, 211035 bytes)
(-3.0 %, 211056 bytes)
(-3.0 %, 211077 bytes)
(-3.0 %, 211098 bytes)
(-3.0 %, 211119 bytes)
(-3.0 %, 211140 bytes)
(-3.0 %, 211161 bytes)
(-3.0 %, 211182 bytes)
(-3.1 %, 211203 bytes)
(-3.1 %, 211224 bytes)
(-3.1 %, 211245 bytes)
(-3.1 %, 211266 bytes)
(-3.1 %, 211287 bytes)
(-3.1 %, 211308 bytes)
(-3.1 %, 211329 bytes)
(-3.1 %, 211350 bytes)
(-3.1 %, 211371 bytes)
(-3.2 %, 211392 bytes)
(-3.2 %, 211413 bytes)
(-3.2 %, 211434 bytes)
(-3.2 %, 211455 bytes)
(-3.2 %, 211476 bytes)
(-3.2 %, 211497 bytes)
(-3.2 %, 211518 bytes)
(-3.2 %, 211539 bytes)
(-3.2 %, 211560 bytes)
(-3.2 %, 211581 bytes)
(-3.3 %, 211602 bytes)
(-3.3 %, 211623 bytes)
(-3.3 %, 211644 bytes)
(-3.3 %, 211665 bytes)
(-3.3 %, 211686 bytes)
(-3.3 %, 211707 bytes)
(-3.3 %, 211728 bytes)
(-3.3 %, 211749 bytes)
(-3.3 %, 211770 bytes)
(-3.3 %, 211791 bytes)
(-3.4 %, 211812 bytes)
(-3.4 %, 211833 bytes)
(-3.4 %, 211854 bytes)
(-3.4 %, 211875 bytes)
(-3.4 %, 211896 bytes)
(-3.4 %, 211917 bytes)
(-3.4 %, 211938 bytes)
(-3.4 %, 211959 bytes)
(-3.4 %, 211980 bytes)
(-3.4 %, 212001 bytes)
(-3.5 %, 212022 bytes)
(-3.5 %, 212043 bytes)
(-3.5 %, 212064 bytes)
(-3.5 %, 212085 bytes)
(-3.5 %, 212106 bytes)
(-3.5 %, 212127 bytes)
(-3.5 %, 212148 bytes)
(-3.5 %, 212169 bytes)
(-3.5 %, 212190 bytes)
(-3.5 %, 212211 bytes)
(-3.6 %, 212232 bytes)
(-3.6 %, 212253 bytes)
(-3.6 %, 212274 bytes)
(-3.6 %, 212295 bytes)
sh: 0: getcwd() failed: No such file or directory
(-3.6 %, 212316 bytes)
(-3.6 %, 212337 bytes)
(-3.6 %, 212358 bytes)
(-3.6 %, 212379 bytes)
(-3.6 %, 212400 bytes)
(-3.7 %, 212421 bytes)
(-3.7 %, 212442 bytes)
(-3.7 %, 212463 bytes)
(-3.7 %, 212484 bytes)
(-3.7 %, 212505 bytes)
(-3.7 %, 212526 bytes)
(-3.7 %, 212547 bytes)
(-3.7 %, 212568 bytes)
(-3.7 %, 212589 bytes)
(-3.7 %, 212610 bytes)
(-3.8 %, 212631 bytes)
(-3.8 %, 212652 bytes)
(-3.8 %, 212673 bytes)
(-3.8 %, 212694 bytes)
(-3.8 %, 212715 bytes)
(-3.8 %, 212736 bytes)
(-3.8 %, 212757 bytes)
(-3.8 %, 212778 bytes)
(-3.8 %, 212799 bytes)
(-3.8 %, 212820 bytes)
(-3.9 %, 212841 bytes)
(-3.9 %, 212862 bytes)
(-3.9 %, 212883 bytes)
(-3.9 %, 212904 bytes)
(-3.9 %, 212925 bytes)
(-3.9 %, 212946 bytes)
(-3.9 %, 212967 bytes)
(-3.9 %, 212988 bytes)
(-3.9 %, 213009 bytes)
(-3.9 %, 213030 bytes)
(-4.0 %, 213051 bytes)
(-4.0 %, 213072 bytes)
(-4.0 %, 213093 bytes)
(-4.0 %, 213114 bytes)
(-4.0 %, 213135 bytes)
(-4.0 %, 213156 bytes)
sh: 0: getcwd() failed: No such file or directory
(-4.0 %, 213177 bytes)
(-4.0 %, 213198 bytes)
(-4.0 %, 213219 bytes)
(-4.1 %, 213240 bytes)
(-4.1 %, 213261 bytes)
(-4.1 %, 213282 bytes)
(-4.1 %, 213303 bytes)
(-4.1 %, 213324 bytes)
(-4.1 %, 213345 bytes)
(-4.1 %, 213366 bytes)
(-4.1 %, 213387 bytes)
(-4.1 %, 213408 bytes)
(-4.1 %, 213429 bytes)
(-4.2 %, 213450 bytes)
(-4.2 %, 213471 bytes)
(-4.2 %, 213492 bytes)
(-4.2 %, 213513 bytes)
(-4.2 %, 213534 bytes)
(-4.2 %, 213555 bytes)
(-4.2 %, 213576 bytes)
(-4.2 %, 213597 bytes)
(-4.2 %, 213618 bytes)
(-4.2 %, 213639 bytes)
(-4.3 %, 213660 bytes)
(-4.3 %, 213681 bytes)
(-4.3 %, 213702 bytes)
(-4.3 %, 213723 bytes)
(-4.3 %, 213744 bytes)
(-4.3 %, 213765 bytes)
(-4.3 %, 213786 bytes)
(-4.3 %, 213807 bytes)
(-4.3 %, 213828 bytes)
(-4.3 %, 213849 bytes)
(-4.4 %, 213870 bytes)
(-4.4 %, 213891 bytes)
(-4.4 %, 213912 bytes)
(-4.4 %, 213933 bytes)
(-4.4 %, 213954 bytes)
(-4.4 %, 213975 bytes)
(-4.4 %, 213996 bytes)
(-4.4 %, 214017 bytes)
(-4.4 %, 214038 bytes)
(-4.5 %, 214059 bytes)
(-4.5 %, 214080 bytes)
(-4.5 %, 214101 bytes)
(-4.5 %, 214122 bytes)
(-4.5 %, 214143 bytes)
(-4.5 %, 214164 bytes)
(-4.5 %, 214185 bytes)
(-4.5 %, 214206 bytes)
(-4.5 %, 214227 bytes)
(-4.5 %, 214248 bytes)
(-4.6 %, 214269 bytes)
(-4.6 %, 214290 bytes)
(-4.6 %, 214311 bytes)
(-4.6 %, 214332 bytes)
(-4.6 %, 214353 bytes)
(-4.6 %, 214374 bytes)
(-4.6 %, 214395 bytes)
(-4.6 %, 214416 bytes)
(-4.6 %, 214437 bytes)
(-4.6 %, 214458 bytes)
(-4.7 %, 214479 bytes)
(-4.7 %, 214500 bytes)
(-4.7 %, 214521 bytes)
(-4.7 %, 214542 bytes)
(-4.7 %, 214563 bytes)
(-4.7 %, 214584 bytes)
(-4.7 %, 214605 bytes)
(-4.7 %, 214626 bytes)
(-4.7 %, 214647 bytes)
(-4.7 %, 214668 bytes)
(-4.8 %, 214689 bytes)
(-4.8 %, 214710 bytes)
(-4.8 %, 214731 bytes)
(-4.8 %, 214752 bytes)
(-4.8 %, 214773 bytes)
(-4.8 %, 214794 bytes)
(-4.8 %, 214815 bytes)
(-4.8 %, 214836 bytes)
(-4.8 %, 214857 bytes)
(-4.9 %, 214878 bytes)
(-4.9 %, 214899 bytes)
(-4.9 %, 214920 bytes)
(-4.9 %, 214941 bytes)
(-4.9 %, 214962 bytes)
(-4.9 %, 214983 bytes)
(-4.9 %, 215004 bytes)
(-4.9 %, 215025 bytes)
(-4.9 %, 215046 bytes)
(-4.9 %, 215067 bytes)
(-5.0 %, 215088 bytes)
(-5.0 %, 215109 bytes)
(-5.0 %, 215130 bytes)
(-5.0 %, 215151 bytes)
(-5.0 %, 215172 bytes)
(-5.0 %, 215193 bytes)
(-5.0 %, 215214 bytes)
(-5.0 %, 215235 bytes)
(-5.0 %, 215256 bytes)
(-5.0 %, 215277 bytes)
(-5.1 %, 215298 bytes)
(-5.1 %, 215319 bytes)
(-5.1 %, 215340 bytes)
(-5.1 %, 215361 bytes)
(-5.1 %, 215382 bytes)
(-5.1 %, 215403 bytes)
(-5.1 %, 215424 bytes)
(-5.1 %, 215445 bytes)
(-5.1 %, 215466 bytes)
(-5.1 %, 215487 bytes)
(-5.2 %, 215508 bytes)
(-5.2 %, 215529 bytes)
(-5.2 %, 215550 bytes)
(-5.2 %, 215571 bytes)
(-5.2 %, 215592 bytes)
(-5.2 %, 215613 bytes)
(-5.2 %, 215634 bytes)
(-5.2 %, 215655 bytes)
(-5.2 %, 215676 bytes)
(-5.3 %, 215697 bytes)
(-5.3 %, 215718 bytes)
(-5.3 %, 215739 bytes)
(-5.3 %, 215760 bytes)
(-5.3 %, 215781 bytes)
(-5.3 %, 215802 bytes)
(-5.3 %, 215823 bytes)
(-5.3 %, 215844 bytes)
(-5.3 %, 215865 bytes)
(-5.3 %, 215886 bytes)
(-5.4 %, 215907 bytes)
(-5.4 %, 215928 bytes)
(-5.4 %, 215949 bytes)
(-5.4 %, 215970 bytes)
(-5.4 %, 215991 bytes)
(-5.4 %, 216012 bytes)
(-5.4 %, 216033 bytes)
(-5.4 %, 216054 bytes)
(-5.4 %, 216075 bytes)
(-5.4 %, 216096 bytes)
(-5.5 %, 216117 bytes)
(-5.5 %, 216138 bytes)
(-5.5 %, 216159 bytes)
(-5.5 %, 216180 bytes)
(-5.5 %, 216201 bytes)
(-5.5 %, 216222 bytes)
(-5.5 %, 216243 bytes)
(-5.5 %, 216264 bytes)
(-5.5 %, 216285 bytes)
(-5.5 %, 216306 bytes)
(-5.6 %, 216327 bytes)
(-5.6 %, 216348 bytes)
(-5.6 %, 216369 bytes)
(-5.6 %, 216390 bytes)
(-5.6 %, 216411 bytes)
(-5.6 %, 216432 bytes)
(-5.6 %, 216453 bytes)
(-5.6 %, 216474 bytes)
(-5.6 %, 216495 bytes)
(-5.7 %, 216516 bytes)
(-5.7 %, 216537 bytes)
(-5.7 %, 216558 bytes)
(-5.7 %, 216579 bytes)
(-5.7 %, 216600 bytes)
(-5.7 %, 216621 bytes)
(-5.7 %, 216642 bytes)
(-5.7 %, 216663 bytes)
(-5.7 %, 216684 bytes)
(-5.7 %, 216705 bytes)
(-5.8 %, 216726 bytes)
(-5.8 %, 216747 bytes)
(-5.8 %, 216768 bytes)
(-5.8 %, 216789 bytes)
(-5.8 %, 216810 bytes)
(-5.8 %, 216831 bytes)
(-5.8 %, 216852 bytes)
(-5.8 %, 216873 bytes)
(-5.8 %, 216894 bytes)
(-5.8 %, 216915 bytes)
(-5.9 %, 216936 bytes)
(-5.9 %, 216957 bytes)
(-5.9 %, 216978 bytes)
(-5.9 %, 216999 bytes)
(-5.9 %, 217020 bytes)
(-5.9 %, 217041 bytes)
(-5.9 %, 217062 bytes)
(-5.9 %, 217083 bytes)
(-5.9 %, 217104 bytes)
(-5.9 %, 217125 bytes)
(-6.0 %, 217146 bytes)
(-6.0 %, 217167 bytes)
(-6.0 %, 217188 bytes)
(-6.0 %, 217209 bytes)
(-6.0 %, 217230 bytes)
(-6.0 %, 217251 bytes)
(-6.0 %, 217272 bytes)
(-6.0 %, 217293 bytes)
(-6.0 %, 217314 bytes)
(-6.1 %, 217335 bytes)
(-6.1 %, 217356 bytes)
(-6.1 %, 217377 bytes)
(-6.1 %, 217398 bytes)
(-6.1 %, 217419 bytes)
(-6.1 %, 217440 bytes)
(-6.1 %, 217461 bytes)
(-6.1 %, 217482 bytes)
(-6.1 %, 217503 bytes)
(-6.1 %, 217524 bytes)
(-6.2 %, 217545 bytes)
(-6.2 %, 217566 bytes)
(-6.2 %, 217587 bytes)
(-6.2 %, 217608 bytes)
(-6.2 %, 217629 bytes)
(-6.2 %, 217650 bytes)
(-6.2 %, 217671 bytes)
(-6.2 %, 217692 bytes)
(-6.2 %, 217713 bytes)
(-6.2 %, 217734 bytes)
(-6.3 %, 217755 bytes)
(-6.3 %, 217776 bytes)
(-6.3 %, 217797 bytes)
(-6.3 %, 217818 bytes)
(-6.3 %, 217839 bytes)
(-6.3 %, 217860 bytes)
(-6.3 %, 217881 bytes)
(-6.3 %, 217902 bytes)
(-6.3 %, 217923 bytes)
(-6.3 %, 217944 bytes)
(-6.4 %, 217965 bytes)
(-6.4 %, 217986 bytes)
(-6.4 %, 218007 bytes)
(-6.4 %, 218028 bytes)
(-6.4 %, 218049 bytes)
(-6.4 %, 218070 bytes)
(-6.4 %, 218091 bytes)
(-6.4 %, 218112 bytes)
(-6.4 %, 218133 bytes)
(-6.4 %, 218154 bytes)
(-6.5 %, 218175 bytes)
(-6.5 %, 218196 bytes)
(-6.5 %, 218217 bytes)
(-6.5 %, 218238 bytes)
(-6.5 %, 218259 bytes)
(-6.5 %, 218280 bytes)
(-6.5 %, 218301 bytes)
(-6.5 %, 218322 bytes)
(-6.5 %, 218343 bytes)
(-6.6 %, 218364 bytes)
(-6.6 %, 218385 bytes)
(-6.6 %, 218406 bytes)
(-6.6 %, 218427 bytes)
(-6.6 %, 218448 bytes)
(-6.6 %, 218469 bytes)
(-6.6 %, 218490 bytes)
(-6.6 %, 218511 bytes)
(-6.6 %, 218532 bytes)
(-6.6 %, 218553 bytes)
(-6.7 %, 218574 bytes)
(-6.7 %, 218595 bytes)
(-6.7 %, 218616 bytes)
(-6.7 %, 218637 bytes)
(-6.7 %, 218658 bytes)
(-6.7 %, 218679 bytes)
(-6.7 %, 218700 bytes)
(-6.7 %, 218721 bytes)
(-6.7 %, 218742 bytes)
(-6.7 %, 218763 bytes)
(-6.8 %, 218784 bytes)
(-6.8 %, 218805 bytes)
(-6.8 %, 218826 bytes)
(-6.8 %, 218847 bytes)
(-6.8 %, 218868 bytes)
(-6.8 %, 218889 bytes)
(-6.8 %, 218910 bytes)
(-6.8 %, 218931 bytes)
(-6.8 %, 218952 bytes)
(-6.8 %, 218973 bytes)
(-6.9 %, 218994 bytes)
(-6.9 %, 219015 bytes)
(-6.9 %, 219036 bytes)
(-6.9 %, 219057 bytes)
(-6.9 %, 219078 bytes)
(-6.9 %, 219099 bytes)
(-6.9 %, 219120 bytes)
(-6.9 %, 219141 bytes)
(-6.9 %, 219162 bytes)
(-7.0 %, 219183 bytes)
(-7.0 %, 219204 bytes)
(-7.0 %, 219225 bytes)
(-7.0 %, 219246 bytes)
(-7.0 %, 219267 bytes)
(-7.0 %, 219288 bytes)
(-7.0 %, 219309 bytes)
(-7.0 %, 219330 bytes)
(-7.0 %, 219351 bytes)
(-7.0 %, 219372 bytes)
(-7.1 %, 219393 bytes)
(-7.1 %, 219414 bytes)
(-7.1 %, 219435 bytes)
(-7.1 %, 219456 bytes)
(-7.1 %, 219477 bytes)
(-7.1 %, 219498 bytes)
(-7.1 %, 219519 bytes)
(-7.1 %, 219540 bytes)
(-7.1 %, 219561 bytes)
(-7.1 %, 219582 bytes)
(-7.2 %, 219603 bytes)
(-7.2 %, 219624 bytes)
(-7.2 %, 219645 bytes)
(-7.2 %, 219666 bytes)
(-7.2 %, 219687 bytes)
(-7.2 %, 219708 bytes)
(-7.2 %, 219729 bytes)
(-7.2 %, 219750 bytes)
(-7.2 %, 219771 bytes)
(-7.2 %, 219792 bytes)
(-7.3 %, 219813 bytes)
(-7.3 %, 219834 bytes)
(-7.3 %, 219855 bytes)
(-7.3 %, 219876 bytes)
(-7.3 %, 219897 bytes)
(-7.3 %, 219918 bytes)
(-7.3 %, 219939 bytes)
(-7.3 %, 219960 bytes)
(-7.3 %, 219981 bytes)
(-7.4 %, 220002 bytes)
(-7.4 %, 220023 bytes)
(-7.4 %, 220044 bytes)
(-7.4 %, 220065 bytes)
(-7.4 %, 220086 bytes)
(-7.4 %, 220107 bytes)
(-7.4 %, 220128 bytes)
(-7.4 %, 220149 bytes)
(-7.4 %, 220170 bytes)
(-7.4 %, 220191 bytes)
(-7.5 %, 220212 bytes)
(-7.5 %, 220233 bytes)
(-7.5 %, 220254 bytes)
(-7.5 %, 220275 bytes)
(-7.5 %, 220296 bytes)
(-7.5 %, 220317 bytes)
(-7.5 %, 220338 bytes)
(-7.5 %, 220359 bytes)
(-7.5 %, 220380 bytes)
(-7.5 %, 220401 bytes)
(-7.6 %, 220422 bytes)
(-7.6 %, 220443 bytes)
(-7.6 %, 220464 bytes)
(-7.6 %, 220485 bytes)
(-7.6 %, 220506 bytes)
(-7.6 %, 220527 bytes)
(-7.6 %, 220548 bytes)
(-7.6 %, 220569 bytes)
(-7.6 %, 220590 bytes)
(-7.6 %, 220611 bytes)
(-7.7 %, 220632 bytes)
(-7.7 %, 220653 bytes)
(-7.7 %, 220674 bytes)
(-7.7 %, 220695 bytes)
(-7.7 %, 220716 bytes)
(-7.7 %, 220737 bytes)
(-7.7 %, 220758 bytes)
(-7.7 %, 220779 bytes)
(-7.7 %, 220800 bytes)
(-7.8 %, 220821 bytes)
(-7.8 %, 220842 bytes)
(-7.8 %, 220863 bytes)
(-7.8 %, 220884 bytes)
(-7.8 %, 220905 bytes)
(-7.8 %, 220926 bytes)
(-7.8 %, 220947 bytes)
(-7.8 %, 220968 bytes)
(-7.8 %, 220989 bytes)
(-7.8 %, 221010 bytes)
(-7.9 %, 221031 bytes)
(-7.9 %, 221052 bytes)
(-7.9 %, 221073 bytes)
(-7.9 %, 221094 bytes)
(-7.9 %, 221115 bytes)
(-7.9 %, 221136 bytes)
(-7.9 %, 221157 bytes)
(-7.9 %, 221178 bytes)
(-7.9 %, 221199 bytes)
(-7.9 %, 221220 bytes)
(-8.0 %, 221241 bytes)
(-8.0 %, 221262 bytes)
(-8.0 %, 221283 bytes)
(-8.0 %, 221304 bytes)
(-8.0 %, 221325 bytes)
(-8.0 %, 221346 bytes)
(-8.0 %, 221367 bytes)
(-8.0 %, 221388 bytes)
(-8.0 %, 221409 bytes)
(-8.0 %, 221430 bytes)
(-8.1 %, 221451 bytes)
(-8.1 %, 221472 bytes)
(-8.1 %, 221493 bytes)
(-8.1 %, 221514 bytes)
(-8.1 %, 221535 bytes)
(-8.1 %, 221556 bytes)
(-8.1 %, 221577 bytes)
(-8.1 %, 221598 bytes)
(-8.1 %, 221619 bytes)
(-8.2 %, 221640 bytes)
(-8.2 %, 221661 bytes)
(-8.2 %, 221682 bytes)
(-8.2 %, 221703 bytes)
(-8.2 %, 221724 bytes)
(-8.2 %, 221745 bytes)
(-8.2 %, 221766 bytes)
(-8.2 %, 221787 bytes)
(-8.2 %, 221808 bytes)
(-8.2 %, 221829 bytes)
(-8.3 %, 221850 bytes)
(-8.3 %, 221871 bytes)
(-8.3 %, 221892 bytes)
(-8.3 %, 221913 bytes)
(-8.3 %, 221934 bytes)
(-8.3 %, 221955 bytes)
(-8.3 %, 221976 bytes)
(-8.3 %, 221997 bytes)
(-8.3 %, 222018 bytes)
(-8.3 %, 222039 bytes)
(-8.4 %, 222060 bytes)
(-8.4 %, 222081 bytes)
(-8.4 %, 222102 bytes)
(-8.4 %, 222123 bytes)
(-8.4 %, 222144 bytes)
(-8.4 %, 222165 bytes)
(-8.4 %, 222186 bytes)
(-8.4 %, 222207 bytes)
(-8.4 %, 222228 bytes)
(-8.4 %, 222249 bytes)
(-8.5 %, 222270 bytes)
(-8.5 %, 222291 bytes)
(-8.5 %, 222312 bytes)
(-8.5 %, 222333 bytes)
(-8.5 %, 222354 bytes)
(-8.5 %, 222375 bytes)
(-8.5 %, 222396 bytes)
(-8.5 %, 222417 bytes)
(-8.5 %, 222438 bytes)
(-8.6 %, 222459 bytes)
(-8.6 %, 222480 bytes)
(-8.6 %, 222501 bytes)
(-8.6 %, 222522 bytes)
(-8.6 %, 222543 bytes)
(-8.6 %, 222564 bytes)
(-8.6 %, 222585 bytes)
(-8.6 %, 222606 bytes)
(-8.6 %, 222627 bytes)
(-8.6 %, 222648 bytes)
(-8.7 %, 222669 bytes)
(-8.7 %, 222690 bytes)
(-8.7 %, 222711 bytes)
(-8.7 %, 222732 bytes)
(-8.7 %, 222753 bytes)
(-8.7 %, 222774 bytes)
(-8.7 %, 222795 bytes)
(-8.7 %, 222816 bytes)
(-8.7 %, 222837 bytes)
(-8.7 %, 222858 bytes)
(-8.8 %, 222879 bytes)
(-8.8 %, 222900 bytes)
(-8.8 %, 222921 bytes)
(-8.8 %, 222942 bytes)
(-8.8 %, 222963 bytes)
(-8.8 %, 222984 bytes)
(-8.8 %, 223005 bytes)
(-8.8 %, 223026 bytes)
(-8.8 %, 223047 bytes)
(-8.8 %, 223068 bytes)
(-8.9 %, 223089 bytes)
(-8.9 %, 223110 bytes)
(-8.9 %, 223131 bytes)
(-8.9 %, 223152 bytes)
(-8.9 %, 223173 bytes)
(-8.9 %, 223194 bytes)
(-8.9 %, 223215 bytes)
(-8.9 %, 223236 bytes)
(-8.9 %, 223257 bytes)
(-9.0 %, 223278 bytes)
(-9.0 %, 223299 bytes)
(-9.0 %, 223320 bytes)
(-9.0 %, 223341 bytes)
(-9.0 %, 223362 bytes)
(-9.0 %, 223383 bytes)
(-9.0 %, 223404 bytes)
(-9.0 %, 223425 bytes)
(-9.0 %, 223446 bytes)
(-9.0 %, 223467 bytes)
(-9.1 %, 223488 bytes)
(-9.1 %, 223509 bytes)
(-9.1 %, 223530 bytes)
(-9.1 %, 223551 bytes)
(-9.1 %, 223572 bytes)
(-9.1 %, 223593 bytes)
(-9.1 %, 223614 bytes)
(-9.1 %, 223635 bytes)
(-9.1 %, 223656 bytes)
(-9.1 %, 223677 bytes)
(-9.2 %, 223698 bytes)
(-9.2 %, 223719 bytes)
(-9.2 %, 223740 bytes)
(-9.2 %, 223761 bytes)
(-9.2 %, 223782 bytes)
(-9.2 %, 223803 bytes)
(-9.2 %, 223824 bytes)
(-9.2 %, 223845 bytes)
(-9.2 %, 223866 bytes)
(-9.2 %, 223887 bytes)
(-9.3 %, 223908 bytes)
(-9.3 %, 223929 bytes)
(-9.3 %, 223950 bytes)
(-9.3 %, 223971 bytes)
(-9.3 %, 223992 bytes)
(-9.3 %, 224013 bytes)
(-9.3 %, 224034 bytes)
(-9.3 %, 224055 bytes)
(-9.3 %, 224076 bytes)
(-9.3 %, 224097 bytes)
(-9.4 %, 224118 bytes)
(-9.4 %, 224139 bytes)
(-9.4 %, 224160 bytes)
(-9.4 %, 224181 bytes)
(-9.4 %, 224202 bytes)
(-9.4 %, 224223 bytes)
(-9.4 %, 224244 bytes)
(-9.4 %, 224265 bytes)
(-9.4 %, 224286 bytes)
(-9.5 %, 224307 bytes)
(-9.5 %, 224328 bytes)
(-9.5 %, 224349 bytes)
(-9.5 %, 224370 bytes)
(-9.5 %, 224391 bytes)
(-9.5 %, 224412 bytes)
(-9.5 %, 224433 bytes)
(-9.5 %, 224454 bytes)
(-9.5 %, 224475 bytes)
(-9.5 %, 224496 bytes)
(-9.6 %, 224517 bytes)
(-9.6 %, 224538 bytes)
(-9.6 %, 224559 bytes)
(-9.6 %, 224580 bytes)
(-9.6 %, 224601 bytes)
(-9.6 %, 224622 bytes)
(-9.6 %, 224643 bytes)
(-9.6 %, 224664 bytes)
(-9.6 %, 224685 bytes)
(-9.6 %, 224706 bytes)
(-9.7 %, 224727 bytes)
(-9.7 %, 224748 bytes)
(-9.7 %, 224769 bytes)
(-9.7 %, 224790 bytes)
(-9.7 %, 224811 bytes)
(-9.7 %, 224832 bytes)
(-9.7 %, 224853 bytes)
(-9.7 %, 224874 bytes)
(-9.7 %, 224895 bytes)
(-9.7 %, 224916 bytes)
(-9.8 %, 224937 bytes)
(-9.8 %, 224958 bytes)
(-9.8 %, 224979 bytes)
(-9.8 %, 225000 bytes)
(-9.8 %, 225021 bytes)
(-9.8 %, 225042 bytes)
(-9.8 %, 225063 bytes)
(-9.8 %, 225084 bytes)
(-9.8 %, 225105 bytes)
(-9.9 %, 225126 bytes)
(-9.9 %, 225147 bytes)
(-9.9 %, 225168 bytes)
(-9.9 %, 225189 bytes)
(-9.9 %, 225210 bytes)
(-9.9 %, 225231 bytes)
(-9.9 %, 225252 bytes)
(-9.9 %, 225273 bytes)
(-9.9 %, 225294 bytes)
(-9.9 %, 225315 bytes)
(-10.0 %, 225336 bytes)
(-10.0 %, 225357 bytes)
(-10.0 %, 225378 bytes)
(-10.0 %, 225399 bytes)
(-10.0 %, 225420 bytes)
(-10.0 %, 225441 bytes)
(-10.0 %, 225462 bytes)
(-10.0 %, 225483 bytes)
(-10.0 %, 225504 bytes)
(-10.0 %, 225525 bytes)
(-10.1 %, 225546 bytes)
(-10.1 %, 225567 bytes)
(-10.1 %, 225588 bytes)
(-10.1 %, 225609 bytes)
(-10.1 %, 225630 bytes)
(-10.1 %, 225651 bytes)
(-10.1 %, 225672 bytes)
(-10.1 %, 225693 bytes)
(-10.1 %, 225714 bytes)
(-10.1 %, 225735 bytes)
(-10.2 %, 225756 bytes)
(-10.2 %, 225777 bytes)
(-10.2 %, 225798 bytes)
(-10.2 %, 225819 bytes)
(-10.2 %, 225840 bytes)
(-10.2 %, 225861 bytes)
(-10.2 %, 225882 bytes)
(-10.2 %, 225903 bytes)
(-10.2 %, 225924 bytes)
(-10.3 %, 225945 bytes)
(-10.3 %, 225966 bytes)
(-10.3 %, 225987 bytes)
(-10.3 %, 226008 bytes)
(-10.3 %, 226029 bytes)
(-10.3 %, 226050 bytes)
(-10.3 %, 226071 bytes)
(-10.3 %, 226092 bytes)
(-10.3 %, 226113 bytes)
(-10.3 %, 226134 bytes)
(-10.4 %, 226155 bytes)
(-10.4 %, 226176 bytes)
(-10.4 %, 226197 bytes)
(-10.4 %, 226218 bytes)
(-10.4 %, 226239 bytes)
(-10.4 %, 226260 bytes)
(-10.4 %, 226281 bytes)
(-10.4 %, 226302 bytes)
(-10.4 %, 226323 bytes)
(-10.4 %, 226344 bytes)
(-10.5 %, 226365 bytes)
(-10.5 %, 226386 bytes)
(-10.5 %, 226407 bytes)
(-10.5 %, 226428 bytes)
(-10.5 %, 226449 bytes)
(-10.5 %, 226470 bytes)
(-10.5 %, 226491 bytes)
(-10.5 %, 226512 bytes)
(-10.5 %, 226533 bytes)
(-10.5 %, 226554 bytes)
(-10.6 %, 226575 bytes)
(-10.6 %, 226596 bytes)
(-10.6 %, 226617 bytes)
(-10.6 %, 226638 bytes)
(-10.6 %, 226659 bytes)
(-10.6 %, 226680 bytes)
(-10.6 %, 226701 bytes)
(-10.6 %, 226722 bytes)
(-10.6 %, 226743 bytes)
(-10.7 %, 226764 bytes)
(-10.7 %, 226785 bytes)
(-10.7 %, 226806 bytes)
(-10.7 %, 226827 bytes)
(-10.7 %, 226848 bytes)
(-10.7 %, 226869 bytes)
(-10.7 %, 226890 bytes)
(-10.7 %, 226911 bytes)
(-10.7 %, 226932 bytes)
(-10.7 %, 226953 bytes)
(-10.8 %, 226974 bytes)
(-10.8 %, 226995 bytes)
(-10.8 %, 227016 bytes)
(-10.8 %, 227037 bytes)
(-10.8 %, 227058 bytes)
(-10.8 %, 227079 bytes)
(-10.8 %, 227100 bytes)
(-10.8 %, 227121 bytes)
(-10.8 %, 227142 bytes)
(-10.8 %, 227163 bytes)
(-10.9 %, 227184 bytes)
(-10.9 %, 227205 bytes)
(-10.9 %, 227226 bytes)
(-10.9 %, 227247 bytes)
(-10.9 %, 227268 bytes)
(-10.9 %, 227289 bytes)
(-10.9 %, 227310 bytes)
(-10.9 %, 227331 bytes)
(-10.9 %, 227352 bytes)
(-10.9 %, 227373 bytes)
(-11.0 %, 227394 bytes)
(-11.0 %, 227415 bytes)
(-11.0 %, 227436 bytes)
(-11.0 %, 227457 bytes)
(-11.0 %, 227478 bytes)
(-11.0 %, 227499 bytes)
(-11.0 %, 227520 bytes)
(-11.0 %, 227541 bytes)
(-11.0 %, 227562 bytes)
(-11.1 %, 227583 bytes)
(-11.1 %, 227604 bytes)
(-11.1 %, 227625 bytes)
(-11.1 %, 227646 bytes)
(-11.1 %, 227667 bytes)
(-11.1 %, 227688 bytes)
(-11.1 %, 227709 bytes)
(-11.1 %, 227730 bytes)
(-11.1 %, 227751 bytes)
(-11.1 %, 227772 bytes)
(-11.2 %, 227793 bytes)
(-11.2 %, 227814 bytes)
(-11.2 %, 227835 bytes)
(-11.2 %, 227856 bytes)
(-11.2 %, 227877 bytes)
(-11.2 %, 227898 bytes)
(-11.2 %, 227919 bytes)
(-11.2 %, 227940 bytes)
(-11.2 %, 227961 bytes)
(-11.2 %, 227982 bytes)
(-11.3 %, 228003 bytes)
(-11.3 %, 228024 bytes)
(-11.3 %, 228045 bytes)
(-11.3 %, 228066 bytes)
(-11.3 %, 228087 bytes)
(-11.3 %, 228108 bytes)
(-11.3 %, 228129 bytes)
(-11.3 %, 228150 bytes)
(-11.3 %, 228171 bytes)
(-11.3 %, 228192 bytes)
(-11.4 %, 228213 bytes)
(-11.4 %, 228234 bytes)
(-11.4 %, 228255 bytes)
(-11.4 %, 228276 bytes)
(-11.4 %, 228297 bytes)
(-11.4 %, 228318 bytes)
(-11.4 %, 228339 bytes)
(-11.4 %, 228360 bytes)
(-11.4 %, 228381 bytes)
(-11.5 %, 228402 bytes)
(-11.5 %, 228423 bytes)
(-11.5 %, 228444 bytes)
(-11.5 %, 228465 bytes)
(-11.5 %, 228486 bytes)
(-11.5 %, 228507 bytes)
(-11.5 %, 228528 bytes)
(-11.5 %, 228549 bytes)
(-11.5 %, 228570 bytes)
(-11.5 %, 228591 bytes)
(-11.6 %, 228612 bytes)
(-11.6 %, 228633 bytes)
(-11.6 %, 228654 bytes)
(-11.6 %, 228675 bytes)
(-11.6 %, 228696 bytes)
(-11.6 %, 228717 bytes)
(-11.6 %, 228738 bytes)
(-11.6 %, 228759 bytes)
(-11.6 %, 228780 bytes)
(-11.6 %, 228801 bytes)
(-11.7 %, 228822 bytes)
(-11.7 %, 228843 bytes)
(-11.7 %, 228864 bytes)
(-11.7 %, 228885 bytes)
(-11.7 %, 228906 bytes)
(-11.7 %, 228927 bytes)
(-11.7 %, 228948 bytes)
(-11.7 %, 228969 bytes)
(-11.7 %, 228990 bytes)
(-11.7 %, 229011 bytes)
(-11.8 %, 229032 bytes)
(-11.8 %, 229053 bytes)
(-11.8 %, 229074 bytes)
(-11.8 %, 229095 bytes)
(-11.8 %, 229116 bytes)
(-11.8 %, 229137 bytes)
(-11.8 %, 229158 bytes)
(-11.8 %, 229179 bytes)
(-11.8 %, 229200 bytes)
(-11.9 %, 229221 bytes)
(-11.9 %, 229242 bytes)
(-11.9 %, 229263 bytes)
(-11.9 %, 229284 bytes)
(-11.9 %, 229305 bytes)
(-11.9 %, 229326 bytes)
(-11.9 %, 229347 bytes)
(-11.9 %, 229368 bytes)
(-11.9 %, 229389 bytes)
(-11.9 %, 229410 bytes)
(-12.0 %, 229431 bytes)
(-12.0 %, 229452 bytes)
(-12.0 %, 229473 bytes)
(-12.0 %, 229494 bytes)
(-12.0 %, 229515 bytes)
(-12.0 %, 229536 bytes)
(-12.0 %, 229557 bytes)
(-12.0 %, 229578 bytes)
(-12.0 %, 229599 bytes)
(-12.0 %, 229620 bytes)
(-12.1 %, 229641 bytes)
(-12.1 %, 229662 bytes)
(-12.1 %, 229683 bytes)
(-12.1 %, 229704 bytes)
(-12.1 %, 229725 bytes)
(-12.1 %, 229746 bytes)
(-12.1 %, 229767 bytes)
(-12.1 %, 229788 bytes)
(-12.1 %, 229809 bytes)
(-12.1 %, 229830 bytes)
(-12.2 %, 229851 bytes)
(-12.2 %, 229872 bytes)
(-12.2 %, 229893 bytes)
(-12.2 %, 229914 bytes)
(-12.2 %, 229935 bytes)
(-12.2 %, 229956 bytes)
(-12.2 %, 229977 bytes)
(-12.2 %, 229998 bytes)
(-12.2 %, 230019 bytes)
(-12.2 %, 230040 bytes)
(-12.3 %, 230061 bytes)
(-12.3 %, 230082 bytes)
(-12.3 %, 230103 bytes)
(-12.3 %, 230124 bytes)
(-12.3 %, 230145 bytes)
(-12.3 %, 230166 bytes)
(-12.3 %, 230187 bytes)
(-12.3 %, 230208 bytes)
(-12.3 %, 230229 bytes)
(-12.4 %, 230250 bytes)
(-12.4 %, 230271 bytes)
(-12.4 %, 230292 bytes)
(-12.4 %, 230313 bytes)
(-12.4 %, 230334 bytes)
(-12.4 %, 230355 bytes)
(-12.4 %, 230376 bytes)
(-12.4 %, 230397 bytes)
(-12.4 %, 230418 bytes)
(-12.4 %, 230439 bytes)
(-12.5 %, 230460 bytes)
(-12.5 %, 230481 bytes)
(-12.5 %, 230502 bytes)
(-12.5 %, 230523 bytes)
(-12.5 %, 230544 bytes)
(-12.5 %, 230565 bytes)
(-12.5 %, 230586 bytes)
(-12.5 %, 230607 bytes)
(-12.5 %, 230628 bytes)
(-12.5 %, 230649 bytes)
(-12.6 %, 230670 bytes)
(-12.6 %, 230691 bytes)
(-12.6 %, 230712 bytes)
(-12.6 %, 230733 bytes)
(-12.6 %, 230754 bytes)
(-12.6 %, 230775 bytes)
(-12.6 %, 230796 bytes)
(-12.6 %, 230817 bytes)
(-12.6 %, 230838 bytes)
(-12.6 %, 230859 bytes)
(-12.7 %, 230880 bytes)
(-12.7 %, 230901 bytes)
(-12.7 %, 230922 bytes)
(-12.7 %, 230943 bytes)
(-12.7 %, 230964 bytes)
(-12.7 %, 230985 bytes)
(-12.7 %, 231006 bytes)
(-12.7 %, 231027 bytes)
(-12.7 %, 231048 bytes)
(-12.8 %, 231069 bytes)
(-12.8 %, 231090 bytes)
(-12.8 %, 231111 bytes)
(-12.8 %, 231132 bytes)
(-12.8 %, 231153 bytes)
(-12.8 %, 231174 bytes)
(-12.8 %, 231195 bytes)
(-12.8 %, 231216 bytes)
(-12.8 %, 231237 bytes)
(-12.8 %, 231258 bytes)
(-12.9 %, 231279 bytes)
(-12.9 %, 231300 bytes)
(-12.9 %, 231321 bytes)
(-12.9 %, 231342 bytes)
(-12.9 %, 231363 bytes)
(-12.9 %, 231384 bytes)
(-12.9 %, 231405 bytes)
(-12.9 %, 231426 bytes)
(-12.9 %, 231447 bytes)
(-12.9 %, 231468 bytes)
(-13.0 %, 231489 bytes)
(-13.0 %, 231510 bytes)
(-13.0 %, 231531 bytes)
(-13.0 %, 231552 bytes)
(-13.0 %, 231573 bytes)
(-13.0 %, 231594 bytes)
(-13.0 %, 231615 bytes)
(-13.0 %, 231636 bytes)
(-13.0 %, 231657 bytes)
(-13.0 %, 231678 bytes)
(-13.1 %, 231699 bytes)
(-13.1 %, 231720 bytes)
(-13.1 %, 231741 bytes)
(-13.1 %, 231762 bytes)
(-13.1 %, 231783 bytes)
(-13.1 %, 231804 bytes)
(-13.1 %, 231825 bytes)
(-13.1 %, 231846 bytes)
(-13.1 %, 231867 bytes)
(-13.2 %, 231888 bytes)
(-13.2 %, 231909 bytes)
(-13.2 %, 231930 bytes)
(-13.2 %, 231951 bytes)
(-13.2 %, 231972 bytes)
(-13.2 %, 231993 bytes)
(-13.2 %, 232014 bytes)
(-13.2 %, 232035 bytes)
(-13.2 %, 232056 bytes)
(-13.2 %, 232077 bytes)
(-13.3 %, 232098 bytes)
(-13.3 %, 232119 bytes)
(-13.3 %, 232140 bytes)
(-13.3 %, 232161 bytes)
(-13.3 %, 232182 bytes)
(-13.3 %, 232203 bytes)
(-13.3 %, 232224 bytes)
(-13.3 %, 232245 bytes)
(-13.3 %, 232266 bytes)
(-13.3 %, 232287 bytes)
(-13.4 %, 232308 bytes)
(-13.4 %, 232329 bytes)
(-13.4 %, 232350 bytes)
(-13.4 %, 232371 bytes)
(-13.4 %, 232392 bytes)
(-13.4 %, 232413 bytes)
(-13.4 %, 232434 bytes)
(-13.4 %, 232455 bytes)
(-13.4 %, 232476 bytes)
(-13.4 %, 232497 bytes)
(-13.5 %, 232518 bytes)
(-13.5 %, 232539 bytes)
(-13.5 %, 232560 bytes)
(-13.5 %, 232581 bytes)
(-13.5 %, 232602 bytes)
(-13.5 %, 232623 bytes)
(-13.5 %, 232644 bytes)
(-13.5 %, 232665 bytes)
(-13.5 %, 232686 bytes)
(-13.6 %, 232707 bytes)
(-13.6 %, 232728 bytes)
(-13.6 %, 232749 bytes)
(-13.6 %, 232770 bytes)
(-13.6 %, 232791 bytes)
(-13.6 %, 232812 bytes)
(-13.6 %, 232833 bytes)
(-13.6 %, 232854 bytes)
(-13.6 %, 232875 bytes)
(-13.6 %, 232896 bytes)
(-13.7 %, 232917 bytes)
(-13.7 %, 232938 bytes)
(-13.7 %, 232959 bytes)
(-13.7 %, 232980 bytes)
(-13.7 %, 233001 bytes)
(-13.7 %, 233022 bytes)
(-13.7 %, 233043 bytes)
(-13.7 %, 233064 bytes)
(-13.7 %, 233085 bytes)
(-13.7 %, 233106 bytes)
(-13.8 %, 233127 bytes)
(-13.8 %, 233148 bytes)
(-13.8 %, 233169 bytes)
(-13.8 %, 233190 bytes)
(-13.8 %, 233211 bytes)
(-13.8 %, 233232 bytes)
(-13.8 %, 233253 bytes)
(-13.8 %, 233274 bytes)
(-13.8 %, 233295 bytes)
(-13.8 %, 233316 bytes)
(-13.9 %, 233337 bytes)
(-13.9 %, 233358 bytes)
(-13.9 %, 233379 bytes)
(-13.9 %, 233400 bytes)
(-13.9 %, 233421 bytes)
(-13.9 %, 233442 bytes)
(-13.9 %, 233463 bytes)
(-13.9 %, 233484 bytes)
(-13.9 %, 233505 bytes)
(-14.0 %, 233526 bytes)
(-14.0 %, 233547 bytes)
(-14.0 %, 233568 bytes)
(-14.0 %, 233589 bytes)
(-14.0 %, 233610 bytes)
(-14.0 %, 233631 bytes)
(-14.0 %, 233652 bytes)
(-14.0 %, 233673 bytes)
(-14.0 %, 233694 bytes)
(-14.0 %, 233715 bytes)
(-14.1 %, 233736 bytes)
(-14.1 %, 233757 bytes)
(-14.1 %, 233778 bytes)
(-14.1 %, 233799 bytes)
(-14.1 %, 233820 bytes)
(-14.1 %, 233841 bytes)
(-14.1 %, 233862 bytes)
(-14.1 %, 233883 bytes)
(-14.1 %, 233904 bytes)
(-14.1 %, 233925 bytes)
(-14.2 %, 233946 bytes)
(-14.2 %, 233967 bytes)
(-14.2 %, 233988 bytes)
(-14.2 %, 234009 bytes)
(-14.2 %, 234030 bytes)
(-14.2 %, 234051 bytes)
(-14.2 %, 234072 bytes)
(-14.2 %, 234093 bytes)
(-14.2 %, 234114 bytes)
(-14.2 %, 234135 bytes)
(-14.3 %, 234156 bytes)
(-14.3 %, 234177 bytes)
(-14.3 %, 234198 bytes)
(-14.3 %, 234219 bytes)
(-14.3 %, 234240 bytes)
(-14.3 %, 234261 bytes)
(-14.3 %, 234282 bytes)
(-14.3 %, 234303 bytes)
(-14.3 %, 234324 bytes)
(-14.4 %, 234345 bytes)
(-14.4 %, 234366 bytes)
(-14.4 %, 234387 bytes)
(-14.4 %, 234408 bytes)
(-14.4 %, 234429 bytes)
(-14.4 %, 234450 bytes)
(-14.4 %, 234471 bytes)
(-14.4 %, 234492 bytes)
(-14.4 %, 234513 bytes)
(-14.4 %, 234534 bytes)
(-14.5 %, 234555 bytes)
(-14.5 %, 234576 bytes)
(-14.5 %, 234597 bytes)
(-14.5 %, 234618 bytes)
(-14.5 %, 234639 bytes)
(-14.5 %, 234660 bytes)
(-14.5 %, 234681 bytes)
(-14.5 %, 234702 bytes)
(-14.5 %, 234723 bytes)
(-14.5 %, 234744 bytes)
(-14.6 %, 234765 bytes)
(-14.6 %, 234786 bytes)
(-14.6 %, 234807 bytes)
(-14.6 %, 234828 bytes)
(-14.6 %, 234849 bytes)
(-14.6 %, 234870 bytes)
(-14.6 %, 234891 bytes)
(-14.6 %, 234912 bytes)
(-14.6 %, 234933 bytes)
(-14.6 %, 234954 bytes)
(-14.7 %, 234975 bytes)
(-14.7 %, 234996 bytes)
(-14.7 %, 235017 bytes)
(-14.7 %, 235038 bytes)
(-14.7 %, 235059 bytes)
(-14.7 %, 235080 bytes)
(-14.7 %, 235101 bytes)
(-14.7 %, 235122 bytes)
(-14.7 %, 235143 bytes)
(-14.7 %, 235164 bytes)
(-14.8 %, 235185 bytes)
(-14.8 %, 235206 bytes)
(-14.8 %, 235227 bytes)
(-14.8 %, 235248 bytes)
(-14.8 %, 235269 bytes)
(-14.8 %, 235290 bytes)
(-14.8 %, 235311 bytes)
(-14.8 %, 235332 bytes)
(-14.8 %, 235353 bytes)
(-14.9 %, 235374 bytes)
(-14.9 %, 235395 bytes)
(-14.9 %, 235416 bytes)
(-14.9 %, 235437 bytes)
(-14.9 %, 235458 bytes)
(-14.9 %, 235479 bytes)
(-14.9 %, 235500 bytes)
(-14.9 %, 235521 bytes)
(-14.9 %, 235542 bytes)
(-14.9 %, 235563 bytes)
(-15.0 %, 235584 bytes)
(-15.0 %, 235605 bytes)
(-15.0 %, 235626 bytes)
(-15.0 %, 235647 bytes)
(-15.0 %, 235668 bytes)
(-15.0 %, 235689 bytes)
(-15.0 %, 235710 bytes)
(-15.0 %, 235731 bytes)
(-15.0 %, 235752 bytes)
(-15.0 %, 235773 bytes)
(-15.1 %, 235794 bytes)
(-15.1 %, 235815 bytes)
(-15.1 %, 235836 bytes)
(-15.1 %, 235857 bytes)
(-15.1 %, 235878 bytes)
(-15.1 %, 235899 bytes)
(-15.1 %, 235920 bytes)
(-15.1 %, 235941 bytes)
(-15.1 %, 235962 bytes)
(-15.1 %, 235983 bytes)
(-15.2 %, 236004 bytes)
(-15.2 %, 236025 bytes)
(-15.2 %, 236046 bytes)
(-15.2 %, 236067 bytes)
(-15.2 %, 236088 bytes)
(-15.2 %, 236109 bytes)
(-15.2 %, 236130 bytes)
(-15.2 %, 236151 bytes)
(-15.2 %, 236172 bytes)
(-15.3 %, 236193 bytes)
(-15.3 %, 236214 bytes)
(-15.3 %, 236235 bytes)
(-15.3 %, 236256 bytes)
(-15.3 %, 236277 bytes)
(-15.3 %, 236298 bytes)
(-15.3 %, 236319 bytes)
(-15.3 %, 236340 bytes)
(-15.3 %, 236361 bytes)
(-15.3 %, 236382 bytes)
(-15.4 %, 236403 bytes)
(-15.4 %, 236424 bytes)
(-15.4 %, 236445 bytes)
(-15.4 %, 236466 bytes)
(-15.4 %, 236487 bytes)
(-15.4 %, 236508 bytes)
(-15.4 %, 236529 bytes)
(-15.4 %, 236550 bytes)
(-15.4 %, 236571 bytes)
(-15.4 %, 236592 bytes)
(-15.5 %, 236613 bytes)
(-15.5 %, 236634 bytes)
(-15.5 %, 236655 bytes)
(-15.5 %, 236676 bytes)
(-15.5 %, 236697 bytes)
(-15.5 %, 236718 bytes)
(-15.5 %, 236739 bytes)
(-15.5 %, 236760 bytes)
(-15.5 %, 236781 bytes)
(-15.5 %, 236802 bytes)
(-15.6 %, 236823 bytes)
(-15.6 %, 236844 bytes)
(-15.6 %, 236865 bytes)
(-15.6 %, 236886 bytes)
(-15.6 %, 236907 bytes)
(-15.6 %, 236928 bytes)
(-15.6 %, 236949 bytes)
(-15.6 %, 236970 bytes)
(-15.6 %, 236991 bytes)
(-15.7 %, 237012 bytes)
(-15.7 %, 237033 bytes)
(-15.7 %, 237054 bytes)
(-15.7 %, 237075 bytes)
(-15.7 %, 237096 bytes)
(-15.7 %, 237117 bytes)
(-15.7 %, 237138 bytes)
(-15.7 %, 237159 bytes)
(-15.7 %, 237180 bytes)
(-15.7 %, 237201 bytes)
(-15.8 %, 237222 bytes)
(-15.8 %, 237243 bytes)
(-15.8 %, 237264 bytes)
(-15.8 %, 237285 bytes)
(-15.8 %, 237306 bytes)
(-15.8 %, 237327 bytes)
(-15.8 %, 237348 bytes)
(-15.8 %, 237369 bytes)
(-15.8 %, 237390 bytes)
(-15.8 %, 237411 bytes)
(-15.9 %, 237432 bytes)
(-15.9 %, 237453 bytes)
(-15.9 %, 237474 bytes)
(-15.9 %, 237495 bytes)
(-15.9 %, 237516 bytes)
(-15.9 %, 237537 bytes)
(-15.9 %, 237558 bytes)
(-15.9 %, 237579 bytes)
(-15.9 %, 237600 bytes)
(-15.9 %, 237621 bytes)
(-16.0 %, 237642 bytes)
(-16.0 %, 237663 bytes)
(-16.0 %, 237684 bytes)
(-16.0 %, 237705 bytes)
(-16.0 %, 237726 bytes)
(-16.0 %, 237747 bytes)
(-16.0 %, 237768 bytes)
(-16.0 %, 237789 bytes)
(-16.0 %, 237810 bytes)
(-16.1 %, 237831 bytes)
(-16.1 %, 237852 bytes)
(-16.1 %, 237873 bytes)
(-16.1 %, 237894 bytes)
(-16.1 %, 237915 bytes)
(-16.1 %, 237936 bytes)
(-16.1 %, 237957 bytes)
(-16.1 %, 237978 bytes)
(-16.1 %, 237999 bytes)
(-16.1 %, 238020 bytes)
(-16.2 %, 238041 bytes)
(-16.2 %, 238062 bytes)
(-16.2 %, 238083 bytes)
(-16.2 %, 238104 bytes)
(-16.2 %, 238125 bytes)
(-16.2 %, 238146 bytes)
(-16.2 %, 238167 bytes)
(-16.2 %, 238188 bytes)
(-16.2 %, 238209 bytes)
(-16.2 %, 238230 bytes)
(-16.3 %, 238251 bytes)
(-16.3 %, 238272 bytes)
(-16.3 %, 238293 bytes)
(-16.3 %, 238314 bytes)
(-16.3 %, 238335 bytes)
(-16.3 %, 238356 bytes)
(-16.3 %, 238377 bytes)
(-16.3 %, 238398 bytes)
(-16.3 %, 238419 bytes)
(-16.3 %, 238440 bytes)
(-16.4 %, 238461 bytes)
(-16.4 %, 238482 bytes)
(-16.4 %, 238503 bytes)
(-16.4 %, 238524 bytes)
(-16.4 %, 238545 bytes)
(-16.4 %, 238566 bytes)
(-16.4 %, 238587 bytes)
(-16.4 %, 238608 bytes)
(-16.4 %, 238629 bytes)
(-16.5 %, 238650 bytes)
(-16.5 %, 238671 bytes)
(-16.5 %, 238692 bytes)
(-16.5 %, 238713 bytes)
(-16.5 %, 238734 bytes)
(-16.5 %, 238755 bytes)
(-16.5 %, 238776 bytes)
(-16.5 %, 238797 bytes)
(-16.5 %, 238818 bytes)
(-16.5 %, 238839 bytes)
(-16.6 %, 238860 bytes)
(-16.6 %, 238881 bytes)
(-16.6 %, 238902 bytes)
(-16.6 %, 238923 bytes)
(-16.6 %, 238944 bytes)
(-16.6 %, 238965 bytes)
(-16.6 %, 238986 bytes)
(-16.6 %, 239007 bytes)
(-16.6 %, 239028 bytes)
(-16.6 %, 239049 bytes)
(-16.7 %, 239070 bytes)
(-16.7 %, 239091 bytes)
(-16.7 %, 239112 bytes)
(-16.7 %, 239133 bytes)
(-16.7 %, 239154 bytes)
(-16.7 %, 239175 bytes)
(-16.7 %, 239196 bytes)
(-16.7 %, 239217 bytes)
(-16.7 %, 239238 bytes)
(-16.7 %, 239259 bytes)
(-16.8 %, 239280 bytes)
(-16.8 %, 239301 bytes)
(-16.8 %, 239322 bytes)
(-16.8 %, 239343 bytes)
(-16.8 %, 239364 bytes)
(-16.8 %, 239385 bytes)
(-16.8 %, 239406 bytes)
(-16.8 %, 239427 bytes)
(-16.8 %, 239448 bytes)
(-16.9 %, 239469 bytes)
(-16.9 %, 239490 bytes)
(-16.9 %, 239511 bytes)
(-16.9 %, 239532 bytes)
(-16.9 %, 239553 bytes)
(-16.9 %, 239574 bytes)
(-16.9 %, 239595 bytes)
(-16.9 %, 239616 bytes)
(-16.9 %, 239637 bytes)
(-16.9 %, 239658 bytes)
(-17.0 %, 239679 bytes)
(-17.0 %, 239700 bytes)
(-17.0 %, 239721 bytes)
(-17.0 %, 239742 bytes)
(-17.0 %, 239763 bytes)
(-17.0 %, 239784 bytes)
(-17.0 %, 239805 bytes)
(-17.0 %, 239826 bytes)
(-17.0 %, 239847 bytes)
(-17.0 %, 239868 bytes)
(-17.1 %, 239889 bytes)
(-17.1 %, 239910 bytes)
(-17.1 %, 239931 bytes)
(-17.1 %, 239952 bytes)
(-17.1 %, 239973 bytes)
(-17.1 %, 239994 bytes)
(-17.1 %, 240015 bytes)
(-17.1 %, 240036 bytes)
(-17.1 %, 240057 bytes)
(-17.1 %, 240078 bytes)
(-17.2 %, 240099 bytes)
(-17.2 %, 240120 bytes)
(-17.2 %, 240141 bytes)
(-17.2 %, 240162 bytes)
(-17.2 %, 240183 bytes)
(-17.2 %, 240204 bytes)
(-17.2 %, 240225 bytes)
(-17.2 %, 240246 bytes)
(-17.2 %, 240267 bytes)
(-17.3 %, 240288 bytes)
(-17.3 %, 240309 bytes)
(-17.3 %, 240330 bytes)
(-17.3 %, 240351 bytes)
(-17.3 %, 240372 bytes)
(-17.3 %, 240393 bytes)
(-17.3 %, 240414 bytes)
(-17.3 %, 240435 bytes)
(-17.3 %, 240456 bytes)
(-17.3 %, 240477 bytes)
(-17.4 %, 240498 bytes)
(-17.4 %, 240519 bytes)
(-17.4 %, 240540 bytes)
(-17.4 %, 240561 bytes)
(-17.4 %, 240582 bytes)
(-17.4 %, 240603 bytes)
(-17.4 %, 240624 bytes)
(-17.4 %, 240645 bytes)
(-17.4 %, 240666 bytes)
(-17.4 %, 240687 bytes)
(-17.5 %, 240708 bytes)
(-17.5 %, 240729 bytes)
(-17.5 %, 240750 bytes)
(-17.5 %, 240771 bytes)
(-17.5 %, 240792 bytes)
(-17.5 %, 240813 bytes)
(-17.5 %, 240834 bytes)
(-17.5 %, 240855 bytes)
(-17.5 %, 240876 bytes)
(-17.5 %, 240897 bytes)
(-17.6 %, 240918 bytes)
(-17.6 %, 240939 bytes)
(-17.6 %, 240960 bytes)
(-17.6 %, 240981 bytes)
(-17.6 %, 241002 bytes)
(-17.6 %, 241023 bytes)
(-17.6 %, 241044 bytes)
(-17.6 %, 241065 bytes)
(-17.6 %, 241086 bytes)
(-17.6 %, 241107 bytes)
(-17.7 %, 241128 bytes)
(-17.7 %, 241149 bytes)
(-17.7 %, 241170 bytes)
(-17.7 %, 241191 bytes)
(-17.7 %, 241212 bytes)
(-17.7 %, 241233 bytes)
(-17.7 %, 241254 bytes)
(-17.7 %, 241275 bytes)
(-17.7 %, 241296 bytes)
(-17.8 %, 241317 bytes)
(-17.8 %, 241338 bytes)
(-17.8 %, 241359 bytes)
(-17.8 %, 241380 bytes)
(-17.8 %, 241401 bytes)
(-17.8 %, 241422 bytes)
(-17.8 %, 241443 bytes)
(-17.8 %, 241464 bytes)
(-17.8 %, 241485 bytes)
(-17.8 %, 241506 bytes)
(-17.9 %, 241527 bytes)
(-17.9 %, 241548 bytes)
(-17.9 %, 241569 bytes)
(-17.9 %, 241590 bytes)
(-17.9 %, 241611 bytes)
(-17.9 %, 241632 bytes)
(-17.9 %, 241653 bytes)
(-17.9 %, 241674 bytes)
(-17.9 %, 241695 bytes)
(-17.9 %, 241716 bytes)
(-18.0 %, 241737 bytes)
(-18.0 %, 241758 bytes)
(-18.0 %, 241779 bytes)
(-18.0 %, 241800 bytes)
(-18.0 %, 241821 bytes)
(-18.0 %, 241842 bytes)
(-18.0 %, 241863 bytes)
(-18.0 %, 241884 bytes)
(-18.0 %, 241905 bytes)
(-18.0 %, 241926 bytes)
(-18.1 %, 241947 bytes)
(-18.1 %, 241968 bytes)
(-18.1 %, 241989 bytes)
(-18.1 %, 242010 bytes)
(-18.1 %, 242031 bytes)
(-18.1 %, 242052 bytes)
(-18.1 %, 242073 bytes)
(-18.1 %, 242094 bytes)
(-18.1 %, 242115 bytes)
(-18.2 %, 242136 bytes)
(-18.2 %, 242157 bytes)
(-18.2 %, 242178 bytes)
(-18.2 %, 242199 bytes)
(-18.2 %, 242220 bytes)
(-18.2 %, 242241 bytes)
(-18.2 %, 242262 bytes)
(-18.2 %, 242283 bytes)
(-18.2 %, 242304 bytes)
(-18.2 %, 242325 bytes)
(-18.3 %, 242346 bytes)
(-18.3 %, 242367 bytes)
(-18.3 %, 242388 bytes)
(-18.3 %, 242409 bytes)
(-18.3 %, 242430 bytes)
(-18.3 %, 242451 bytes)
(-18.3 %, 242472 bytes)
(-18.3 %, 242493 bytes)
(-18.3 %, 242514 bytes)
(-18.3 %, 242535 bytes)
(-18.4 %, 242556 bytes)
(-18.4 %, 242577 bytes)
(-18.4 %, 242598 bytes)
(-18.4 %, 242619 bytes)
(-18.4 %, 242640 bytes)
(-18.4 %, 242661 bytes)
(-18.4 %, 242682 bytes)
(-18.4 %, 242703 bytes)
(-18.4 %, 242724 bytes)
(-18.4 %, 242745 bytes)
(-18.5 %, 242766 bytes)
(-18.5 %, 242787 bytes)
(-18.5 %, 242808 bytes)
(-18.5 %, 242829 bytes)
(-18.5 %, 242850 bytes)
(-18.5 %, 242871 bytes)
(-18.5 %, 242892 bytes)
(-18.5 %, 242913 bytes)
(-18.5 %, 242934 bytes)
(-18.6 %, 242955 bytes)
(-18.6 %, 242976 bytes)
(-18.6 %, 242997 bytes)
(-18.6 %, 243018 bytes)
(-18.6 %, 243039 bytes)
(-18.6 %, 243060 bytes)
(-18.6 %, 243081 bytes)
(-18.6 %, 243102 bytes)
(-18.6 %, 243123 bytes)
(-18.6 %, 243144 bytes)
(-18.7 %, 243165 bytes)
(-18.7 %, 243186 bytes)
(-18.7 %, 243207 bytes)
(-18.7 %, 243228 bytes)
(-18.7 %, 243249 bytes)
(-18.7 %, 243270 bytes)
(-18.7 %, 243291 bytes)
(-18.7 %, 243312 bytes)
(-18.7 %, 243333 bytes)
(-18.7 %, 243354 bytes)
(-18.8 %, 243375 bytes)
(-18.8 %, 243396 bytes)
(-18.8 %, 243417 bytes)
(-18.8 %, 243438 bytes)
(-18.8 %, 243459 bytes)
(-18.8 %, 243480 bytes)
(-18.8 %, 243501 bytes)
(-18.8 %, 243522 bytes)
(-18.8 %, 243543 bytes)
(-18.8 %, 243564 bytes)
(-18.9 %, 243585 bytes)
(-18.9 %, 243606 bytes)
(-18.9 %, 243627 bytes)
(-18.9 %, 243648 bytes)
(-18.9 %, 243669 bytes)
(-18.9 %, 243690 bytes)
(-18.9 %, 243711 bytes)
(-18.9 %, 243732 bytes)
(-18.9 %, 243753 bytes)
(-19.0 %, 243774 bytes)
(-19.0 %, 243795 bytes)
(-19.0 %, 243816 bytes)
(-19.0 %, 243837 bytes)
(-19.0 %, 243858 bytes)
(-19.0 %, 243879 bytes)
(-19.0 %, 243900 bytes)
(-19.0 %, 243921 bytes)
(-19.0 %, 243942 bytes)
(-19.0 %, 243963 bytes)
(-19.1 %, 243984 bytes)
(-19.1 %, 244005 bytes)
(-19.1 %, 244026 bytes)
(-19.1 %, 244047 bytes)
(-19.1 %, 244068 bytes)
(-19.1 %, 244089 bytes)
(-19.1 %, 244110 bytes)
(-19.1 %, 244131 bytes)
(-19.1 %, 244152 bytes)
(-19.1 %, 244173 bytes)
(-19.2 %, 244194 bytes)
(-19.2 %, 244215 bytes)
(-19.2 %, 244236 bytes)
(-19.2 %, 244257 bytes)
(-19.2 %, 244278 bytes)
(-19.2 %, 244299 bytes)
(-19.2 %, 244320 bytes)
(-19.2 %, 244341 bytes)
(-19.2 %, 244362 bytes)
(-19.2 %, 244383 bytes)
(-19.3 %, 244404 bytes)
(-19.3 %, 244425 bytes)
(-19.3 %, 244446 bytes)
(-19.3 %, 244467 bytes)
(-19.3 %, 244488 bytes)
(-19.3 %, 244509 bytes)
(-19.3 %, 244530 bytes)
(-19.3 %, 244551 bytes)
(-19.3 %, 244572 bytes)
(-19.4 %, 244593 bytes)
(-19.4 %, 244614 bytes)
(-19.4 %, 244635 bytes)
(-19.4 %, 244656 bytes)
(-19.4 %, 244677 bytes)
(-19.4 %, 244698 bytes)
(-19.4 %, 244719 bytes)
(-19.4 %, 244740 bytes)
(-19.4 %, 244761 bytes)
(-19.4 %, 244782 bytes)
(-19.5 %, 244803 bytes)
(-19.5 %, 244824 bytes)
(-19.5 %, 244845 bytes)
(-19.5 %, 244866 bytes)
(-19.5 %, 244887 bytes)
(-19.5 %, 244908 bytes)
(-19.5 %, 244929 bytes)
(-19.5 %, 244950 bytes)
(-19.5 %, 244971 bytes)
(-19.5 %, 244992 bytes)
(-19.6 %, 245013 bytes)
(-19.6 %, 245034 bytes)
(-19.6 %, 245055 bytes)
(-19.6 %, 245076 bytes)
(-19.6 %, 245097 bytes)
(-19.6 %, 245118 bytes)
(-19.6 %, 245139 bytes)
(-19.6 %, 245160 bytes)
(-19.6 %, 245181 bytes)
(-19.6 %, 245202 bytes)
(-19.7 %, 245223 bytes)
(-19.7 %, 245244 bytes)
(-19.7 %, 245265 bytes)
(-19.7 %, 245286 bytes)
(-19.7 %, 245307 bytes)
(-19.7 %, 245328 bytes)
(-19.7 %, 245349 bytes)
(-19.7 %, 245370 bytes)
(-19.7 %, 245391 bytes)
(-19.8 %, 245412 bytes)
(-19.8 %, 245433 bytes)
(-19.8 %, 245454 bytes)
(-19.8 %, 245475 bytes)
(-19.8 %, 245496 bytes)
(-19.8 %, 245517 bytes)
(-19.8 %, 245538 bytes)
(-19.8 %, 245559 bytes)
(-19.8 %, 245580 bytes)
(-19.8 %, 245601 bytes)
(-19.9 %, 245622 bytes)
(-19.9 %, 245643 bytes)
(-19.9 %, 245664 bytes)
(-19.9 %, 245685 bytes)
(-19.9 %, 245706 bytes)
(-19.9 %, 245727 bytes)
(-19.9 %, 245748 bytes)
(-19.9 %, 245769 bytes)
(-19.9 %, 245790 bytes)
(-19.9 %, 245811 bytes)
(-20.0 %, 245832 bytes)
(-20.0 %, 245853 bytes)
(-20.0 %, 245874 bytes)
(-20.0 %, 245895 bytes)
(-20.0 %, 245916 bytes)
(-20.0 %, 245937 bytes)
(-20.0 %, 245958 bytes)
(-20.0 %, 245979 bytes)
(-20.0 %, 246000 bytes)
(-20.0 %, 246021 bytes)
(-20.1 %, 246042 bytes)
(-20.1 %, 246063 bytes)
(-20.1 %, 246084 bytes)
(-20.1 %, 246105 bytes)
(-20.1 %, 246126 bytes)
(-20.1 %, 246147 bytes)
(-20.1 %, 246168 bytes)
(-20.1 %, 246189 bytes)
(-20.1 %, 246210 bytes)
(-20.2 %, 246231 bytes)
(-20.2 %, 246252 bytes)
(-20.2 %, 246273 bytes)
(-20.2 %, 246294 bytes)
(-20.2 %, 246315 bytes)
(-20.2 %, 246336 bytes)
(-20.2 %, 246357 bytes)
(-20.2 %, 246378 bytes)
(-20.2 %, 246399 bytes)
(-20.2 %, 246420 bytes)
(-20.3 %, 246441 bytes)
(-20.3 %, 246462 bytes)
(-20.3 %, 246483 bytes)
(-20.3 %, 246504 bytes)
(-20.3 %, 246525 bytes)
(-20.3 %, 246546 bytes)
(-20.3 %, 246567 bytes)
(-20.3 %, 246588 bytes)
(-20.3 %, 246609 bytes)
(-20.3 %, 246630 bytes)
(-20.4 %, 246651 bytes)
(-20.4 %, 246672 bytes)
(-20.4 %, 246693 bytes)
(-20.4 %, 246714 bytes)
(-20.4 %, 246735 bytes)
(-20.4 %, 246756 bytes)
(-20.4 %, 246777 bytes)
(-20.4 %, 246798 bytes)
(-20.4 %, 246819 bytes)
(-20.4 %, 246840 bytes)
(-20.5 %, 246861 bytes)
(-20.5 %, 246882 bytes)
(-20.5 %, 246903 bytes)
(-20.5 %, 246924 bytes)
(-20.5 %, 246945 bytes)
(-20.5 %, 246966 bytes)
(-20.5 %, 246987 bytes)
(-20.5 %, 247008 bytes)
(-20.5 %, 247029 bytes)
(-20.5 %, 247050 bytes)
(-20.6 %, 247071 bytes)
(-20.6 %, 247092 bytes)
(-20.6 %, 247113 bytes)
(-20.6 %, 247134 bytes)
(-20.6 %, 247155 bytes)
(-20.6 %, 247176 bytes)
(-20.6 %, 247197 bytes)
(-20.6 %, 247218 bytes)
(-20.6 %, 247239 bytes)
(-20.7 %, 247260 bytes)
(-20.7 %, 247281 bytes)
(-20.7 %, 247302 bytes)
(-20.7 %, 247323 bytes)
(-20.7 %, 247344 bytes)
(-20.7 %, 247365 bytes)
(-20.7 %, 247386 bytes)
(-20.7 %, 247407 bytes)
(-20.7 %, 247428 bytes)
(-20.7 %, 247449 bytes)
(-20.8 %, 247470 bytes)
(-20.8 %, 247491 bytes)
(-20.8 %, 247512 bytes)
(-20.8 %, 247533 bytes)
(-20.8 %, 247554 bytes)
(-20.8 %, 247575 bytes)
(-20.8 %, 247596 bytes)
(-20.8 %, 247617 bytes)
(-20.8 %, 247638 bytes)
(-20.8 %, 247659 bytes)
(-20.9 %, 247680 bytes)
(-20.9 %, 247701 bytes)
(-20.9 %, 247722 bytes)
(-20.9 %, 247743 bytes)
(-20.9 %, 247764 bytes)
(-20.9 %, 247785 bytes)
(-20.9 %, 247806 bytes)
(-20.9 %, 247827 bytes)
(-20.9 %, 247848 bytes)
(-20.9 %, 247869 bytes)
(-21.0 %, 247890 bytes)
(-21.0 %, 247911 bytes)
(-21.0 %, 247932 bytes)
(-21.0 %, 247953 bytes)
(-21.0 %, 247974 bytes)
(-21.0 %, 247995 bytes)
(-21.0 %, 248016 bytes)
(-21.0 %, 248037 bytes)
(-21.0 %, 248058 bytes)
(-21.1 %, 248079 bytes)
(-21.1 %, 248100 bytes)
(-21.1 %, 248121 bytes)
(-21.1 %, 248142 bytes)
(-21.1 %, 248163 bytes)
(-21.1 %, 248184 bytes)
(-21.1 %, 248205 bytes)
(-21.1 %, 248226 bytes)
(-21.1 %, 248247 bytes)
(-21.1 %, 248268 bytes)
(-21.2 %, 248289 bytes)
(-21.2 %, 248310 bytes)
(-21.2 %, 248331 bytes)
(-21.2 %, 248352 bytes)
(-21.2 %, 248373 bytes)
(-21.2 %, 248394 bytes)
(-21.2 %, 248415 bytes)
(-21.2 %, 248436 bytes)
(-21.2 %, 248457 bytes)
(-21.2 %, 248478 bytes)
(-21.3 %, 248499 bytes)
(-21.3 %, 248520 bytes)
(-21.3 %, 248541 bytes)
(-21.3 %, 248562 bytes)
(-21.3 %, 248583 bytes)
(-21.3 %, 248604 bytes)
(-21.3 %, 248625 bytes)
(-21.3 %, 248646 bytes)
(-21.3 %, 248667 bytes)
(-21.3 %, 248688 bytes)
(-21.4 %, 248709 bytes)
(-21.4 %, 248730 bytes)
(-21.4 %, 248751 bytes)
(-21.4 %, 248772 bytes)
(-21.4 %, 248793 bytes)
(-21.4 %, 248814 bytes)
(-21.4 %, 248835 bytes)
(-21.4 %, 248856 bytes)
(-21.4 %, 248877 bytes)
(-21.5 %, 248898 bytes)
(-21.5 %, 248919 bytes)
(-21.5 %, 248940 bytes)
(-21.5 %, 248961 bytes)
(-21.5 %, 248982 bytes)
(-21.5 %, 249003 bytes)
(-21.5 %, 249024 bytes)
(-21.5 %, 249045 bytes)
(-21.5 %, 249066 bytes)
(-21.5 %, 249087 bytes)
(-21.6 %, 249108 bytes)
(-21.6 %, 249129 bytes)
(-21.6 %, 249150 bytes)
(-21.6 %, 249171 bytes)
(-21.6 %, 249192 bytes)
(-21.6 %, 249213 bytes)
(-21.6 %, 249234 bytes)
(-21.6 %, 249255 bytes)
(-21.6 %, 249276 bytes)
(-21.6 %, 249297 bytes)
(-21.7 %, 249318 bytes)
(-21.7 %, 249339 bytes)
(-21.7 %, 249360 bytes)
(-21.7 %, 249381 bytes)
(-21.7 %, 249402 bytes)
(-21.7 %, 249423 bytes)
(-21.7 %, 249444 bytes)
(-21.7 %, 249465 bytes)
(-21.7 %, 249486 bytes)
(-21.7 %, 249507 bytes)
(-21.8 %, 249528 bytes)
(-21.8 %, 249549 bytes)
(-21.8 %, 249570 bytes)
(-21.8 %, 249591 bytes)
(-21.8 %, 249612 bytes)
(-21.8 %, 249633 bytes)
(-21.8 %, 249654 bytes)
(-21.8 %, 249675 bytes)
(-21.8 %, 249696 bytes)
(-21.9 %, 249717 bytes)
(-21.9 %, 249738 bytes)
(-21.9 %, 249759 bytes)
(-21.9 %, 249780 bytes)
(-21.9 %, 249801 bytes)
(-21.9 %, 249822 bytes)
(-21.9 %, 249843 bytes)
(-21.9 %, 249864 bytes)
(-21.9 %, 249885 bytes)
(-21.9 %, 249906 bytes)
(-22.0 %, 249927 bytes)
(-22.0 %, 249948 bytes)
(-22.0 %, 249969 bytes)
(-22.0 %, 249990 bytes)
(-22.0 %, 250011 bytes)
(-22.0 %, 250032 bytes)
(-22.0 %, 250053 bytes)
(-22.0 %, 250074 bytes)
(-22.0 %, 250095 bytes)
(-22.0 %, 250116 bytes)
(-22.1 %, 250137 bytes)
(-22.1 %, 250158 bytes)
(-22.1 %, 250179 bytes)
(-22.1 %, 250200 bytes)
(-22.1 %, 250221 bytes)
(-22.1 %, 250242 bytes)
(-22.1 %, 250263 bytes)
(-22.1 %, 250284 bytes)
(-22.1 %, 250305 bytes)
(-22.1 %, 250326 bytes)
(-22.2 %, 250347 bytes)
(-22.2 %, 250368 bytes)
(-22.2 %, 250389 bytes)
(-22.2 %, 250410 bytes)
(-22.2 %, 250431 bytes)
(-22.2 %, 250452 bytes)
(-22.2 %, 250473 bytes)
(-22.2 %, 250494 bytes)
(-22.2 %, 250515 bytes)
(-22.3 %, 250536 bytes)
(-22.3 %, 250557 bytes)
(-22.3 %, 250578 bytes)
(-22.3 %, 250599 bytes)
(-22.3 %, 250620 bytes)
(-22.3 %, 250641 bytes)
(-22.3 %, 250662 bytes)
(-22.3 %, 250683 bytes)
(-22.3 %, 250704 bytes)
(-22.3 %, 250725 bytes)
(-22.4 %, 250746 bytes)
(-22.4 %, 250767 bytes)
(-22.4 %, 250788 bytes)
(-22.4 %, 250809 bytes)
(-22.4 %, 250830 bytes)
(-22.4 %, 250851 bytes)
(-22.4 %, 250872 bytes)
(-22.4 %, 250893 bytes)
(-22.4 %, 250914 bytes)
(-22.4 %, 250935 bytes)
(-22.5 %, 250956 bytes)
(-22.5 %, 250977 bytes)
(-22.5 %, 250998 bytes)
(-22.5 %, 251019 bytes)
(-22.5 %, 251040 bytes)
(-22.5 %, 251061 bytes)
(-22.5 %, 251082 bytes)
(-22.5 %, 251103 bytes)
(-22.5 %, 251124 bytes)
(-22.5 %, 251145 bytes)
(-22.6 %, 251166 bytes)
(-22.6 %, 251187 bytes)
(-22.6 %, 251208 bytes)
(-22.6 %, 251229 bytes)
(-22.6 %, 251250 bytes)
(-22.6 %, 251271 bytes)
(-22.6 %, 251292 bytes)
(-22.6 %, 251313 bytes)
(-22.6 %, 251334 bytes)
(-22.7 %, 251355 bytes)
(-22.7 %, 251376 bytes)
(-22.7 %, 251397 bytes)
(-22.7 %, 251418 bytes)
(-22.7 %, 251439 bytes)
(-22.7 %, 251460 bytes)
(-22.7 %, 251481 bytes)
(-22.7 %, 251502 bytes)
(-22.7 %, 251523 bytes)
(-22.7 %, 251544 bytes)
(-22.8 %, 251565 bytes)
(-22.8 %, 251586 bytes)
(-22.8 %, 251607 bytes)
(-22.8 %, 251628 bytes)
(-22.8 %, 251649 bytes)
(-22.8 %, 251670 bytes)
(-22.8 %, 251691 bytes)
(-22.8 %, 251712 bytes)
(-22.8 %, 251733 bytes)
(-22.8 %, 251754 bytes)
(-22.9 %, 251775 bytes)
(-22.9 %, 251796 bytes)
(-22.9 %, 251817 bytes)
(-22.9 %, 251838 bytes)
(-22.9 %, 251859 bytes)
(-22.9 %, 251880 bytes)
(-22.9 %, 251901 bytes)
(-22.9 %, 251922 bytes)
(-22.9 %, 251943 bytes)
(-22.9 %, 251964 bytes)
(-23.0 %, 251985 bytes)
(-23.0 %, 252006 bytes)
(-23.0 %, 252027 bytes)
(-23.0 %, 252048 bytes)
(-23.0 %, 252069 bytes)
(-23.0 %, 252090 bytes)
(-23.0 %, 252111 bytes)
(-23.0 %, 252132 bytes)
(-23.0 %, 252153 bytes)
(-23.1 %, 252174 bytes)
(-23.1 %, 252195 bytes)
(-23.1 %, 252216 bytes)
(-23.1 %, 252237 bytes)
(-23.1 %, 252258 bytes)
(-23.1 %, 252279 bytes)
(-23.1 %, 252300 bytes)
(-23.1 %, 252321 bytes)
(-23.1 %, 252342 bytes)
(-23.1 %, 252363 bytes)
(-23.2 %, 252384 bytes)
(-23.2 %, 252405 bytes)
(-23.2 %, 252426 bytes)
(-23.2 %, 252447 bytes)
(-23.2 %, 252468 bytes)
(-23.2 %, 252489 bytes)
(-23.2 %, 252510 bytes)
(-23.2 %, 252531 bytes)
(-23.2 %, 252552 bytes)
(-23.2 %, 252573 bytes)
(-23.3 %, 252594 bytes)
(-23.3 %, 252615 bytes)
(-23.3 %, 252636 bytes)
(-23.3 %, 252657 bytes)
(-23.3 %, 252678 bytes)
(-23.3 %, 252699 bytes)
(-23.3 %, 252720 bytes)
(-23.3 %, 252741 bytes)
(-23.3 %, 252762 bytes)
(-23.3 %, 252783 bytes)
(-23.4 %, 252804 bytes)
(-23.4 %, 252825 bytes)
(-23.4 %, 252846 bytes)
(-23.4 %, 252867 bytes)
(-23.4 %, 252888 bytes)
(-23.4 %, 252909 bytes)
(-23.4 %, 252930 bytes)
(-23.4 %, 252951 bytes)
(-23.4 %, 252972 bytes)
(-23.4 %, 252993 bytes)
(-23.5 %, 253014 bytes)
(-23.5 %, 253035 bytes)
(-23.5 %, 253056 bytes)
(-23.5 %, 253077 bytes)
(-23.5 %, 253098 bytes)
(-23.5 %, 253119 bytes)
(-23.5 %, 253140 bytes)
(-23.5 %, 253161 bytes)
(-23.5 %, 253182 bytes)
(-23.6 %, 253203 bytes)
(-23.6 %, 253224 bytes)
(-23.6 %, 253245 bytes)
(-23.6 %, 253266 bytes)
(-23.6 %, 253287 bytes)
(-23.6 %, 253308 bytes)
(-23.6 %, 253329 bytes)
(-23.6 %, 253350 bytes)
(-23.6 %, 253371 bytes)
(-23.6 %, 253392 bytes)
(-23.7 %, 253413 bytes)
(-23.7 %, 253434 bytes)
(-23.7 %, 253455 bytes)
(-23.7 %, 253476 bytes)
(-23.7 %, 253497 bytes)
(-23.7 %, 253518 bytes)
(-23.7 %, 253539 bytes)
(-23.7 %, 253560 bytes)
(-23.7 %, 253581 bytes)
(-23.7 %, 253602 bytes)
(-23.8 %, 253623 bytes)
(-23.8 %, 253644 bytes)
(-23.8 %, 253665 bytes)
(-23.8 %, 253686 bytes)
(-23.8 %, 253707 bytes)
(-23.8 %, 253728 bytes)
(-23.8 %, 253749 bytes)
(-23.8 %, 253770 bytes)
(-23.8 %, 253791 bytes)
(-23.8 %, 253812 bytes)
(-23.9 %, 253833 bytes)
(-23.9 %, 253854 bytes)
(-23.9 %, 253875 bytes)
(-23.9 %, 253896 bytes)
(-23.9 %, 253917 bytes)
(-23.9 %, 253938 bytes)
(-23.9 %, 253959 bytes)
(-23.9 %, 253980 bytes)
(-23.9 %, 254001 bytes)
(-24.0 %, 254022 bytes)
(-24.0 %, 254043 bytes)
(-24.0 %, 254064 bytes)
(-24.0 %, 254085 bytes)
(-24.0 %, 254106 bytes)
(-24.0 %, 254127 bytes)
(-24.0 %, 254148 bytes)
(-24.0 %, 254169 bytes)
(-24.0 %, 254190 bytes)
(-24.0 %, 254211 bytes)
(-24.1 %, 254232 bytes)
(-24.1 %, 254253 bytes)
(-24.1 %, 254274 bytes)
(-24.1 %, 254295 bytes)
(-24.1 %, 254316 bytes)
(-24.1 %, 254337 bytes)
(-24.1 %, 254358 bytes)
(-24.1 %, 254379 bytes)
(-24.1 %, 254400 bytes)
(-24.1 %, 254421 bytes)
(-24.2 %, 254442 bytes)
(-24.2 %, 254463 bytes)
(-24.2 %, 254484 bytes)
(-24.2 %, 254505 bytes)
(-24.2 %, 254526 bytes)
(-24.2 %, 254547 bytes)
(-24.2 %, 254568 bytes)
(-24.2 %, 254589 bytes)
(-24.2 %, 254610 bytes)
(-24.2 %, 254631 bytes)
(-24.3 %, 254652 bytes)
(-24.3 %, 254673 bytes)
(-24.3 %, 254694 bytes)
(-24.3 %, 254715 bytes)
(-24.3 %, 254736 bytes)
(-24.3 %, 254757 bytes)
(-24.3 %, 254778 bytes)
(-24.3 %, 254799 bytes)
(-24.3 %, 254820 bytes)
(-24.4 %, 254841 bytes)
(-24.4 %, 254862 bytes)
(-24.4 %, 254883 bytes)
(-24.4 %, 254904 bytes)
(-24.4 %, 254925 bytes)
(-24.4 %, 254946 bytes)
(-24.4 %, 254967 bytes)
(-24.4 %, 254988 bytes)
(-24.4 %, 255009 bytes)
(-24.4 %, 255030 bytes)
(-24.5 %, 255051 bytes)
(-24.5 %, 255072 bytes)
(-24.5 %, 255093 bytes)
(-24.5 %, 255114 bytes)
(-24.5 %, 255135 bytes)
(-24.5 %, 255156 bytes)
(-24.5 %, 255177 bytes)
(-24.5 %, 255198 bytes)
(-24.5 %, 255219 bytes)
(-24.5 %, 255240 bytes)
(-24.6 %, 255261 bytes)
(-24.6 %, 255282 bytes)
(-24.6 %, 255303 bytes)
(-24.6 %, 255324 bytes)
(-24.6 %, 255345 bytes)
(-24.6 %, 255366 bytes)
(-24.6 %, 255387 bytes)
(-24.6 %, 255408 bytes)
(-24.6 %, 255429 bytes)
(-24.6 %, 255450 bytes)
(-24.7 %, 255471 bytes)
(-24.7 %, 255492 bytes)
(-24.7 %, 255513 bytes)
(-24.7 %, 255534 bytes)
(-24.7 %, 255555 bytes)
(-24.7 %, 255576 bytes)
(-24.7 %, 255597 bytes)
(-24.7 %, 255618 bytes)
(-24.7 %, 255639 bytes)
(-24.8 %, 255660 bytes)
(-24.8 %, 255681 bytes)
(-24.8 %, 255702 bytes)
(-24.8 %, 255723 bytes)
(-24.8 %, 255744 bytes)
(-24.8 %, 255765 bytes)
(-24.8 %, 255786 bytes)
(-24.8 %, 255807 bytes)
(-24.8 %, 255828 bytes)
(-24.8 %, 255849 bytes)
(-24.9 %, 255870 bytes)
(-24.9 %, 255891 bytes)
(-24.9 %, 255912 bytes)
(-24.9 %, 255933 bytes)
(-24.9 %, 255954 bytes)
(-24.9 %, 255975 bytes)
(-24.9 %, 255996 bytes)
(-24.9 %, 256017 bytes)
(-24.9 %, 256038 bytes)
(-24.9 %, 256059 bytes)
(-25.0 %, 256080 bytes)
(-25.0 %, 256101 bytes)
(-25.0 %, 256122 bytes)
(-25.0 %, 256143 bytes)
(-25.0 %, 256164 bytes)
(-25.0 %, 256185 bytes)
(-25.0 %, 256206 bytes)
(-25.0 %, 256227 bytes)
(-25.0 %, 256248 bytes)
(-25.0 %, 256269 bytes)
(-25.1 %, 256290 bytes)
(-25.1 %, 256311 bytes)
(-25.1 %, 256332 bytes)
(-25.1 %, 256353 bytes)
(-25.1 %, 256374 bytes)
(-25.1 %, 256395 bytes)
(-25.1 %, 256416 bytes)
(-25.1 %, 256437 bytes)
(-25.1 %, 256458 bytes)
(-25.2 %, 256479 bytes)
(-25.2 %, 256500 bytes)
(-25.2 %, 256521 bytes)
(-25.2 %, 256542 bytes)
(-25.2 %, 256563 bytes)
(-25.2 %, 256584 bytes)
(-25.2 %, 256605 bytes)
(-25.2 %, 256626 bytes)
(-25.2 %, 256647 bytes)
(-25.2 %, 256668 bytes)
(-25.3 %, 256689 bytes)
(-25.3 %, 256710 bytes)
(-25.3 %, 256731 bytes)
(-25.3 %, 256752 bytes)
(-25.3 %, 256773 bytes)
(-25.3 %, 256794 bytes)
(-25.3 %, 256815 bytes)
(-25.3 %, 256836 bytes)
(-25.3 %, 256857 bytes)
(-25.3 %, 256878 bytes)
(-25.4 %, 256899 bytes)
(-25.4 %, 256920 bytes)
(-25.4 %, 256941 bytes)
(-25.4 %, 256962 bytes)
(-25.4 %, 256983 bytes)
(-25.4 %, 257004 bytes)
(-25.4 %, 257025 bytes)
(-25.4 %, 257046 bytes)
(-25.4 %, 257067 bytes)
(-25.4 %, 257088 bytes)
(-25.5 %, 257109 bytes)
(-25.5 %, 257130 bytes)
(-25.5 %, 257151 bytes)
(-25.5 %, 257172 bytes)
(-25.5 %, 257193 bytes)
(-25.5 %, 257214 bytes)
(-25.5 %, 257235 bytes)
(-25.5 %, 257256 bytes)
(-25.5 %, 257277 bytes)
(-25.6 %, 257298 bytes)
(-25.6 %, 257319 bytes)
(-25.6 %, 257340 bytes)
(-25.6 %, 257361 bytes)
(-25.6 %, 257382 bytes)
(-25.6 %, 257403 bytes)
(-25.6 %, 257424 bytes)
(-25.6 %, 257445 bytes)
(-25.6 %, 257466 bytes)
(-25.6 %, 257487 bytes)
(-25.7 %, 257508 bytes)
(-25.7 %, 257529 bytes)
(-25.7 %, 257550 bytes)
(-25.7 %, 257571 bytes)
(-25.7 %, 257592 bytes)
(-25.7 %, 257613 bytes)
(-25.7 %, 257634 bytes)
(-25.7 %, 257655 bytes)
(-25.7 %, 257676 bytes)
(-25.7 %, 257697 bytes)
(-25.8 %, 257718 bytes)
(-25.8 %, 257739 bytes)
(-25.8 %, 257760 bytes)
(-25.8 %, 257781 bytes)
(-25.8 %, 257802 bytes)
(-25.8 %, 257823 bytes)
(-25.8 %, 257844 bytes)
(-25.8 %, 257865 bytes)
(-25.8 %, 257886 bytes)
(-25.8 %, 257907 bytes)
(-25.9 %, 257928 bytes)
(-25.9 %, 257949 bytes)
(-25.9 %, 257970 bytes)
(-25.9 %, 257991 bytes)
(-25.9 %, 258012 bytes)
(-25.9 %, 258033 bytes)
(-25.9 %, 258054 bytes)
(-25.9 %, 258075 bytes)
(-25.9 %, 258096 bytes)
(-26.0 %, 258117 bytes)
(-26.0 %, 258138 bytes)
(-26.0 %, 258159 bytes)
(-26.0 %, 258180 bytes)
(-26.0 %, 258201 bytes)
(-26.0 %, 258222 bytes)
(-26.0 %, 258243 bytes)
(-26.0 %, 258264 bytes)
(-26.0 %, 258285 bytes)
(-26.0 %, 258306 bytes)
(-26.1 %, 258327 bytes)
(-26.1 %, 258348 bytes)
(-26.1 %, 258369 bytes)
(-26.1 %, 258390 bytes)
(-26.1 %, 258411 bytes)
(-26.1 %, 258432 bytes)
(-26.1 %, 258453 bytes)
(-26.1 %, 258474 bytes)
(-26.1 %, 258495 bytes)
(-26.1 %, 258516 bytes)
(-26.2 %, 258537 bytes)
(-26.2 %, 258558 bytes)
(-26.2 %, 258579 bytes)
(-26.2 %, 258600 bytes)
(-26.2 %, 258621 bytes)
(-26.2 %, 258642 bytes)
(-26.2 %, 258663 bytes)
(-26.2 %, 258684 bytes)
(-26.2 %, 258705 bytes)
(-26.2 %, 258726 bytes)
(-26.3 %, 258747 bytes)
(-26.3 %, 258768 bytes)
(-26.3 %, 258789 bytes)
(-26.3 %, 258810 bytes)
(-26.3 %, 258831 bytes)
(-26.3 %, 258852 bytes)
(-26.3 %, 258873 bytes)
(-26.3 %, 258894 bytes)
(-26.3 %, 258915 bytes)
(-26.3 %, 258936 bytes)
(-26.4 %, 258957 bytes)
(-26.4 %, 258978 bytes)
(-26.4 %, 258999 bytes)
(-26.4 %, 259020 bytes)
(-26.4 %, 259041 bytes)
(-26.4 %, 259062 bytes)
(-26.4 %, 259083 bytes)
(-26.4 %, 259104 bytes)
(-26.4 %, 259125 bytes)
(-26.5 %, 259146 bytes)
(-26.5 %, 259167 bytes)
(-26.5 %, 259188 bytes)
(-26.5 %, 259209 bytes)
(-26.5 %, 259230 bytes)
(-26.5 %, 259251 bytes)
(-26.5 %, 259272 bytes)
(-26.5 %, 259293 bytes)
(-26.5 %, 259314 bytes)
(-26.5 %, 259335 bytes)
(-26.6 %, 259356 bytes)
(-26.6 %, 259377 bytes)
(-26.6 %, 259398 bytes)
(-26.6 %, 259419 bytes)
(-26.6 %, 259440 bytes)
(-26.6 %, 259461 bytes)
(-26.6 %, 259482 bytes)
(-26.6 %, 259503 bytes)
(-26.6 %, 259524 bytes)
(-26.6 %, 259545 bytes)
(-26.7 %, 259566 bytes)
(-26.7 %, 259587 bytes)
(-26.7 %, 259608 bytes)
(-26.7 %, 259629 bytes)
(-26.7 %, 259650 bytes)
(-26.7 %, 259671 bytes)
(-26.7 %, 259692 bytes)
(-26.7 %, 259713 bytes)
(-26.7 %, 259734 bytes)
(-26.7 %, 259755 bytes)
(-26.8 %, 259776 bytes)
(-26.8 %, 259797 bytes)
(-26.8 %, 259818 bytes)
(-26.8 %, 259839 bytes)
(-26.8 %, 259860 bytes)
(-26.8 %, 259881 bytes)
(-26.8 %, 259902 bytes)
(-26.8 %, 259923 bytes)
(-26.8 %, 259944 bytes)
(-26.9 %, 259965 bytes)
(-26.9 %, 259986 bytes)
(-26.9 %, 260007 bytes)
(-26.9 %, 260028 bytes)
(-26.9 %, 260049 bytes)
(-26.9 %, 260070 bytes)
(-26.9 %, 260091 bytes)
(-26.9 %, 260112 bytes)
(-26.9 %, 260133 bytes)
(-26.9 %, 260154 bytes)
(-27.0 %, 260175 bytes)
(-27.0 %, 260196 bytes)
(-27.0 %, 260217 bytes)
(-27.0 %, 260238 bytes)
(-27.0 %, 260259 bytes)
(-27.0 %, 260280 bytes)
(-27.0 %, 260301 bytes)
(-27.0 %, 260322 bytes)
(-27.0 %, 260343 bytes)
(-27.0 %, 260364 bytes)
(-27.1 %, 260385 bytes)
(-27.1 %, 260406 bytes)
(-27.1 %, 260427 bytes)
(-27.1 %, 260448 bytes)
(-27.1 %, 260469 bytes)
(-27.1 %, 260490 bytes)
(-27.1 %, 260511 bytes)
(-27.1 %, 260532 bytes)
(-27.1 %, 260553 bytes)
(-27.1 %, 260574 bytes)
(-27.2 %, 260595 bytes)
(-27.2 %, 260616 bytes)
(-27.2 %, 260637 bytes)
(-27.2 %, 260658 bytes)
(-27.2 %, 260679 bytes)
(-27.2 %, 260700 bytes)
(-27.2 %, 260721 bytes)
(-27.2 %, 260742 bytes)
(-27.2 %, 260763 bytes)
(-27.3 %, 260784 bytes)
(-27.3 %, 260805 bytes)
(-27.3 %, 260826 bytes)
(-27.3 %, 260847 bytes)
(-27.3 %, 260868 bytes)
(-27.3 %, 260889 bytes)
(-27.3 %, 260910 bytes)
(-27.3 %, 260931 bytes)
(-27.3 %, 260952 bytes)
(-27.3 %, 260973 bytes)
(-27.4 %, 260994 bytes)
(-27.4 %, 261015 bytes)
(-27.4 %, 261036 bytes)
(-27.4 %, 261057 bytes)
(-27.4 %, 261078 bytes)
(-27.4 %, 261099 bytes)
(-27.4 %, 261120 bytes)
(-27.4 %, 261141 bytes)
(-27.4 %, 261162 bytes)
(-27.4 %, 261183 bytes)
(-27.5 %, 261204 bytes)
(-27.5 %, 261225 bytes)
(-27.5 %, 261246 bytes)
(-27.5 %, 261267 bytes)
(-27.5 %, 261288 bytes)
(-27.5 %, 261309 bytes)
(-27.5 %, 261330 bytes)
(-27.5 %, 261351 bytes)
(-27.5 %, 261372 bytes)
(-27.5 %, 261393 bytes)
(-27.6 %, 261414 bytes)
(-27.6 %, 261435 bytes)
(-27.6 %, 261456 bytes)
(-27.6 %, 261477 bytes)
(-27.6 %, 261498 bytes)
(-27.6 %, 261519 bytes)
(-27.6 %, 261540 bytes)
(-27.6 %, 261561 bytes)
(-27.6 %, 261582 bytes)
(-27.7 %, 261603 bytes)
(-27.7 %, 261624 bytes)
(-27.7 %, 261645 bytes)
(-27.7 %, 261666 bytes)
(-27.7 %, 261687 bytes)
(-27.7 %, 261708 bytes)
(-27.7 %, 261729 bytes)
(-27.7 %, 261750 bytes)
(-27.7 %, 261771 bytes)
(-27.7 %, 261792 bytes)
(-27.8 %, 261813 bytes)
(-27.8 %, 261834 bytes)
(-27.8 %, 261855 bytes)
(-27.8 %, 261876 bytes)
(-27.8 %, 261897 bytes)
(-27.8 %, 261918 bytes)
(-27.8 %, 261939 bytes)
(-27.8 %, 261960 bytes)
(-27.8 %, 261981 bytes)
(-27.8 %, 262002 bytes)
(-27.9 %, 262023 bytes)
(-27.9 %, 262044 bytes)
(-27.9 %, 262065 bytes)
(-27.9 %, 262086 bytes)
(-27.9 %, 262107 bytes)
(-27.9 %, 262128 bytes)
(-27.9 %, 262149 bytes)
(-27.9 %, 262170 bytes)
(-27.9 %, 262191 bytes)
(-27.9 %, 262212 bytes)
(-28.0 %, 262233 bytes)
(-28.0 %, 262254 bytes)
(-28.0 %, 262275 bytes)
(-28.0 %, 262296 bytes)
(-28.0 %, 262317 bytes)
(-28.0 %, 262338 bytes)
(-28.0 %, 262359 bytes)
(-28.0 %, 262380 bytes)
(-28.0 %, 262401 bytes)
(-28.1 %, 262422 bytes)
(-28.1 %, 262443 bytes)
(-28.1 %, 262464 bytes)
(-28.1 %, 262485 bytes)
(-28.1 %, 262506 bytes)
(-28.1 %, 262527 bytes)
(-28.1 %, 262548 bytes)
(-28.1 %, 262569 bytes)
(-28.1 %, 262590 bytes)
(-28.1 %, 262611 bytes)
(-28.2 %, 262632 bytes)
(-28.2 %, 262653 bytes)
(-28.2 %, 262674 bytes)
(-28.2 %, 262695 bytes)
(-28.2 %, 262716 bytes)
(-28.2 %, 262737 bytes)
(-28.2 %, 262758 bytes)
(-28.2 %, 262779 bytes)
(-28.2 %, 262800 bytes)
(-28.2 %, 262821 bytes)
(-28.3 %, 262842 bytes)
(-28.3 %, 262863 bytes)
(-28.3 %, 262884 bytes)
(-28.3 %, 262905 bytes)
(-28.3 %, 262926 bytes)
(-28.3 %, 262947 bytes)
(-28.3 %, 262968 bytes)
(-28.3 %, 262989 bytes)
(-28.3 %, 263010 bytes)
(-28.3 %, 263031 bytes)
(-28.4 %, 263052 bytes)
(-28.4 %, 263073 bytes)
(-28.4 %, 263094 bytes)
(-28.4 %, 263115 bytes)
(-28.4 %, 263136 bytes)
(-28.4 %, 263157 bytes)
(-28.4 %, 263178 bytes)
(-28.4 %, 263199 bytes)
(-28.4 %, 263220 bytes)
(-28.5 %, 263241 bytes)
(-28.5 %, 263262 bytes)
(-28.5 %, 263283 bytes)
(-28.5 %, 263304 bytes)
(-28.5 %, 263325 bytes)
(-28.5 %, 263346 bytes)
(-28.5 %, 263367 bytes)
(-28.5 %, 263388 bytes)
(-28.5 %, 263409 bytes)
(-28.5 %, 263430 bytes)
(-28.6 %, 263451 bytes)
(-28.6 %, 263472 bytes)
(-28.6 %, 263493 bytes)
(-28.6 %, 263514 bytes)
(-28.6 %, 263535 bytes)
(-28.6 %, 263556 bytes)
(-28.6 %, 263577 bytes)
(-28.6 %, 263598 bytes)
(-28.6 %, 263619 bytes)
(-28.6 %, 263640 bytes)
(-28.7 %, 263661 bytes)
(-28.7 %, 263682 bytes)
(-28.7 %, 263703 bytes)
(-28.7 %, 263724 bytes)
(-28.7 %, 263745 bytes)
(-28.7 %, 263766 bytes)
(-28.7 %, 263787 bytes)
(-28.7 %, 263808 bytes)
(-28.7 %, 263829 bytes)
(-28.7 %, 263850 bytes)
(-28.8 %, 263871 bytes)
(-28.8 %, 263892 bytes)
(-28.8 %, 263913 bytes)
(-28.8 %, 263934 bytes)
(-28.8 %, 263955 bytes)
(-28.8 %, 263976 bytes)
(-28.8 %, 263997 bytes)
(-28.8 %, 264018 bytes)
(-28.8 %, 264039 bytes)
(-28.8 %, 264060 bytes)
(-28.9 %, 264081 bytes)
(-28.9 %, 264102 bytes)
(-28.9 %, 264123 bytes)
(-28.9 %, 264144 bytes)
(-28.9 %, 264165 bytes)
(-28.9 %, 264186 bytes)
(-28.9 %, 264207 bytes)
(-28.9 %, 264228 bytes)
(-28.9 %, 264249 bytes)
(-29.0 %, 264270 bytes)
(-29.0 %, 264291 bytes)
(-29.0 %, 264312 bytes)
(-29.0 %, 264333 bytes)
(-29.0 %, 264354 bytes)
(-29.0 %, 264375 bytes)
(-29.0 %, 264396 bytes)
(-29.0 %, 264417 bytes)
(-29.0 %, 264438 bytes)
(-29.0 %, 264459 bytes)
(-29.1 %, 264480 bytes)
(-29.1 %, 264501 bytes)
(-29.1 %, 264522 bytes)
(-29.1 %, 264543 bytes)
(-29.1 %, 264564 bytes)
(-29.1 %, 264585 bytes)
(-29.1 %, 264606 bytes)
(-29.1 %, 264627 bytes)
(-29.1 %, 264648 bytes)
(-29.1 %, 264669 bytes)
(-29.2 %, 264690 bytes)
(-29.2 %, 264711 bytes)
(-29.2 %, 264732 bytes)
(-29.2 %, 264753 bytes)
(-29.2 %, 264774 bytes)
(-29.2 %, 264795 bytes)
(-29.2 %, 264816 bytes)
(-29.2 %, 264837 bytes)
(-29.2 %, 264858 bytes)
(-29.2 %, 264879 bytes)
(-29.3 %, 264900 bytes)
(-29.3 %, 264921 bytes)
(-29.3 %, 264942 bytes)
(-29.3 %, 264963 bytes)
(-29.3 %, 264984 bytes)
(-29.3 %, 265005 bytes)
(-29.3 %, 265026 bytes)
(-29.3 %, 265047 bytes)
(-29.3 %, 265068 bytes)
(-29.4 %, 265089 bytes)
(-29.4 %, 265110 bytes)
(-29.4 %, 265131 bytes)
(-29.4 %, 265152 bytes)
(-29.4 %, 265173 bytes)
(-29.4 %, 265194 bytes)
(-29.4 %, 265215 bytes)
(-29.4 %, 265236 bytes)
(-29.4 %, 265257 bytes)
(-29.4 %, 265278 bytes)
(-29.5 %, 265299 bytes)
(-29.5 %, 265320 bytes)
(-29.5 %, 265341 bytes)
(-29.5 %, 265362 bytes)
(-29.5 %, 265383 bytes)
(-29.5 %, 265404 bytes)
(-29.5 %, 265425 bytes)
(-29.5 %, 265446 bytes)
(-29.5 %, 265467 bytes)
(-29.5 %, 265488 bytes)
(-29.6 %, 265509 bytes)
(-29.6 %, 265530 bytes)
(-29.6 %, 265551 bytes)
(-29.6 %, 265572 bytes)
(-29.6 %, 265593 bytes)
(-29.6 %, 265614 bytes)
(-29.6 %, 265635 bytes)
(-29.6 %, 265656 bytes)
(-29.6 %, 265677 bytes)
(-29.6 %, 265698 bytes)
(-29.7 %, 265719 bytes)
(-29.7 %, 265740 bytes)
(-29.7 %, 265761 bytes)
(-29.7 %, 265782 bytes)
(-29.7 %, 265803 bytes)
(-29.7 %, 265824 bytes)
(-29.7 %, 265845 bytes)
(-29.7 %, 265866 bytes)
(-29.7 %, 265887 bytes)
(-29.8 %, 265908 bytes)
(-29.8 %, 265929 bytes)
(-29.8 %, 265950 bytes)
(-29.8 %, 265971 bytes)
(-29.8 %, 265992 bytes)
(-29.8 %, 266013 bytes)
(-29.8 %, 266034 bytes)
(-29.8 %, 266055 bytes)
(-29.8 %, 266076 bytes)
(-29.8 %, 266097 bytes)
(-29.9 %, 266118 bytes)
(-29.9 %, 266139 bytes)
(-29.9 %, 266160 bytes)
(-29.9 %, 266181 bytes)
(-29.9 %, 266202 bytes)
(-29.9 %, 266223 bytes)
(-29.9 %, 266244 bytes)
(-29.9 %, 266265 bytes)
(-29.9 %, 266286 bytes)
(-29.9 %, 266307 bytes)
(-30.0 %, 266328 bytes)
(-30.0 %, 266349 bytes)
(-30.0 %, 266370 bytes)
(-30.0 %, 266391 bytes)
(-30.0 %, 266412 bytes)
(-30.0 %, 266433 bytes)
(-30.0 %, 266454 bytes)
(-30.0 %, 266475 bytes)
(-30.0 %, 266496 bytes)
(-30.0 %, 266517 bytes)
(-30.1 %, 266538 bytes)
(-30.1 %, 266559 bytes)
(-30.1 %, 266580 bytes)
(-30.1 %, 266601 bytes)
(-30.1 %, 266622 bytes)
(-30.1 %, 266643 bytes)
(-30.1 %, 266664 bytes)
(-30.1 %, 266685 bytes)
(-30.1 %, 266706 bytes)
(-30.2 %, 266727 bytes)
(-30.2 %, 266748 bytes)
(-30.2 %, 266769 bytes)
(-30.2 %, 266790 bytes)
(-30.2 %, 266811 bytes)
(-30.2 %, 266832 bytes)
(-30.2 %, 266853 bytes)
(-30.2 %, 266874 bytes)
(-30.2 %, 266895 bytes)
(-30.2 %, 266916 bytes)
(-30.3 %, 266937 bytes)
(-30.3 %, 266958 bytes)
(-30.3 %, 266979 bytes)
(-30.3 %, 267000 bytes)
(-30.3 %, 267021 bytes)
(-30.3 %, 267042 bytes)
(-30.3 %, 267063 bytes)
(-30.3 %, 267084 bytes)
(-30.3 %, 267105 bytes)
(-30.3 %, 267126 bytes)
(-30.4 %, 267147 bytes)
(-30.4 %, 267168 bytes)
(-30.4 %, 267189 bytes)
(-30.4 %, 267210 bytes)
(-30.4 %, 267231 bytes)
(-30.4 %, 267252 bytes)
(-30.4 %, 267273 bytes)
(-30.4 %, 267294 bytes)
(-30.4 %, 267315 bytes)
(-30.4 %, 267336 bytes)
(-30.5 %, 267357 bytes)
(-30.5 %, 267378 bytes)
(-30.5 %, 267399 bytes)
(-30.5 %, 267420 bytes)
(-30.5 %, 267441 bytes)
(-30.5 %, 267462 bytes)
(-30.5 %, 267483 bytes)
(-30.5 %, 267504 bytes)
(-30.5 %, 267525 bytes)
(-30.6 %, 267546 bytes)
(-30.6 %, 267567 bytes)
(-30.6 %, 267588 bytes)
(-30.6 %, 267609 bytes)
(-30.6 %, 267630 bytes)
(-30.6 %, 267651 bytes)
(-30.6 %, 267672 bytes)
(-30.6 %, 267693 bytes)
(-30.6 %, 267714 bytes)
(-30.6 %, 267735 bytes)
(-30.7 %, 267756 bytes)
(-30.7 %, 267777 bytes)
(-30.7 %, 267798 bytes)
(-30.7 %, 267819 bytes)
(-30.7 %, 267840 bytes)
(-30.7 %, 267861 bytes)
(-30.7 %, 267882 bytes)
(-30.7 %, 267903 bytes)
(-30.7 %, 267924 bytes)
(-30.7 %, 267945 bytes)
(-30.8 %, 267966 bytes)
(-30.8 %, 267987 bytes)
(-30.8 %, 268008 bytes)
(-30.8 %, 268029 bytes)
(-30.8 %, 268050 bytes)
(-30.8 %, 268071 bytes)
(-30.8 %, 268092 bytes)
(-30.8 %, 268113 bytes)
(-30.8 %, 268134 bytes)
(-30.8 %, 268155 bytes)
(-30.9 %, 268176 bytes)
(-30.9 %, 268197 bytes)
(-30.9 %, 268218 bytes)
(-30.9 %, 268239 bytes)
(-30.9 %, 268260 bytes)
(-30.9 %, 268281 bytes)
(-30.9 %, 268302 bytes)
(-30.9 %, 268323 bytes)
(-30.9 %, 268344 bytes)
(-31.0 %, 268365 bytes)
(-31.0 %, 268386 bytes)
(-31.0 %, 268407 bytes)
(-31.0 %, 268428 bytes)
(-31.0 %, 268449 bytes)
(-31.0 %, 268470 bytes)
(-31.0 %, 268491 bytes)
(-31.0 %, 268512 bytes)
(-31.0 %, 268533 bytes)
(-31.0 %, 268554 bytes)
(-31.1 %, 268575 bytes)
(-31.1 %, 268596 bytes)
(-31.1 %, 268617 bytes)
(-31.1 %, 268638 bytes)
(-31.1 %, 268659 bytes)
(-31.1 %, 268680 bytes)
(-31.1 %, 268701 bytes)
(-31.1 %, 268722 bytes)
(-31.1 %, 268743 bytes)
(-31.1 %, 268764 bytes)
(-31.2 %, 268785 bytes)
(-31.2 %, 268806 bytes)
(-31.2 %, 268827 bytes)
(-31.2 %, 268848 bytes)
(-31.2 %, 268869 bytes)
(-31.2 %, 268890 bytes)
(-31.2 %, 268911 bytes)
(-31.2 %, 268932 bytes)
(-31.2 %, 268953 bytes)
(-31.2 %, 268974 bytes)
(-31.3 %, 268995 bytes)
(-31.3 %, 269016 bytes)
(-31.3 %, 269037 bytes)
(-31.3 %, 269058 bytes)
(-31.3 %, 269079 bytes)
(-31.3 %, 269100 bytes)
(-31.3 %, 269121 bytes)
(-31.3 %, 269142 bytes)
(-31.3 %, 269163 bytes)
(-31.4 %, 269184 bytes)
(-31.4 %, 269205 bytes)
(-31.4 %, 269226 bytes)
(-31.4 %, 269247 bytes)
(-31.4 %, 269268 bytes)
(-31.4 %, 269289 bytes)
(-31.4 %, 269310 bytes)
(-31.4 %, 269331 bytes)
(-31.4 %, 269352 bytes)
(-31.4 %, 269373 bytes)
(-31.5 %, 269394 bytes)
(-31.5 %, 269415 bytes)
(-31.5 %, 269436 bytes)
(-31.5 %, 269457 bytes)
(-31.5 %, 269478 bytes)
(-31.5 %, 269499 bytes)
(-31.5 %, 269520 bytes)
(-31.5 %, 269541 bytes)
(-31.5 %, 269562 bytes)
(-31.5 %, 269583 bytes)
(-31.6 %, 269604 bytes)
(-31.6 %, 269625 bytes)
(-31.6 %, 269646 bytes)
(-31.6 %, 269667 bytes)
(-31.6 %, 269688 bytes)
(-31.6 %, 269709 bytes)
(-31.6 %, 269730 bytes)
(-31.6 %, 269751 bytes)
(-31.6 %, 269772 bytes)
(-31.6 %, 269793 bytes)
(-31.7 %, 269814 bytes)
(-31.7 %, 269835 bytes)
(-31.7 %, 269856 bytes)
(-31.7 %, 269877 bytes)
(-31.7 %, 269898 bytes)
(-31.7 %, 269919 bytes)
(-31.7 %, 269940 bytes)
(-31.7 %, 269961 bytes)
(-31.7 %, 269982 bytes)
(-31.7 %, 270003 bytes)
(-31.8 %, 270024 bytes)
(-31.8 %, 270045 bytes)
(-31.8 %, 270066 bytes)
(-31.8 %, 270087 bytes)
(-31.8 %, 270108 bytes)
(-31.8 %, 270129 bytes)
(-31.8 %, 270150 bytes)
(-31.8 %, 270171 bytes)
(-31.8 %, 270192 bytes)
(-31.9 %, 270213 bytes)
(-31.9 %, 270234 bytes)
(-31.9 %, 270255 bytes)
(-31.9 %, 270276 bytes)
(-31.9 %, 270297 bytes)
(-31.9 %, 270318 bytes)
(-31.9 %, 270339 bytes)
(-31.9 %, 270360 bytes)
(-31.9 %, 270381 bytes)
(-31.9 %, 270402 bytes)
(-32.0 %, 270423 bytes)
(-32.0 %, 270444 bytes)
(-32.0 %, 270465 bytes)
(-32.0 %, 270486 bytes)
(-32.0 %, 270507 bytes)
(-32.0 %, 270528 bytes)
(-32.0 %, 270549 bytes)
(-32.0 %, 270570 bytes)
(-32.0 %, 270591 bytes)
(-32.0 %, 270612 bytes)
(-32.1 %, 270633 bytes)
(-32.1 %, 270654 bytes)
(-32.1 %, 270675 bytes)
(-32.1 %, 270696 bytes)
(-32.1 %, 270717 bytes)
(-32.1 %, 270738 bytes)
(-32.1 %, 270759 bytes)
(-32.1 %, 270780 bytes)
(-32.1 %, 270801 bytes)
(-32.1 %, 270822 bytes)
(-32.2 %, 270843 bytes)
(-32.2 %, 270864 bytes)
(-32.2 %, 270885 bytes)
(-32.2 %, 270906 bytes)
(-32.2 %, 270927 bytes)
(-32.2 %, 270948 bytes)
(-32.2 %, 270969 bytes)
(-32.2 %, 270990 bytes)
(-32.2 %, 271011 bytes)
(-32.3 %, 271032 bytes)
(-32.3 %, 271053 bytes)
(-32.3 %, 271074 bytes)
(-32.3 %, 271095 bytes)
(-32.3 %, 271116 bytes)
(-32.3 %, 271137 bytes)
(-32.3 %, 271158 bytes)
(-32.3 %, 271179 bytes)
(-32.3 %, 271200 bytes)
(-32.3 %, 271221 bytes)
(-32.4 %, 271242 bytes)
(-32.4 %, 271263 bytes)
(-32.4 %, 271284 bytes)
(-32.4 %, 271305 bytes)
(-32.4 %, 271326 bytes)
(-32.4 %, 271347 bytes)
(-32.4 %, 271368 bytes)
(-32.4 %, 271389 bytes)
(-32.4 %, 271410 bytes)
(-32.4 %, 271431 bytes)
(-32.5 %, 271452 bytes)
(-32.5 %, 271473 bytes)
(-32.5 %, 271494 bytes)
(-32.5 %, 271515 bytes)
(-32.5 %, 271536 bytes)
(-32.5 %, 271557 bytes)
(-32.5 %, 271578 bytes)
(-32.5 %, 271599 bytes)
(-32.5 %, 271620 bytes)
(-32.5 %, 271641 bytes)
(-32.6 %, 271662 bytes)
(-32.6 %, 271683 bytes)
(-32.6 %, 271704 bytes)
(-32.6 %, 271725 bytes)
(-32.6 %, 271746 bytes)
(-32.6 %, 271767 bytes)
(-32.6 %, 271788 bytes)
(-32.6 %, 271809 bytes)
(-32.6 %, 271830 bytes)
(-32.7 %, 271851 bytes)
(-32.7 %, 271872 bytes)
(-32.7 %, 271893 bytes)
(-32.7 %, 271914 bytes)
(-32.7 %, 271935 bytes)
(-32.7 %, 271956 bytes)
(-32.7 %, 271977 bytes)
(-32.7 %, 271998 bytes)
(-32.7 %, 272019 bytes)
(-32.7 %, 272040 bytes)
(-32.8 %, 272061 bytes)
(-32.8 %, 272082 bytes)
(-32.8 %, 272103 bytes)
(-32.8 %, 272124 bytes)
(-32.8 %, 272145 bytes)
(-32.8 %, 272166 bytes)
(-32.8 %, 272187 bytes)
(-32.8 %, 272208 bytes)
(-32.8 %, 272229 bytes)
(-32.8 %, 272250 bytes)
(-32.9 %, 272271 bytes)
(-32.9 %, 272292 bytes)
(-32.9 %, 272313 bytes)
(-32.9 %, 272334 bytes)
(-32.9 %, 272355 bytes)
(-32.9 %, 272376 bytes)
(-32.9 %, 272397 bytes)
(-32.9 %, 272418 bytes)
(-32.9 %, 272439 bytes)
(-32.9 %, 272460 bytes)
(-33.0 %, 272481 bytes)
(-33.0 %, 272502 bytes)
(-33.0 %, 272523 bytes)
(-33.0 %, 272544 bytes)
(-33.0 %, 272565 bytes)
(-33.0 %, 272586 bytes)
(-33.0 %, 272607 bytes)
(-33.0 %, 272628 bytes)
(-33.0 %, 272649 bytes)
(-33.1 %, 272670 bytes)
(-33.1 %, 272691 bytes)
(-33.1 %, 272712 bytes)
(-33.1 %, 272733 bytes)
(-33.1 %, 272754 bytes)
(-33.1 %, 272775 bytes)
(-33.1 %, 272796 bytes)
(-33.1 %, 272817 bytes)
(-33.1 %, 272838 bytes)
(-33.1 %, 272859 bytes)
(-33.2 %, 272880 bytes)
(-33.2 %, 272901 bytes)
(-33.2 %, 272922 bytes)
(-33.2 %, 272943 bytes)
(-33.2 %, 272964 bytes)
(-33.2 %, 272985 bytes)
(-33.2 %, 273006 bytes)
(-33.2 %, 273027 bytes)
(-33.2 %, 273048 bytes)
(-33.2 %, 273069 bytes)
(-33.3 %, 273090 bytes)
(-33.3 %, 273111 bytes)
(-33.3 %, 273132 bytes)
(-33.3 %, 273153 bytes)
(-33.3 %, 273174 bytes)
(-33.3 %, 273195 bytes)
(-33.3 %, 273216 bytes)
(-33.3 %, 273237 bytes)
(-33.3 %, 273258 bytes)
(-33.3 %, 273279 bytes)
(-33.4 %, 273300 bytes)
(-33.4 %, 273321 bytes)
(-33.4 %, 273342 bytes)
(-33.4 %, 273363 bytes)
(-33.4 %, 273384 bytes)
(-33.4 %, 273405 bytes)
(-33.4 %, 273426 bytes)
(-33.4 %, 273447 bytes)
(-33.4 %, 273468 bytes)
(-33.5 %, 273489 bytes)
(-33.5 %, 273510 bytes)
(-33.5 %, 273531 bytes)
(-33.5 %, 273552 bytes)
(-33.5 %, 273573 bytes)
(-33.5 %, 273594 bytes)
(-33.5 %, 273615 bytes)
(-33.5 %, 273636 bytes)
(-33.5 %, 273657 bytes)
(-33.5 %, 273678 bytes)
(-33.6 %, 273699 bytes)
(-33.6 %, 273720 bytes)
(-33.6 %, 273741 bytes)
(-33.6 %, 273762 bytes)
(-33.6 %, 273783 bytes)
(-33.6 %, 273804 bytes)
(-33.6 %, 273825 bytes)
(-33.6 %, 273846 bytes)
(-33.6 %, 273867 bytes)
(-33.6 %, 273888 bytes)
(-33.7 %, 273909 bytes)
(-33.7 %, 273930 bytes)
(-33.7 %, 273951 bytes)
(-33.7 %, 273972 bytes)
(-33.7 %, 273993 bytes)
(-33.7 %, 274014 bytes)
(-33.7 %, 274035 bytes)
(-33.7 %, 274056 bytes)
(-33.7 %, 274077 bytes)
(-33.7 %, 274098 bytes)
(-33.8 %, 274119 bytes)
(-33.8 %, 274140 bytes)
(-33.8 %, 274161 bytes)
(-33.8 %, 274182 bytes)
(-33.8 %, 274203 bytes)
(-33.8 %, 274224 bytes)
(-33.8 %, 274245 bytes)
(-33.8 %, 274266 bytes)
(-33.8 %, 274287 bytes)
(-33.9 %, 274308 bytes)
(-33.9 %, 274329 bytes)
(-33.9 %, 274350 bytes)
(-33.9 %, 274371 bytes)
(-33.9 %, 274392 bytes)
(-33.9 %, 274413 bytes)
(-33.9 %, 274434 bytes)
(-33.9 %, 274455 bytes)
(-33.9 %, 274476 bytes)
(-33.9 %, 274497 bytes)
(-34.0 %, 274518 bytes)
(-34.0 %, 274539 bytes)
(-34.0 %, 274560 bytes)
(-34.0 %, 274581 bytes)
(-34.0 %, 274602 bytes)
(-34.0 %, 274623 bytes)
(-34.0 %, 274644 bytes)
(-34.0 %, 274665 bytes)
(-34.0 %, 274686 bytes)
(-34.0 %, 274707 bytes)
(-34.1 %, 274728 bytes)
(-34.1 %, 274749 bytes)
(-34.1 %, 274770 bytes)
(-34.1 %, 274791 bytes)
(-34.1 %, 274812 bytes)
(-34.1 %, 274833 bytes)
(-34.1 %, 274854 bytes)
(-34.1 %, 274875 bytes)
(-34.1 %, 274896 bytes)
(-34.1 %, 274917 bytes)
(-34.2 %, 274938 bytes)
(-34.2 %, 274959 bytes)
(-34.2 %, 274980 bytes)
(-34.2 %, 275001 bytes)
(-34.2 %, 275022 bytes)
(-34.2 %, 275043 bytes)
(-34.2 %, 275064 bytes)
(-34.2 %, 275085 bytes)
(-34.2 %, 275106 bytes)
(-34.3 %, 275127 bytes)
(-34.3 %, 275148 bytes)
(-34.3 %, 275169 bytes)
(-34.3 %, 275190 bytes)
(-34.3 %, 275211 bytes)
(-34.3 %, 275232 bytes)
(-34.3 %, 275253 bytes)
(-34.3 %, 275274 bytes)
(-34.3 %, 275295 bytes)
(-34.3 %, 275316 bytes)
(-34.4 %, 275337 bytes)
(-34.4 %, 275358 bytes)
(-34.4 %, 275379 bytes)
(-34.4 %, 275400 bytes)
(-34.4 %, 275421 bytes)
(-34.4 %, 275442 bytes)
(-34.4 %, 275463 bytes)
(-34.4 %, 275484 bytes)
(-34.4 %, 275505 bytes)
(-34.4 %, 275526 bytes)
(-34.5 %, 275547 bytes)
(-34.5 %, 275568 bytes)
(-34.5 %, 275589 bytes)
(-34.5 %, 275610 bytes)
(-34.5 %, 275631 bytes)
(-34.5 %, 275652 bytes)
(-34.5 %, 275673 bytes)
(-34.5 %, 275694 bytes)
(-34.5 %, 275715 bytes)
(-34.5 %, 275736 bytes)
(-34.6 %, 275757 bytes)
(-34.6 %, 275778 bytes)
(-34.6 %, 275799 bytes)
(-34.6 %, 275820 bytes)
(-34.6 %, 275841 bytes)
(-34.6 %, 275862 bytes)
(-34.6 %, 275883 bytes)
(-34.6 %, 275904 bytes)
(-34.6 %, 275925 bytes)
(-34.6 %, 275946 bytes)
(-34.7 %, 275967 bytes)
(-34.7 %, 275988 bytes)
(-34.7 %, 276009 bytes)
(-34.7 %, 276030 bytes)
(-34.7 %, 276051 bytes)
(-34.7 %, 276072 bytes)
(-34.7 %, 276093 bytes)
(-34.7 %, 276114 bytes)
(-34.7 %, 276135 bytes)
(-34.8 %, 276156 bytes)
(-34.8 %, 276177 bytes)
(-34.8 %, 276198 bytes)
(-34.8 %, 276219 bytes)
(-34.8 %, 276240 bytes)
(-34.8 %, 276261 bytes)
(-34.8 %, 276282 bytes)
(-34.8 %, 276303 bytes)
(-34.8 %, 276324 bytes)
(-34.8 %, 276345 bytes)
(-34.9 %, 276366 bytes)
(-34.9 %, 276387 bytes)
(-34.9 %, 276408 bytes)
(-34.9 %, 276429 bytes)
(-34.9 %, 276450 bytes)
(-34.9 %, 276471 bytes)
(-34.9 %, 276492 bytes)
(-34.9 %, 276513 bytes)
(-34.9 %, 276534 bytes)
(-34.9 %, 276555 bytes)
(-35.0 %, 276576 bytes)
(-35.0 %, 276597 bytes)
(-35.0 %, 276618 bytes)
(-35.0 %, 276639 bytes)
(-35.0 %, 276660 bytes)
(-35.0 %, 276681 bytes)
(-35.0 %, 276702 bytes)
(-35.0 %, 276723 bytes)
(-35.0 %, 276744 bytes)
(-35.0 %, 276765 bytes)
(-35.1 %, 276786 bytes)
(-35.1 %, 276807 bytes)
(-35.1 %, 276828 bytes)
(-35.1 %, 276849 bytes)
(-35.1 %, 276870 bytes)
(-35.1 %, 276891 bytes)
(-35.1 %, 276912 bytes)
(-35.1 %, 276933 bytes)
(-35.1 %, 276954 bytes)
(-35.2 %, 276975 bytes)
(-35.2 %, 276996 bytes)
(-35.2 %, 277017 bytes)
(-35.2 %, 277038 bytes)
(-35.2 %, 277059 bytes)
(-35.2 %, 277080 bytes)
(-35.2 %, 277101 bytes)
(-35.2 %, 277122 bytes)
(-35.2 %, 277143 bytes)
(-35.2 %, 277164 bytes)
(-35.3 %, 277185 bytes)
(-35.3 %, 277206 bytes)
(-35.3 %, 277227 bytes)
(-35.3 %, 277248 bytes)
(-35.3 %, 277269 bytes)
(-35.3 %, 277290 bytes)
(-35.3 %, 277311 bytes)
(-35.3 %, 277332 bytes)
(-35.3 %, 277353 bytes)
(-35.3 %, 277374 bytes)
(-35.4 %, 277395 bytes)
(-35.4 %, 277416 bytes)
(-35.4 %, 277437 bytes)
(-35.4 %, 277458 bytes)
(-35.4 %, 277479 bytes)
(-35.4 %, 277500 bytes)
(-35.4 %, 277521 bytes)
(-35.4 %, 277542 bytes)
(-35.4 %, 277563 bytes)
(-35.4 %, 277584 bytes)
(-35.5 %, 277605 bytes)
(-35.5 %, 277626 bytes)
(-35.5 %, 277647 bytes)
(-35.5 %, 277668 bytes)
(-35.5 %, 277689 bytes)
(-35.5 %, 277710 bytes)
(-35.5 %, 277731 bytes)
(-35.5 %, 277752 bytes)
(-35.5 %, 277773 bytes)
(-35.6 %, 277794 bytes)
(-35.6 %, 277815 bytes)
(-35.6 %, 277836 bytes)
(-35.6 %, 277857 bytes)
(-35.6 %, 277878 bytes)
(-35.6 %, 277899 bytes)
(-35.6 %, 277920 bytes)
(-35.6 %, 277941 bytes)
(-35.6 %, 277962 bytes)
(-35.6 %, 277983 bytes)
(-35.7 %, 278004 bytes)
(-35.7 %, 278025 bytes)
(-35.7 %, 278046 bytes)
(-35.7 %, 278067 bytes)
(-35.7 %, 278088 bytes)
(-35.7 %, 278109 bytes)
(-35.7 %, 278130 bytes)
(-35.7 %, 278151 bytes)
(-35.7 %, 278172 bytes)
(-35.7 %, 278193 bytes)
(-35.8 %, 278214 bytes)
(-35.8 %, 278235 bytes)
(-35.8 %, 278256 bytes)
(-35.8 %, 278277 bytes)
(-35.8 %, 278298 bytes)
(-35.8 %, 278319 bytes)
(-35.8 %, 278340 bytes)
(-35.8 %, 278361 bytes)
(-35.8 %, 278382 bytes)
(-35.8 %, 278403 bytes)
(-35.9 %, 278424 bytes)
(-35.9 %, 278445 bytes)
(-35.9 %, 278466 bytes)
(-35.9 %, 278487 bytes)
(-35.9 %, 278508 bytes)
(-35.9 %, 278529 bytes)
(-35.9 %, 278550 bytes)
(-35.9 %, 278571 bytes)
(-35.9 %, 278592 bytes)
(-36.0 %, 278613 bytes)
(-36.0 %, 278634 bytes)
(-36.0 %, 278655 bytes)
(-36.0 %, 278676 bytes)
(-36.0 %, 278697 bytes)
(-36.0 %, 278718 bytes)
(-36.0 %, 278739 bytes)
(-36.0 %, 278760 bytes)
(-36.0 %, 278781 bytes)
(-36.0 %, 278802 bytes)
(-36.1 %, 278823 bytes)
(-36.1 %, 278844 bytes)
(-36.1 %, 278865 bytes)
(-36.1 %, 278886 bytes)
(-36.1 %, 278907 bytes)
(-36.1 %, 278928 bytes)
(-36.1 %, 278949 bytes)
(-36.1 %, 278970 bytes)
(-36.1 %, 278991 bytes)
(-36.1 %, 279012 bytes)
(-36.2 %, 279033 bytes)
(-36.2 %, 279054 bytes)
(-36.2 %, 279075 bytes)
(-36.2 %, 279096 bytes)
(-36.2 %, 279117 bytes)
(-36.2 %, 279138 bytes)
(-36.2 %, 279159 bytes)
(-36.2 %, 279180 bytes)
(-36.2 %, 279201 bytes)
(-36.2 %, 279222 bytes)
(-36.3 %, 279243 bytes)
(-36.3 %, 279264 bytes)
(-36.3 %, 279285 bytes)
(-36.3 %, 279306 bytes)
(-36.3 %, 279327 bytes)
(-36.3 %, 279348 bytes)
(-36.3 %, 279369 bytes)
(-36.3 %, 279390 bytes)
(-36.3 %, 279411 bytes)
(-36.4 %, 279432 bytes)
(-36.4 %, 279453 bytes)
(-36.4 %, 279474 bytes)
(-36.4 %, 279495 bytes)
(-36.4 %, 279516 bytes)
(-36.4 %, 279537 bytes)
(-36.4 %, 279558 bytes)
(-36.4 %, 279579 bytes)
(-36.4 %, 279600 bytes)
(-36.4 %, 279621 bytes)
(-36.5 %, 279642 bytes)
(-36.5 %, 279663 bytes)
(-36.5 %, 279684 bytes)
(-36.5 %, 279705 bytes)
(-36.5 %, 279726 bytes)
(-36.5 %, 279747 bytes)
(-36.5 %, 279768 bytes)
(-36.5 %, 279789 bytes)
(-36.5 %, 279810 bytes)
(-36.5 %, 279831 bytes)
(-36.6 %, 279852 bytes)
(-36.6 %, 279873 bytes)
(-36.6 %, 279894 bytes)
(-36.6 %, 279915 bytes)
(-36.6 %, 279936 bytes)
(-36.6 %, 279957 bytes)
(-36.6 %, 279978 bytes)
(-36.6 %, 279999 bytes)
(-36.6 %, 280020 bytes)
(-36.6 %, 280041 bytes)
(-36.7 %, 280062 bytes)
(-36.7 %, 280083 bytes)
(-36.7 %, 280104 bytes)
(-36.7 %, 280125 bytes)
(-36.7 %, 280146 bytes)
(-36.7 %, 280167 bytes)
(-36.7 %, 280188 bytes)
(-36.7 %, 280209 bytes)
(-36.7 %, 280230 bytes)
(-36.8 %, 280251 bytes)
(-36.8 %, 280272 bytes)
(-36.8 %, 280293 bytes)
(-36.8 %, 280314 bytes)
(-36.8 %, 280335 bytes)
(-36.8 %, 280356 bytes)
(-36.8 %, 280377 bytes)
(-36.8 %, 280398 bytes)
(-36.8 %, 280419 bytes)
(-36.8 %, 280440 bytes)
(-36.9 %, 280461 bytes)
(-36.9 %, 280482 bytes)
(-36.9 %, 280503 bytes)
(-36.9 %, 280524 bytes)
(-36.9 %, 280545 bytes)
(-36.9 %, 280566 bytes)
(-36.9 %, 280587 bytes)
(-36.9 %, 280608 bytes)
(-36.9 %, 280629 bytes)
(-36.9 %, 280650 bytes)
(-37.0 %, 280671 bytes)
(-37.0 %, 280692 bytes)
(-37.0 %, 280713 bytes)
(-37.0 %, 280734 bytes)
(-37.0 %, 280755 bytes)
(-37.0 %, 280776 bytes)
(-37.0 %, 280797 bytes)
(-37.0 %, 280818 bytes)
(-37.0 %, 280839 bytes)
(-37.0 %, 280860 bytes)
(-37.1 %, 280881 bytes)
(-37.1 %, 280902 bytes)
(-37.1 %, 280923 bytes)
(-37.1 %, 280944 bytes)
(-37.1 %, 280965 bytes)
(-37.1 %, 280986 bytes)
(-37.1 %, 281007 bytes)
(-37.1 %, 281028 bytes)
(-37.1 %, 281049 bytes)
(-37.2 %, 281070 bytes)
(-37.2 %, 281091 bytes)
(-37.2 %, 281112 bytes)
(-37.2 %, 281133 bytes)
(-37.2 %, 281154 bytes)
(-37.2 %, 281175 bytes)
(-37.2 %, 281196 bytes)
(-37.2 %, 281217 bytes)
(-37.2 %, 281238 bytes)
(-37.2 %, 281259 bytes)
(-37.3 %, 281280 bytes)
(-37.3 %, 281301 bytes)
(-37.3 %, 281322 bytes)
(-37.3 %, 281343 bytes)
(-37.3 %, 281364 bytes)
(-37.3 %, 281385 bytes)
(-37.3 %, 281406 bytes)
(-37.3 %, 281427 bytes)
(-37.3 %, 281448 bytes)
(-37.3 %, 281469 bytes)
(-37.4 %, 281490 bytes)
(-37.4 %, 281511 bytes)
(-37.4 %, 281532 bytes)
(-37.4 %, 281553 bytes)
(-37.4 %, 281574 bytes)
(-37.4 %, 281595 bytes)
(-37.4 %, 281616 bytes)
(-37.4 %, 281637 bytes)
(-37.4 %, 281658 bytes)
(-37.4 %, 281679 bytes)
(-37.5 %, 281700 bytes)
(-37.5 %, 281721 bytes)
(-37.5 %, 281742 bytes)
(-37.5 %, 281763 bytes)
(-37.5 %, 281784 bytes)
(-37.5 %, 281805 bytes)
(-37.5 %, 281826 bytes)
(-37.5 %, 281847 bytes)
(-37.5 %, 281868 bytes)
(-37.5 %, 281889 bytes)
(-37.6 %, 281910 bytes)
(-37.6 %, 281931 bytes)
(-37.6 %, 281952 bytes)
(-37.6 %, 281973 bytes)
(-37.6 %, 281994 bytes)
(-37.6 %, 282015 bytes)
(-37.6 %, 282036 bytes)
(-37.6 %, 282057 bytes)
(-37.6 %, 282078 bytes)
(-37.7 %, 282099 bytes)
(-37.7 %, 282120 bytes)
(-37.7 %, 282141 bytes)
(-37.7 %, 282162 bytes)
(-37.7 %, 282183 bytes)
(-37.7 %, 282204 bytes)
(-37.7 %, 282225 bytes)
(-37.7 %, 282246 bytes)
(-37.7 %, 282267 bytes)
(-37.7 %, 282288 bytes)
(-37.8 %, 282309 bytes)
(-37.8 %, 282330 bytes)
(-37.8 %, 282351 bytes)
(-37.8 %, 282372 bytes)
(-37.8 %, 282393 bytes)
(-37.8 %, 282414 bytes)
(-37.8 %, 282435 bytes)
(-37.8 %, 282456 bytes)
(-37.8 %, 282477 bytes)
(-37.8 %, 282498 bytes)
(-37.9 %, 282519 bytes)
(-37.9 %, 282540 bytes)
(-37.9 %, 282561 bytes)
(-37.9 %, 282582 bytes)
(-37.9 %, 282603 bytes)
(-37.9 %, 282624 bytes)
(-37.9 %, 282645 bytes)
(-37.9 %, 282666 bytes)
(-37.9 %, 282687 bytes)
(-37.9 %, 282708 bytes)
(-38.0 %, 282729 bytes)
(-38.0 %, 282750 bytes)
(-38.0 %, 282771 bytes)
(-38.0 %, 282792 bytes)
(-38.0 %, 282813 bytes)
(-38.0 %, 282834 bytes)
(-38.0 %, 282855 bytes)
(-38.0 %, 282876 bytes)
(-38.0 %, 282897 bytes)
(-38.1 %, 282918 bytes)
(-38.1 %, 282939 bytes)
(-38.1 %, 282960 bytes)
(-38.1 %, 282981 bytes)
(-38.1 %, 283002 bytes)
(-38.1 %, 283023 bytes)
(-38.1 %, 283044 bytes)
(-38.1 %, 283065 bytes)
(-38.1 %, 283086 bytes)
(-38.1 %, 283107 bytes)
(-38.2 %, 283128 bytes)
(-38.2 %, 283149 bytes)
(-38.2 %, 283170 bytes)
(-38.2 %, 283191 bytes)
(-38.2 %, 283212 bytes)
(-38.2 %, 283233 bytes)
(-38.2 %, 283254 bytes)
(-38.2 %, 283275 bytes)
(-38.2 %, 283296 bytes)
(-38.2 %, 283317 bytes)
(-38.3 %, 283338 bytes)
(-38.3 %, 283359 bytes)
(-38.3 %, 283380 bytes)
(-38.3 %, 283401 bytes)
(-38.3 %, 283422 bytes)
(-38.3 %, 283443 bytes)
(-38.3 %, 283464 bytes)
(-38.3 %, 283485 bytes)
(-38.3 %, 283506 bytes)
(-38.3 %, 283527 bytes)
(-38.4 %, 283548 bytes)
(-38.4 %, 283569 bytes)
(-38.4 %, 283590 bytes)
(-38.4 %, 283611 bytes)
(-38.4 %, 283632 bytes)
(-38.4 %, 283653 bytes)
(-38.4 %, 283674 bytes)
(-38.4 %, 283695 bytes)
(-38.4 %, 283716 bytes)
(-38.5 %, 283737 bytes)
(-38.5 %, 283758 bytes)
(-38.5 %, 283779 bytes)
(-38.5 %, 283800 bytes)
(-38.5 %, 283821 bytes)
(-38.5 %, 283842 bytes)
(-38.5 %, 283863 bytes)
(-38.5 %, 283884 bytes)
(-38.5 %, 283905 bytes)
(-38.5 %, 283926 bytes)
(-38.6 %, 283947 bytes)
(-38.6 %, 283968 bytes)
(-38.6 %, 283989 bytes)
(-38.6 %, 284010 bytes)
(-38.6 %, 284031 bytes)
(-38.6 %, 284052 bytes)
(-38.6 %, 284073 bytes)
(-38.6 %, 284094 bytes)
(-38.6 %, 284115 bytes)
(-38.6 %, 284136 bytes)
(-38.7 %, 284157 bytes)
(-38.7 %, 284178 bytes)
(-38.7 %, 284199 bytes)
(-38.7 %, 284220 bytes)
(-38.7 %, 284241 bytes)
(-38.7 %, 284262 bytes)
(-38.7 %, 284283 bytes)
(-38.7 %, 284304 bytes)
(-38.7 %, 284325 bytes)
(-38.7 %, 284346 bytes)
(-38.8 %, 284367 bytes)
(-38.8 %, 284388 bytes)
(-38.8 %, 284409 bytes)
(-38.8 %, 284430 bytes)
(-38.8 %, 284451 bytes)
(-38.8 %, 284472 bytes)
(-38.8 %, 284493 bytes)
(-38.8 %, 284514 bytes)
(-38.8 %, 284535 bytes)
(-38.9 %, 284556 bytes)
(-38.9 %, 284577 bytes)
(-38.9 %, 284598 bytes)
(-38.9 %, 284619 bytes)
(-38.9 %, 284640 bytes)
(-38.9 %, 284661 bytes)
(-38.9 %, 284682 bytes)
(-38.9 %, 284703 bytes)
(-38.9 %, 284724 bytes)
(-38.9 %, 284745 bytes)
(-39.0 %, 284766 bytes)
(-39.0 %, 284787 bytes)
(-39.0 %, 284808 bytes)
(-39.0 %, 284829 bytes)
(-39.0 %, 284850 bytes)
(-39.0 %, 284871 bytes)
(-39.0 %, 284892 bytes)
(-39.0 %, 284913 bytes)
(-39.0 %, 284934 bytes)
(-39.0 %, 284955 bytes)
(-39.1 %, 284976 bytes)
(-39.1 %, 284997 bytes)
(-39.1 %, 285018 bytes)
(-39.1 %, 285039 bytes)
(-39.1 %, 285060 bytes)
(-39.1 %, 285081 bytes)
(-39.1 %, 285102 bytes)
(-39.1 %, 285123 bytes)
(-39.1 %, 285144 bytes)
(-39.1 %, 285165 bytes)
(-39.2 %, 285186 bytes)
(-39.2 %, 285207 bytes)
(-39.2 %, 285228 bytes)
(-39.2 %, 285249 bytes)
(-39.2 %, 285270 bytes)
(-39.2 %, 285291 bytes)
(-39.2 %, 285312 bytes)
(-39.2 %, 285333 bytes)
(-39.2 %, 285354 bytes)
(-39.3 %, 285375 bytes)
(-39.3 %, 285396 bytes)
(-39.3 %, 285417 bytes)
(-39.3 %, 285438 bytes)
(-39.3 %, 285459 bytes)
(-39.3 %, 285480 bytes)
(-39.3 %, 285501 bytes)
(-39.3 %, 285522 bytes)
(-39.3 %, 285543 bytes)
(-39.3 %, 285564 bytes)
(-39.4 %, 285585 bytes)
(-39.4 %, 285606 bytes)
(-39.4 %, 285627 bytes)
(-39.4 %, 285648 bytes)
(-39.4 %, 285669 bytes)
(-39.4 %, 285690 bytes)
(-39.4 %, 285711 bytes)
(-39.4 %, 285732 bytes)
(-39.4 %, 285753 bytes)
(-39.4 %, 285774 bytes)
(-39.5 %, 285795 bytes)
(-39.5 %, 285816 bytes)
(-39.5 %, 285837 bytes)
(-39.5 %, 285858 bytes)
(-39.5 %, 285879 bytes)
(-39.5 %, 285900 bytes)
(-39.5 %, 285921 bytes)
(-39.5 %, 285942 bytes)
(-39.5 %, 285963 bytes)
(-39.5 %, 285984 bytes)
(-39.6 %, 286005 bytes)
(-39.6 %, 286026 bytes)
(-39.6 %, 286047 bytes)
(-39.6 %, 286068 bytes)
(-39.6 %, 286089 bytes)
(-39.6 %, 286110 bytes)
(-39.6 %, 286131 bytes)
(-39.6 %, 286152 bytes)
(-39.6 %, 286173 bytes)
(-39.7 %, 286194 bytes)
(-39.7 %, 286215 bytes)
(-39.7 %, 286236 bytes)
(-39.7 %, 286257 bytes)
(-39.7 %, 286278 bytes)
(-39.7 %, 286299 bytes)
(-39.7 %, 286320 bytes)
(-39.7 %, 286341 bytes)
(-39.7 %, 286362 bytes)
(-39.7 %, 286383 bytes)
(-39.8 %, 286404 bytes)
(-39.8 %, 286425 bytes)
(-39.8 %, 286446 bytes)
(-39.8 %, 286467 bytes)
(-39.8 %, 286488 bytes)
(-39.8 %, 286509 bytes)
(-39.8 %, 286530 bytes)
(-39.8 %, 286551 bytes)
(-39.8 %, 286572 bytes)
(-39.8 %, 286593 bytes)
(-39.9 %, 286614 bytes)
(-39.9 %, 286635 bytes)
(-39.9 %, 286656 bytes)
(-39.9 %, 286677 bytes)
(-39.9 %, 286698 bytes)
(-39.9 %, 286719 bytes)
(-39.9 %, 286740 bytes)
(-39.9 %, 286761 bytes)
(-39.9 %, 286782 bytes)
(-39.9 %, 286803 bytes)
(-40.0 %, 286824 bytes)
(-40.0 %, 286845 bytes)
(-40.0 %, 286866 bytes)
(-40.0 %, 286887 bytes)
(-40.0 %, 286908 bytes)
(-40.0 %, 286929 bytes)
LLVM ERROR: IO failure on output stream.
(-40.0 %, 286950 bytes)
LLVM ERROR: IO failure on output stream.
===< pass_clang :: return-void >===
clang_delta: ReturnVoid.cpp:163: bool ReturnVoid::isInTheFuncDef(clang::ReturnStmt*): Assertion `(EndPos > FuncDefStartPos) && (EndPos < FuncDefEndPos) && "Bad return statement range!"' failed.
Aborted

***************************************************

pass_clang::return-void has encountered a bug:
crashed: "/usr/local/libexec/clang_delta" --transformation=return-void --counter=3 /tmp/creduce-v_yL_M/bzip2.c

Please consider tarring up /home/ukoc/mangroveL/bzip2_sb/runs/run-1452671058.34913/creduce_bug_000
and mailing it to creduce-bugs@flux.utah.edu and we will try to fix
the bug.

This bug is not fatal, C-Reduce will continue to execute.

***************************************************

===< pass_clang :: simple-inliner >===
LLVM ERROR: IO failure on output stream.
===< pass_clang :: replace-callexpr >===
LLVM ERROR: IO failure on output stream.
===< pass_clang :: remove-unused-enum-member >===
===< pass_clang :: remove-unused-var >===
===< pass_clang :: simplify-comma-expr >===
===< pass_clang :: simplify-dependent-typedef >===
===< pass_clang :: instantiate-template-type-param-to-int >===
===< pass_clang :: instantiate-template-param >===
===< pass_clang :: reduce-class-template-param >===
===< pass_clang :: class-template-to-class >===
===< pass_clang :: replace-derived-class >===
===< pass_clang :: remove-ctor-initializer >===
===< pass_clang :: replace-class-with-base-template-spec >===
===< pass_clang :: remove-unused-outer-class >===
===< pass_clang :: empty-struct-to-int >===
===< pass_clang :: remove-pointer-pairs >===
===< pass_clang :: remove-addr-taken >===
LLVM ERROR: IO failure on output stream.
===< pass_clang :: simplify-struct >===
===< pass_clang :: replace-array-index-var >===
LLVM ERROR: IO failure on output stream.
===< pass_clang :: simplify-recursive-template-instantiation >===
===< pass_clang :: rename-class >===
===< pass_clang :: rename-cxx-method >===
===< pass_clang :: combine-local-var >===
LLVM ERROR: IO failure on output stream.
===< pass_clang :: simplify-struct-union-decl >===
===< pass_clang :: move-global-var >===
LLVM ERROR: IO failure on output stream.
Termination check: size was 204936; now 286950
===================== done ====================

pass statistics:
  method pass_clang :: class-template-to-class worked 0 times and failed 0 times
  method pass_clang :: combine-local-var worked 0 times and failed 2 times
  method pass_clang :: empty-struct-to-int worked 0 times and failed 1 times
  method pass_clang :: instantiate-template-param worked 0 times and failed 0 times
  method pass_clang :: instantiate-template-type-param-to-int worked 0 times and failed 0 times
  method pass_clang :: local-to-global worked 4124 times and failed 51 times
  method pass_clang :: move-global-var worked 0 times and failed 8 times
  method pass_clang :: reduce-class-template-param worked 0 times and failed 0 times
  method pass_clang :: remove-addr-taken worked 0 times and failed 2 times
  method pass_clang :: remove-ctor-initializer worked 0 times and failed 0 times
  method pass_clang :: remove-pointer-pairs worked 0 times and failed 0 times
  method pass_clang :: remove-unused-enum-member worked 0 times and failed 0 times
  method pass_clang :: remove-unused-outer-class worked 0 times and failed 0 times
  method pass_clang :: remove-unused-var worked 0 times and failed 8 times
  method pass_clang :: rename-class worked 0 times and failed 0 times
  method pass_clang :: rename-cxx-method worked 0 times and failed 0 times
  method pass_clang :: replace-array-index-var worked 0 times and failed 4 times
  method pass_clang :: replace-callexpr worked 0 times and failed 1 times
  method pass_clang :: replace-class-with-base-template-spec worked 0 times and failed 0 times
  method pass_clang :: replace-derived-class worked 0 times and failed 0 times
  method pass_clang :: return-void worked 0 times and failed 2 times
  method pass_clang :: simple-inliner worked 0 times and failed 1 times
  method pass_clang :: simplify-comma-expr worked 0 times and failed 0 times
  method pass_clang :: simplify-dependent-typedef worked 0 times and failed 0 times
  method pass_clang :: simplify-recursive-template-instantiation worked 0 times and failed 0 times
  method pass_clang :: simplify-struct worked 0 times and failed 0 times
  method pass_clang :: simplify-struct-union-decl worked 0 times and failed 0 times
  method pass_clang_binsrch :: remove-unused-function worked 1 times and failed 0 times


          '/home/ukoc/mangroveL/bzip2_sb/runs/run-1452671058.34913/bzip2.c' reduced to:
/*-------------------------------------------------------------*/
/*--- Public header file for the library.                   ---*/
/*---                                               bzlib.h ---*/
/*-------------------------------------------------------------*/

/*--
  This file is a part of bzip2 and/or libbzip2, a program and
  library for lossless, block-sorting data compression.

  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. The origin of this software must not be misrepresented; you must 
     not claim that you wrote the original software.  If you use this 
     software in a product, an acknowledgment in the product 
     documentation would be appreciated but is not required.

  3. Altered source versions must be plainly marked as such, and must
     not be misrepresented as being the original software.

  4. The name of the author may not be used to endorse or promote 
     products derived from this software without specific prior written 
     permission.

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Julian Seward, Cambridge, UK.
  jseward@acm.org
  bzip2/libbzip2 version 1.0 of 21 March 2000

  This program is based on (at least) the work of:
     Mike Burrows
     David Wheeler
     Peter Fenwick
     Alistair Moffat
     Radford Neal
     Ian H. Witten
     Robert Sedgewick
     Jon L. Bentley

  For more information on these sources, see the manual.
--*/


#ifndef _BZLIB_H
#define _BZLIB_H

#ifdef __cplusplus
extern "C" {
#endif

#define BZ_RUN               0
#define BZ_FLUSH             1
#define BZ_FINISH            2

#define BZ_OK                0
#define BZ_RUN_OK            1
#define BZ_FLUSH_OK          2
#define BZ_FINISH_OK         3
#define BZ_STREAM_END        4
#define BZ_SEQUENCE_ERROR    (-1)
#define BZ_PARAM_ERROR       (-2)
#define BZ_MEM_ERROR         (-3)
#define BZ_DATA_ERROR        (-4)
#define BZ_DATA_ERROR_MAGIC  (-5)
#define BZ_IO_ERROR          (-6)
#define BZ_UNEXPECTED_EOF    (-7)
#define BZ_OUTBUFF_FULL      (-8)
#define BZ_CONFIG_ERROR      (-9)

typedef 
   struct {
      char *next_in;
      unsigned int avail_in;
      unsigned int total_in_lo32;
      unsigned int total_in_hi32;

      char *next_out;
      unsigned int avail_out;
      unsigned int total_out_lo32;
      unsigned int total_out_hi32;

      void *state;

      void *(*bzalloc)(void *,int,int);
      void (*bzfree)(void *,void *);
      void *opaque;
   } 
   bz_stream;


#ifndef BZ_IMPORT
#define BZ_EXPORT
#endif

/* Need a definitition for FILE */
#include <stdio.h>

#ifdef _WIN32
#   include <windows.h>
#   ifdef small
      /* windows.h define small to char */
#      undef small
#   endif
#   ifdef BZ_EXPORT
#   define BZ_API(func) WINAPI func
#   define BZ_EXTERN extern
#   else
   /* import windows dll dynamically */
#   define BZ_API(func) (WINAPI * func)
#   define BZ_EXTERN
#   endif
#else
#   define BZ_API(func) func
#   define BZ_EXTERN extern
#endif


/*-- Core (low-level) library functions --*/

BZ_EXTERN int BZ_API(BZ2_bzCompressInit) ( 
      bz_stream* strm, 
      int        blockSize100k, 
      int        verbosity, 
      int        workFactor 
   );

BZ_EXTERN int BZ_API(BZ2_bzCompress) ( 
      bz_stream* strm, 
      int action 
   );

BZ_EXTERN int BZ_API(BZ2_bzCompressEnd) ( 
      bz_stream* strm 
   );

BZ_EXTERN int BZ_API(BZ2_bzDecompressInit) ( 
      bz_stream *strm, 
      int       verbosity, 
      int       small
   );

BZ_EXTERN int BZ_API(BZ2_bzDecompress) ( 
      bz_stream* strm 
   );

BZ_EXTERN int BZ_API(BZ2_bzDecompressEnd) ( 
      bz_stream *strm 
   );



/*-- High(er) level library functions --*/

#ifndef BZ_NO_STDIO
#define BZ_MAX_UNUSED 5000

typedef void BZFILE;

BZ_EXTERN BZFILE* BZ_API(BZ2_bzReadOpen) ( 
      int*  bzerror,   
      FILE* f, 
      int   verbosity, 
      int   small,
      void* unused,    
      int   nUnused 
   );

BZ_EXTERN void BZ_API(BZ2_bzReadClose) ( 
      int*    bzerror, 
      BZFILE* b 
   );

BZ_EXTERN void BZ_API(BZ2_bzReadGetUnused) ( 
      int*    bzerror, 
      BZFILE* b, 
      void**  unused,  
      int*    nUnused 
   );

BZ_EXTERN int BZ_API(BZ2_bzRead) ( 
      int*    bzerror, 
      BZFILE* b, 
      void*   buf, 
      int     len 
   );

BZ_EXTERN BZFILE* BZ_API(BZ2_bzWriteOpen) ( 
      int*  bzerror,      
      FILE* f, 
      int   blockSize100k, 
      int   verbosity, 
      int   workFactor 
   );

BZ_EXTERN void BZ_API(BZ2_bzWrite) ( 
      int*    bzerror, 
      BZFILE* b, 
      void*   buf, 
      int     len 
   );

BZ_EXTERN void BZ_API(BZ2_bzWriteClose) ( 
      int*          bzerror, 
      BZFILE*       b, 
      int           abandon, 
      unsigned int* nbytes_in, 
      unsigned int* nbytes_out 
   );

BZ_EXTERN void BZ_API(BZ2_bzWriteClose64) ( 
      int*          bzerror, 
      BZFILE*       b, 
      int           abandon, 
      unsigned int* nbytes_in_lo32, 
      unsigned int* nbytes_in_hi32, 
      unsigned int* nbytes_out_lo32, 
      unsigned int* nbytes_out_hi32
   );
#endif


/*-- Utility functions --*/

BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffCompress) ( 
      char*         dest, 
      unsigned int* destLen,
      char*         source, 
      unsigned int  sourceLen,
      int           blockSize100k, 
      int           verbosity, 
      int           workFactor 
   );

BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffDecompress) ( 
      char*         dest, 
      unsigned int* destLen,
      char*         source, 
      unsigned int  sourceLen,
      int           small, 
      int           verbosity 
   );


/*--
   Code contributed by Yoshioka Tsuneo
   (QWF00133@niftyserve.or.jp/tsuneo-y@is.aist-nara.ac.jp),
   to support better zlib compatibility.
   This code is not _officially_ part of libbzip2 (yet);
   I haven't tested it, documented it, or considered the
   threading-safeness of it.
   If this code breaks, please contact both Yoshioka and me.
--*/

BZ_EXTERN const char * BZ_API(BZ2_bzlibVersion) (
      void
   );

#ifndef BZ_NO_STDIO
BZ_EXTERN BZFILE * BZ_API(BZ2_bzopen) (
      const char *path,
      const char *mode
   );

BZ_EXTERN BZFILE * BZ_API(BZ2_bzdopen) (
      int        fd,
      const char *mode
   );
         
BZ_EXTERN int BZ_API(BZ2_bzread) (
      BZFILE* b, 
      void* buf, 
      int len 
   );

BZ_EXTERN int BZ_API(BZ2_bzwrite) (
      BZFILE* b, 
      void*   buf, 
      int     len 
   );

BZ_EXTERN int BZ_API(BZ2_bzflush) (
      BZFILE* b
   );

BZ_EXTERN void BZ_API(BZ2_bzclose) (
      BZFILE* b
   );

BZ_EXTERN const char * BZ_API(BZ2_bzerror) (
      BZFILE *b, 
      int    *errnum
   );
#endif

#ifdef __cplusplus
}
#endif

#endif

/*-------------------------------------------------------------*/
/*--- end                                           bzlib.h ---*/
/*-------------------------------------------------------------*/
/*-------------------------------------------------------------*/
/*--- Private header file for the library.                  ---*/
/*---                                       bzlib_private.h ---*/
/*-------------------------------------------------------------*/

#ifndef _BZLIB_PRIVATE_H
#define _BZLIB_PRIVATE_H

#include <stdlib.h>

#ifndef BZ_NO_STDIO
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#endif


/*-- General stuff. --*/

#define BZ_VERSION  "1.0.2, 30-Dec-2001"

typedef char            Char;
typedef unsigned char   Bool;
typedef unsigned char   UChar;
typedef int             Int32;
typedef unsigned int    UInt32;
typedef short           Int16;
typedef unsigned short  UInt16;

#define True  ((Bool)1)
#define False ((Bool)0)

#ifndef __GNUC__
#define __inline__  /* */
#endif 

#ifndef BZ_NO_STDIO
extern void BZ2_bz__AssertH__fail ( int errcode );
#define AssertH(cond,errcode) \
   { if (!(cond)) BZ2_bz__AssertH__fail ( errcode ); }
#if BZ_DEBUG
#define AssertD(cond,msg) \
   { if (!(cond)) {       \
      fprintf ( stderr,   \
        "\n\nlibbzip2(debug build): internal error\n\t%s\n", msg );\
      exit(1); \
   }}
#else
#define AssertD(cond,msg) /* */
#endif
#define VPrintf0(zf) \
   fprintf(stderr,zf)
#define VPrintf1(zf,za1) \
   fprintf(stderr,zf,za1)
#define VPrintf2(zf,za1,za2) \
   fprintf(stderr,zf,za1,za2)
#define VPrintf3(zf,za1,za2,za3) \
   fprintf(stderr,zf,za1,za2,za3)
#define VPrintf4(zf,za1,za2,za3,za4) \
   fprintf(stderr,zf,za1,za2,za3,za4)
#define VPrintf5(zf,za1,za2,za3,za4,za5) \
   fprintf(stderr,zf,za1,za2,za3,za4,za5)
#else
extern void bz_internal_error ( int errcode );
#define AssertH(cond,errcode) \
   { if (!(cond)) bz_internal_error ( errcode ); }
#define AssertD(cond,msg) /* */
#define VPrintf0(zf) /* */
#define VPrintf1(zf,za1) /* */
#define VPrintf2(zf,za1,za2) /* */
#define VPrintf3(zf,za1,za2,za3) /* */
#define VPrintf4(zf,za1,za2,za3,za4) /* */
#define VPrintf5(zf,za1,za2,za3,za4,za5) /* */
#endif


#define BZALLOC(nnn) (strm->bzalloc)(strm->opaque,(nnn),1)
#define BZFREE(ppp)  (strm->bzfree)(strm->opaque,(ppp))


/*-- Header bytes. --*/

#define BZ_HDR_B 0x42   /* 'B' */
#define BZ_HDR_Z 0x5a   /* 'Z' */
#define BZ_HDR_h 0x68   /* 'h' */
#define BZ_HDR_0 0x30   /* '0' */
  
/*-- Constants for the back end. --*/

#define BZ_MAX_ALPHA_SIZE 258
#define BZ_MAX_CODE_LEN    23

#define BZ_RUNA 0
#define BZ_RUNB 1

#define BZ_N_GROUPS 6
#define BZ_G_SIZE   50
#define BZ_N_ITERS  4

#define BZ_MAX_SELECTORS (2 + (900000 / BZ_G_SIZE))



/*-- Stuff for randomising repetitive blocks. --*/

extern Int32 BZ2_rNums[512];

#define BZ_RAND_DECLS                          \
   Int32 rNToGo;                               \
   Int32 rTPos                                 \

#define BZ_RAND_INIT_MASK                      \
   s->rNToGo = 0;                              \
   s->rTPos  = 0                               \

#define BZ_RAND_MASK ((s->rNToGo == 1) ? 1 : 0)

#define BZ_RAND_UPD_MASK                       \
   if (s->rNToGo == 0) {                       \
      s->rNToGo = BZ2_rNums[s->rTPos];         \
      s->rTPos++;                              \
      if (s->rTPos == 512) s->rTPos = 0;       \
   }                                           \
   s->rNToGo--;



/*-- Stuff for doing CRCs. --*/

extern UInt32 BZ2_crc32Table[256];

#define BZ_INITIALISE_CRC(crcVar)              \
{                                              \
   crcVar = 0xffffffffL;                       \
}

#define BZ_FINALISE_CRC(crcVar)                \
{                                              \
   crcVar = ~(crcVar);                         \
}

#define BZ_UPDATE_CRC(crcVar,cha)              \
{                                              \
   crcVar = (crcVar << 8) ^                    \
            BZ2_crc32Table[(crcVar >> 24) ^    \
                           ((UChar)cha)];      \
}



/*-- States and modes for compression. --*/

#define BZ_M_IDLE      1
#define BZ_M_RUNNING   2
#define BZ_M_FLUSHING  3
#define BZ_M_FINISHING 4

#define BZ_S_OUTPUT    1
#define BZ_S_INPUT     2

#define BZ_N_RADIX 2
#define BZ_N_QSORT 12
#define BZ_N_SHELL 18
#define BZ_N_OVERSHOOT (BZ_N_RADIX + BZ_N_QSORT + BZ_N_SHELL + 2)




/*-- Structure holding all the compression-side stuff. --*/

typedef
   struct {
      /* pointer back to the struct bz_stream */
      bz_stream* strm;

      /* mode this stream is in, and whether inputting */
      /* or outputting data */
      Int32    mode;
      Int32    state;

      /* remembers avail_in when flush/finish requested */
      UInt32   avail_in_expect;

      /* for doing the block sorting */
      UInt32*  arr1;
      UInt32*  arr2;
      UInt32*  ftab;
      Int32    origPtr;

      /* aliases for arr1 and arr2 */
      UInt32*  ptr;
      UChar*   block;
      UInt16*  mtfv;
      UChar*   zbits;

      /* for deciding when to use the fallback sorting algorithm */
      Int32    workFactor;

      /* run-length-encoding of the input */
      UInt32   state_in_ch;
      Int32    state_in_len;
      BZ_RAND_DECLS;

      /* input and output limits and current posns */
      Int32    nblock;
      Int32    nblockMAX;
      Int32    numZ;
      Int32    state_out_pos;

      /* map of bytes used in block */
      Int32    nInUse;
      Bool     inUse[256];
      UChar    unseqToSeq[256];

      /* the buffer for bit stream creation */
      UInt32   bsBuff;
      Int32    bsLive;

      /* block and combined CRCs */
      UInt32   blockCRC;
      UInt32   combinedCRC;

      /* misc administratium */
      Int32    verbosity;
      Int32    blockNo;
      Int32    blockSize100k;

      /* stuff for coding the MTF values */
      Int32    nMTF;
      Int32    mtfFreq    [BZ_MAX_ALPHA_SIZE];
      UChar    selector   [BZ_MAX_SELECTORS];
      UChar    selectorMtf[BZ_MAX_SELECTORS];

      UChar    len     [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
      Int32    code    [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
      Int32    rfreq   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
      /* second dimension: only 3 needed; 4 makes index calculations faster */
      UInt32   len_pack[BZ_MAX_ALPHA_SIZE][4];

   }
   EState;



/*-- externs for compression. --*/

extern void 
BZ2_blockSort ( EState* );

extern void 
BZ2_compressBlock ( EState*, Bool );

extern void 
BZ2_bsInitWrite ( EState* );

extern void 
BZ2_hbAssignCodes ( Int32*, UChar*, Int32, Int32, Int32 );

extern void 
BZ2_hbMakeCodeLengths ( UChar*, Int32*, Int32, Int32 );



/*-- states for decompression. --*/

#define BZ_X_IDLE        1
#define BZ_X_OUTPUT      2

#define BZ_X_MAGIC_1     10
#define BZ_X_MAGIC_2     11
#define BZ_X_MAGIC_3     12
#define BZ_X_MAGIC_4     13
#define BZ_X_BLKHDR_1    14
#define BZ_X_BLKHDR_2    15
#define BZ_X_BLKHDR_3    16
#define BZ_X_BLKHDR_4    17
#define BZ_X_BLKHDR_5    18
#define BZ_X_BLKHDR_6    19
#define BZ_X_BCRC_1      20
#define BZ_X_BCRC_2      21
#define BZ_X_BCRC_3      22
#define BZ_X_BCRC_4      23
#define BZ_X_RANDBIT     24
#define BZ_X_ORIGPTR_1   25
#define BZ_X_ORIGPTR_2   26
#define BZ_X_ORIGPTR_3   27
#define BZ_X_MAPPING_1   28
#define BZ_X_MAPPING_2   29
#define BZ_X_SELECTOR_1  30
#define BZ_X_SELECTOR_2  31
#define BZ_X_SELECTOR_3  32
#define BZ_X_CODING_1    33
#define BZ_X_CODING_2    34
#define BZ_X_CODING_3    35
#define BZ_X_MTF_1       36
#define BZ_X_MTF_2       37
#define BZ_X_MTF_3       38
#define BZ_X_MTF_4       39
#define BZ_X_MTF_5       40
#define BZ_X_MTF_6       41
#define BZ_X_ENDHDR_2    42
#define BZ_X_ENDHDR_3    43
#define BZ_X_ENDHDR_4    44
#define BZ_X_ENDHDR_5    45
#define BZ_X_ENDHDR_6    46
#define BZ_X_CCRC_1      47
#define BZ_X_CCRC_2      48
#define BZ_X_CCRC_3      49
#define BZ_X_CCRC_4      50



/*-- Constants for the fast MTF decoder. --*/

#define MTFA_SIZE 4096
#define MTFL_SIZE 16



/*-- Structure holding all the decompression-side stuff. --*/

typedef
   struct {
      /* pointer back to the struct bz_stream */
      bz_stream* strm;

      /* state indicator for this stream */
      Int32    state;

      /* for doing the final run-length decoding */
      UChar    state_out_ch;
      Int32    state_out_len;
      Bool     blockRandomised;
      BZ_RAND_DECLS;

      /* the buffer for bit stream reading */
      UInt32   bsBuff;
      Int32    bsLive;

      /* misc administratium */
      Int32    blockSize100k;
      Bool     smallDecompress;
      Int32    currBlockNo;
      Int32    verbosity;

      /* for undoing the Burrows-Wheeler transform */
      Int32    origPtr;
      UInt32   tPos;
      Int32    k0;
      Int32    unzftab[256];
      Int32    nblock_used;
      Int32    cftab[257];
      Int32    cftabCopy[257];

      /* for undoing the Burrows-Wheeler transform (FAST) */
      UInt32   *tt;

      /* for undoing the Burrows-Wheeler transform (SMALL) */
      UInt16   *ll16;
      UChar    *ll4;

      /* stored and calculated CRCs */
      UInt32   storedBlockCRC;
      UInt32   storedCombinedCRC;
      UInt32   calculatedBlockCRC;
      UInt32   calculatedCombinedCRC;

      /* map of bytes used in block */
      Int32    nInUse;
      Bool     inUse[256];
      Bool     inUse16[16];
      UChar    seqToUnseq[256];

      /* for decoding the MTF values */
      UChar    mtfa   [MTFA_SIZE];
      Int32    mtfbase[256 / MTFL_SIZE];
      UChar    selector   [BZ_MAX_SELECTORS];
      UChar    selectorMtf[BZ_MAX_SELECTORS];
      UChar    len  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];

      Int32    limit  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
      Int32    base   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
      Int32    perm   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
      Int32    minLens[BZ_N_GROUPS];

      /* save area for scalars in the main decompress code */
      Int32    save_i;
      Int32    save_j;
      Int32    save_t;
      Int32    save_alphaSize;
      Int32    save_nGroups;
      Int32    save_nSelectors;
      Int32    save_EOB;
      Int32    save_groupNo;
      Int32    save_groupPos;
      Int32    save_nextSym;
      Int32    save_nblockMAX;
      Int32    save_nblock;
      Int32    save_es;
      Int32    save_N;
      Int32    save_curr;
      Int32    save_zt;
      Int32    save_zn; 
      Int32    save_zvec;
      Int32    save_zj;
      Int32    save_gSel;
      Int32    save_gMinlen;
      Int32*   save_gLimit;
      Int32*   save_gBase;
      Int32*   save_gPerm;

   }
   DState;



/*-- Macros for decompression. --*/

#define BZ_GET_FAST(cccc)                     \
    s->tPos = s->tt[s->tPos];                 \
    cccc = (UChar)(s->tPos & 0xff);           \
    s->tPos >>= 8;

#define BZ_GET_FAST_C(cccc)                   \
    c_tPos = c_tt[c_tPos];                    \
    cccc = (UChar)(c_tPos & 0xff);            \
    c_tPos >>= 8;

#define SET_LL4(i,n)                                          \
   { if (((i) & 0x1) == 0)                                    \
        s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 0xf0) | (n); else    \
        s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 0x0f) | ((n) << 4);  \
   }

#define GET_LL4(i)                             \
   ((((UInt32)(s->ll4[(i) >> 1])) >> (((i) << 2) & 0x4)) & 0xF)

#define SET_LL(i,n)                          \
   { s->ll16[i] = (UInt16)(n & 0x0000ffff);  \
     SET_LL4(i, n >> 16);                    \
   }

#define GET_LL(i) \
   (((UInt32)s->ll16[i]) | (GET_LL4(i) << 16))

#define BZ_GET_SMALL(cccc)                            \
      cccc = BZ2_indexIntoF ( s->tPos, s->cftab );    \
      s->tPos = GET_LL(s->tPos);


/*-- externs for decompression. --*/

extern Int32 
BZ2_indexIntoF ( Int32, Int32* );

extern Int32 
BZ2_decompress ( DState* );

extern void 
BZ2_hbCreateDecodeTables ( Int32*, Int32*, Int32*, UChar*,
                           Int32,  Int32, Int32 );


#endif


/*-- BZ_NO_STDIO seems to make NULL disappear on some platforms. --*/

#ifdef BZ_NO_STDIO
#ifndef NULL
#define NULL 0
#endif
#endif


/*-------------------------------------------------------------*/
/*--- end                                   bzlib_private.h ---*/
/*-------------------------------------------------------------*/



/*-------------------------------------------------------------*/
/*--- Block sorting machinery                               ---*/
/*---                                           blocksort.c ---*/
/*-------------------------------------------------------------*/

/*---------------------------------------------*/
/*--- Fallback O(N log(N)^2) sorting        ---*/
/*--- algorithm, for repetitive blocks      ---*/
/*---------------------------------------------*/

/*---------------------------------------------*/
Int32 fallbackSimpleSort_i;
Int32 fallbackSimpleSort_j;
Int32 fallbackSimpleSort_tmp;
UInt32 fallbackSimpleSort_ec_tmp;
static 
__inline__
void fallbackSimpleSort ( UInt32* fmap, 
                          UInt32* eclass, 
                          Int32   lo, 
                          Int32   hi )
{
   
   

   if (lo == hi) return;

   if (hi - lo > 3) {
      for ( fallbackSimpleSort_i = hi-4; fallbackSimpleSort_i >= lo; fallbackSimpleSort_i-- ) {
         fallbackSimpleSort_tmp = fmap[fallbackSimpleSort_i];
         fallbackSimpleSort_ec_tmp = eclass[fallbackSimpleSort_tmp];
         for ( fallbackSimpleSort_j = fallbackSimpleSort_i+4; fallbackSimpleSort_j <= hi && fallbackSimpleSort_ec_tmp > eclass[fmap[fallbackSimpleSort_j]]; fallbackSimpleSort_j += 4 )
            fmap[fallbackSimpleSort_j-4] = fmap[fallbackSimpleSort_j];
         fmap[fallbackSimpleSort_j-4] = fallbackSimpleSort_tmp;
      }
   }

   for ( fallbackSimpleSort_i = hi-1; fallbackSimpleSort_i >= lo; fallbackSimpleSort_i-- ) {
      fallbackSimpleSort_tmp = fmap[fallbackSimpleSort_i];
      fallbackSimpleSort_ec_tmp = eclass[fallbackSimpleSort_tmp];
      for ( fallbackSimpleSort_j = fallbackSimpleSort_i+1; fallbackSimpleSort_j <= hi && fallbackSimpleSort_ec_tmp > eclass[fmap[fallbackSimpleSort_j]]; fallbackSimpleSort_j++ )
         fmap[fallbackSimpleSort_j-1] = fmap[fallbackSimpleSort_j];
      fmap[fallbackSimpleSort_j-1] = fallbackSimpleSort_tmp;
   }
}


/*---------------------------------------------*/
#define fswap(zz1, zz2) \
   { Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }

#define fvswap(zzp1, zzp2, zzn)       \
{                                     \
   Int32 yyp1 = (zzp1);               \
   Int32 yyp2 = (zzp2);               \
   Int32 yyn  = (zzn);                \
   while (yyn > 0) {                  \
      fswap(fmap[yyp1], fmap[yyp2]);  \
      yyp1++; yyp2++; yyn--;          \
   }                                  \
}


#define fmin(a,b) ((a) < (b)) ? (a) : (b)

#define fpush(lz,hz) { stackLo[sp] = lz; \
                       stackHi[sp] = hz; \
                       sp++; }

#define fpop(lz,hz) { sp--;              \
                      lz = stackLo[sp];  \
                      hz = stackHi[sp]; }

#define FALLBACK_QSORT_SMALL_THRESH 10
#define FALLBACK_QSORT_STACK_SIZE   100


Int32 fallbackQSort3_n;
Int32 fallbackQSort3_m;
UInt32 fallbackQSort3_med;
UInt32 fallbackQSort3_r;
UInt32 fallbackQSort3_r3;
static
void fallbackQSort3 ( UInt32* fmap, 
                      UInt32* eclass,
                      Int32   loSt, 
                      Int32   hiSt )
{
   Int32 unLo, unHi, ltLo, gtHi;
   Int32 sp, lo, hi;
   
   Int32 stackLo[FALLBACK_QSORT_STACK_SIZE];
   Int32 stackHi[FALLBACK_QSORT_STACK_SIZE];

   fallbackQSort3_r = 0;

   sp = 0;
   fpush ( loSt, hiSt );

   while (sp > 0) {

      AssertH ( sp < FALLBACK_QSORT_STACK_SIZE, 1004 );

      fpop ( lo, hi );
      if (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {
         fallbackSimpleSort ( fmap, eclass, lo, hi );
         continue;
      }

      /* Random partitioning.  Median of 3 sometimes fails to
         avoid bad cases.  Median of 9 seems to help but 
         looks rather expensive.  This too seems to work but
         is cheaper.  Guidance for the magic constants 
         7621 and 32768 is taken from Sedgewick's algorithms
         book, chapter 35.
      */
      fallbackQSort3_r = ((fallbackQSort3_r * 7621) + 1) % 32768;
      fallbackQSort3_r3 = fallbackQSort3_r % 3;
      if (fallbackQSort3_r3 == 0) fallbackQSort3_med = eclass[fmap[lo]]; else
      if (fallbackQSort3_r3 == 1) fallbackQSort3_med = eclass[fmap[(lo+hi)>>1]]; else
                   fallbackQSort3_med = eclass[fmap[hi]];

      unLo = ltLo = lo;
      unHi = gtHi = hi;

      while (1) {
         while (1) {
            if (unLo > unHi) break;
            fallbackQSort3_n = (Int32)eclass[fmap[unLo]] - (Int32)fallbackQSort3_med;
            if (fallbackQSort3_n == 0) { 
               fswap(fmap[unLo], fmap[ltLo]); 
               ltLo++; unLo++; 
               continue; 
            };
            if (fallbackQSort3_n > 0) break;
            unLo++;
         }
         while (1) {
            if (unLo > unHi) break;
            fallbackQSort3_n = (Int32)eclass[fmap[unHi]] - (Int32)fallbackQSort3_med;
            if (fallbackQSort3_n == 0) { 
               fswap(fmap[unHi], fmap[gtHi]); 
               gtHi--; unHi--; 
               continue; 
            };
            if (fallbackQSort3_n < 0) break;
            unHi--;
         }
         if (unLo > unHi) break;
         fswap(fmap[unLo], fmap[unHi]); unLo++; unHi--;
      }

      AssertD ( unHi == unLo-1, "fallbackQSort3(2)" );

      if (gtHi < ltLo) continue;

      fallbackQSort3_n = fmin(ltLo-lo, unLo-ltLo); fvswap(lo, unLo-fallbackQSort3_n, fallbackQSort3_n);
      fallbackQSort3_m = fmin(hi-gtHi, gtHi-unHi); fvswap(unLo, hi-fallbackQSort3_m+1, fallbackQSort3_m);

      fallbackQSort3_n = lo + unLo - ltLo - 1;
      fallbackQSort3_m = hi - (gtHi - unHi) + 1;

      if (fallbackQSort3_n - lo > hi - fallbackQSort3_m) {
         fpush ( lo, fallbackQSort3_n );
         fpush ( fallbackQSort3_m, hi );
      } else {
         fpush ( fallbackQSort3_m, hi );
         fpush ( lo, fallbackQSort3_n );
      }
   }
}

#undef fmin
#undef fpush
#undef fpop
#undef fswap
#undef fvswap
#undef FALLBACK_QSORT_SMALL_THRESH
#undef FALLBACK_QSORT_STACK_SIZE


/*---------------------------------------------*/
/* Pre:
      nblock > 0
      eclass exists for [0 .. nblock-1]
      ((UChar*)eclass) [0 .. nblock-1] holds block
      ptr exists for [0 .. nblock-1]

   Post:
      ((UChar*)eclass) [0 .. nblock-1] holds block
      All other areas of eclass destroyed
      fmap [0 .. nblock-1] holds sorted order
      bhtab [ 0 .. 2+(nblock/32) ] destroyed
*/

#define       SET_BH(zz)  bhtab[(zz) >> 5] |= (1 << ((zz) & 31))
#define     CLEAR_BH(zz)  bhtab[(zz) >> 5] &= ~(1 << ((zz) & 31))
#define     ISSET_BH(zz)  (bhtab[(zz) >> 5] & (1 << ((zz) & 31)))
#define      WORD_BH(zz)  bhtab[(zz) >> 5]
#define UNALIGNED_BH(zz)  ((zz) & 0x01f)

Int32 fallbackSort_ftabCopy[256];
Int32 fallbackSort_j;
Int32 fallbackSort_l;
Int32 fallbackSort_r;
Int32 fallbackSort_cc;
Int32 fallbackSort_cc1;
Int32 fallbackSort_nBhtab;
static
void fallbackSort ( UInt32* fmap, 
                    UInt32* eclass, 
                    UInt32* bhtab,
                    Int32   nblock,
                    Int32   verb )
{
   Int32 ftab[257];
   
   Int32 H, i, k;
   Int32 nNotDone;
   
   UChar* eclass8 = (UChar*)eclass;

   /*--
      Initial 1-char radix sort to generate
      initial fmap and initial BH bits.
   --*/
   if (verb >= 4)
      VPrintf0 ( "        bucket sorting ...\n" );
   for (i = 0; i < 257;    i++) ftab[i] = 0;
   for (i = 0; i < nblock; i++) ftab[eclass8[i]]++;
   for (i = 0; i < 256;    i++) fallbackSort_ftabCopy[i] = ftab[i];
   for (i = 1; i < 257;    i++) ftab[i] += ftab[i-1];

   for (i = 0; i < nblock; i++) {
      fallbackSort_j = eclass8[i];
      k = ftab[fallbackSort_j] - 1;
      ftab[fallbackSort_j] = k;
      fmap[k] = i;
   }

   fallbackSort_nBhtab = 2 + (nblock / 32);
   for (i = 0; i < fallbackSort_nBhtab; i++) bhtab[i] = 0;
   for (i = 0; i < 256; i++) SET_BH(ftab[i]);

   /*--
      Inductively refine the buckets.  Kind-of an
      "exponential radix sort" (!), inspired by the
      Manber-Myers suffix array construction algorithm.
   --*/

   /*-- set sentinel bits for block-end detection --*/
   for (i = 0; i < 32; i++) { 
      SET_BH(nblock + 2*i);
      CLEAR_BH(nblock + 2*i + 1);
   }

   /*-- the log(N) loop --*/
   H = 1;
   while (1) {

      if (verb >= 4) 
         VPrintf1 ( "        depth %6d has ", H );

      fallbackSort_j = 0;
      for (i = 0; i < nblock; i++) {
         if (ISSET_BH(i)) fallbackSort_j = i;
         k = fmap[i] - H; if (k < 0) k += nblock;
         eclass[k] = fallbackSort_j;
      }

      nNotDone = 0;
      fallbackSort_r = -1;
      while (1) {

	 /*-- find the next non-singleton bucket --*/
         k = fallbackSort_r + 1;
         while (ISSET_BH(k) && UNALIGNED_BH(k)) k++;
         if (ISSET_BH(k)) {
            while (WORD_BH(k) == 0xffffffff) k += 32;
            while (ISSET_BH(k)) k++;
         }
         fallbackSort_l = k - 1;
         if (fallbackSort_l >= nblock) break;
         while (!ISSET_BH(k) && UNALIGNED_BH(k)) k++;
         if (!ISSET_BH(k)) {
            while (WORD_BH(k) == 0x00000000) k += 32;
            while (!ISSET_BH(k)) k++;
         }
         fallbackSort_r = k - 1;
         if (fallbackSort_r >= nblock) break;

         /*-- now [l, r] bracket current bucket --*/
         if (fallbackSort_r > fallbackSort_l) {
            nNotDone += (fallbackSort_r - fallbackSort_l + 1);
            fallbackQSort3 ( fmap, eclass, fallbackSort_l, fallbackSort_r );

            /*-- scan bucket and generate header bits-- */
            fallbackSort_cc = -1;
            for (i = fallbackSort_l; i <= fallbackSort_r; i++) {
               fallbackSort_cc1 = eclass[fmap[i]];
               if (fallbackSort_cc != fallbackSort_cc1) { SET_BH(i); fallbackSort_cc = fallbackSort_cc1; };
            }
         }
      }

      if (verb >= 4) 
         VPrintf1 ( "%6d unresolved strings\n", nNotDone );

      H *= 2;
      if (H > nblock || nNotDone == 0) break;
   }

   /*-- 
      Reconstruct the original block in
      eclass8 [0 .. nblock-1], since the
      previous phase destroyed it.
   --*/
   if (verb >= 4)
      VPrintf0 ( "        reconstructing block ...\n" );
   fallbackSort_j = 0;
   for (i = 0; i < nblock; i++) {
      while (fallbackSort_ftabCopy[fallbackSort_j] == 0) fallbackSort_j++;
      fallbackSort_ftabCopy[fallbackSort_j]--;
      eclass8[fmap[i]] = (UChar)fallbackSort_j;
   }
   AssertH ( fallbackSort_j < 256, 1005 );
}

#undef       SET_BH
#undef     CLEAR_BH
#undef     ISSET_BH
#undef      WORD_BH
#undef UNALIGNED_BH


/*---------------------------------------------*/
/*--- The main, O(N^2 log(N)) sorting       ---*/
/*--- algorithm.  Faster for "normal"       ---*/
/*--- non-repetitive blocks.                ---*/
/*---------------------------------------------*/

/*---------------------------------------------*/
Int32 mainGtU_k;
UChar mainGtU_c1;
UChar mainGtU_c2;
UInt16 mainGtU_s1;
UInt16 mainGtU_s2;
static
__inline__
Bool mainGtU ( UInt32  i1, 
               UInt32  i2,
               UChar*  block, 
               UInt16* quadrant,
               UInt32  nblock,
               Int32*  budget )
{
   
   
   

   AssertD ( i1 != i2, "mainGtU" );
   /* 1 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 2 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 3 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 4 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 5 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 6 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 7 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 8 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 9 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 10 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 11 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;
   /* 12 */
   mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
   if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
   i1++; i2++;

   mainGtU_k = nblock + 8;

   do {
      /* 1 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 2 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 3 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 4 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 5 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 6 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 7 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;
      /* 8 */
      mainGtU_c1 = block[i1]; mainGtU_c2 = block[i2];
      if (mainGtU_c1 != mainGtU_c2) return (mainGtU_c1 > mainGtU_c2);
      mainGtU_s1 = quadrant[i1]; mainGtU_s2 = quadrant[i2];
      if (mainGtU_s1 != mainGtU_s2) return (mainGtU_s1 > mainGtU_s2);
      i1++; i2++;

      if (i1 >= nblock) i1 -= nblock;
      if (i2 >= nblock) i2 -= nblock;

      mainGtU_k -= 8;
      (*budget)--;
   }
      while (mainGtU_k >= 0);

   return False;
}


/*---------------------------------------------*/
/*--
   Knuth's increments seem to work better
   than Incerpi-Sedgewick here.  Possibly
   because the number of elems to sort is
   usually small, typically <= 20.
--*/
static
Int32 incs[14] = { 1, 4, 13, 40, 121, 364, 1093, 3280,
                   9841, 29524, 88573, 265720,
                   797161, 2391484 };

Int32 mainSimpleSort_i;
Int32 mainSimpleSort_j;
Int32 mainSimpleSort_h;
Int32 mainSimpleSort_bigN;
Int32 mainSimpleSort_hp;
UInt32 mainSimpleSort_v;
static
void mainSimpleSort ( UInt32* ptr,
                      UChar*  block,
                      UInt16* quadrant,
                      Int32   nblock,
                      Int32   lo, 
                      Int32   hi, 
                      Int32   d,
                      Int32*  budget )
{
   
   

   mainSimpleSort_bigN = hi - lo + 1;
   if (mainSimpleSort_bigN < 2) return;

   mainSimpleSort_hp = 0;
   while (incs[mainSimpleSort_hp] < mainSimpleSort_bigN) mainSimpleSort_hp++;
   mainSimpleSort_hp--;

   for (; mainSimpleSort_hp >= 0; mainSimpleSort_hp--) {
      mainSimpleSort_h = incs[mainSimpleSort_hp];

      mainSimpleSort_i = lo + mainSimpleSort_h;
      while (True) {

         /*-- copy 1 --*/
         if (mainSimpleSort_i > hi) break;
         mainSimpleSort_v = ptr[mainSimpleSort_i];
         mainSimpleSort_j = mainSimpleSort_i;
         while ( mainGtU ( 
                    ptr[mainSimpleSort_j-mainSimpleSort_h]+d, mainSimpleSort_v+d, block, quadrant, nblock, budget 
                 ) ) {
            ptr[mainSimpleSort_j] = ptr[mainSimpleSort_j-mainSimpleSort_h];
            mainSimpleSort_j = mainSimpleSort_j - mainSimpleSort_h;
            if (mainSimpleSort_j <= (lo + mainSimpleSort_h - 1)) break;
         }
         ptr[mainSimpleSort_j] = mainSimpleSort_v;
         mainSimpleSort_i++;

         /*-- copy 2 --*/
         if (mainSimpleSort_i > hi) break;
         mainSimpleSort_v = ptr[mainSimpleSort_i];
         mainSimpleSort_j = mainSimpleSort_i;
         while ( mainGtU ( 
                    ptr[mainSimpleSort_j-mainSimpleSort_h]+d, mainSimpleSort_v+d, block, quadrant, nblock, budget 
                 ) ) {
            ptr[mainSimpleSort_j] = ptr[mainSimpleSort_j-mainSimpleSort_h];
            mainSimpleSort_j = mainSimpleSort_j - mainSimpleSort_h;
            if (mainSimpleSort_j <= (lo + mainSimpleSort_h - 1)) break;
         }
         ptr[mainSimpleSort_j] = mainSimpleSort_v;
         mainSimpleSort_i++;

         /*-- copy 3 --*/
         if (mainSimpleSort_i > hi) break;
         mainSimpleSort_v = ptr[mainSimpleSort_i];
         mainSimpleSort_j = mainSimpleSort_i;
         while ( mainGtU ( 
                    ptr[mainSimpleSort_j-mainSimpleSort_h]+d, mainSimpleSort_v+d, block, quadrant, nblock, budget 
                 ) ) {
            ptr[mainSimpleSort_j] = ptr[mainSimpleSort_j-mainSimpleSort_h];
            mainSimpleSort_j = mainSimpleSort_j - mainSimpleSort_h;
            if (mainSimpleSort_j <= (lo + mainSimpleSort_h - 1)) break;
         }
         ptr[mainSimpleSort_j] = mainSimpleSort_v;
         mainSimpleSort_i++;

         if (*budget < 0) return;
      }
   }
}


/*---------------------------------------------*/
/*--
   The following is an implementation of
   an elegant 3-way quicksort for strings,
   described in a paper "Fast Algorithms for
   Sorting and Searching Strings", by Robert
   Sedgewick and Jon L. Bentley.
--*/

#define mswap(zz1, zz2) \
   { Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }

#define mvswap(zzp1, zzp2, zzn)       \
{                                     \
   Int32 yyp1 = (zzp1);               \
   Int32 yyp2 = (zzp2);               \
   Int32 yyn  = (zzn);                \
   while (yyn > 0) {                  \
      mswap(ptr[yyp1], ptr[yyp2]);    \
      yyp1++; yyp2++; yyn--;          \
   }                                  \
}

UChar mmed3_t;
static 
__inline__
UChar mmed3 ( UChar a, UChar b, UChar c )
{
   
   if (a > b) { mmed3_t = a; a = b; b = mmed3_t; };
   if (b > c) { 
      b = c;
      if (a > b) b = a;
   }
   return b;
}

#define mmin(a,b) ((a) < (b)) ? (a) : (b)

#define mpush(lz,hz,dz) { stackLo[sp] = lz; \
                          stackHi[sp] = hz; \
                          stackD [sp] = dz; \
                          sp++; }

#define mpop(lz,hz,dz) { sp--;             \
                         lz = stackLo[sp]; \
                         hz = stackHi[sp]; \
                         dz = stackD [sp]; }


#define mnextsize(az) (nextHi[az]-nextLo[az])

#define mnextswap(az,bz)                                        \
   { Int32 tz;                                                  \
     mainQSort3_tz = nextLo[az]; nextLo[az] = nextLo[bz]; nextLo[bz] = mainQSort3_tz; \
     mainQSort3_tz = nextHi[az]; nextHi[az] = nextHi[bz]; nextHi[bz] = mainQSort3_tz; \
     mainQSort3_tz = nextD [az]; nextD [az] = nextD [bz]; nextD [bz] = mainQSort3_tz; }


#define MAIN_QSORT_SMALL_THRESH 20
#define MAIN_QSORT_DEPTH_THRESH (BZ_N_RADIX + BZ_N_QSORT)
#define MAIN_QSORT_STACK_SIZE 100

Int32 mainQSort3_n;
Int32 mainQSort3_m;
Int32 mainQSort3_med;
Int32 mainQSort3_d;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
Int32 mainQSort3_tz;
static
void mainQSort3 ( UInt32* ptr,
                  UChar*  block,
                  UInt16* quadrant,
                  Int32   nblock,
                  Int32   loSt, 
                  Int32   hiSt, 
                  Int32   dSt,
                  Int32*  budget )
{
   Int32 unLo, unHi, ltLo, gtHi;
   Int32 sp, lo, hi;

   Int32 stackLo[MAIN_QSORT_STACK_SIZE];
   Int32 stackHi[MAIN_QSORT_STACK_SIZE];
   Int32 stackD [MAIN_QSORT_STACK_SIZE];

   Int32 nextLo[3];
   Int32 nextHi[3];
   Int32 nextD [3];

   sp = 0;
   mpush ( loSt, hiSt, dSt );

   while (sp > 0) {

      AssertH ( sp < MAIN_QSORT_STACK_SIZE, 1001 );

      mpop ( lo, hi, mainQSort3_d );
      if (hi - lo < MAIN_QSORT_SMALL_THRESH || 
          mainQSort3_d > MAIN_QSORT_DEPTH_THRESH) {
         mainSimpleSort ( ptr, block, quadrant, nblock, lo, hi, mainQSort3_d, budget );
         if (*budget < 0) return;
         continue;
      }

      mainQSort3_med = (Int32) 
            mmed3 ( block[ptr[ lo         ]+mainQSort3_d],
                    block[ptr[ hi         ]+mainQSort3_d],
                    block[ptr[ (lo+hi)>>1 ]+mainQSort3_d] );

      unLo = ltLo = lo;
      unHi = gtHi = hi;

      while (True) {
         while (True) {
            if (unLo > unHi) break;
            mainQSort3_n = ((Int32)block[ptr[unLo]+mainQSort3_d]) - mainQSort3_med;
            if (mainQSort3_n == 0) { 
               mswap(ptr[unLo], ptr[ltLo]); 
               ltLo++; unLo++; continue; 
            };
            if (mainQSort3_n >  0) break;
            unLo++;
         }
         while (True) {
            if (unLo > unHi) break;
            mainQSort3_n = ((Int32)block[ptr[unHi]+mainQSort3_d]) - mainQSort3_med;
            if (mainQSort3_n == 0) { 
               mswap(ptr[unHi], ptr[gtHi]); 
               gtHi--; unHi--; continue; 
            };
            if (mainQSort3_n <  0) break;
            unHi--;
         }
         if (unLo > unHi) break;
         mswap(ptr[unLo], ptr[unHi]); unLo++; unHi--;
      }

      AssertD ( unHi == unLo-1, "mainQSort3(2)" );

      if (gtHi < ltLo) {
         mpush(lo, hi, mainQSort3_d+1 );
         continue;
      }

      mainQSort3_n = mmin(ltLo-lo, unLo-ltLo); mvswap(lo, unLo-mainQSort3_n, mainQSort3_n);
      mainQSort3_m = mmin(hi-gtHi, gtHi-unHi); mvswap(unLo, hi-mainQSort3_m+1, mainQSort3_m);

      mainQSort3_n = lo + unLo - ltLo - 1;
      mainQSort3_m = hi - (gtHi - unHi) + 1;

      nextLo[0] = lo;  nextHi[0] = mainQSort3_n;   nextD[0] = mainQSort3_d;
      nextLo[1] = mainQSort3_m;   nextHi[1] = hi;  nextD[1] = mainQSort3_d;
      nextLo[2] = mainQSort3_n+1; nextHi[2] = mainQSort3_m-1; nextD[2] = mainQSort3_d+1;

      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);
      if (mnextsize(1) < mnextsize(2)) mnextswap(1,2);
      if (mnextsize(0) < mnextsize(1)) mnextswap(0,1);

      AssertD (mnextsize(0) >= mnextsize(1), "mainQSort3(8)" );
      AssertD (mnextsize(1) >= mnextsize(2), "mainQSort3(9)" );

      mpush (nextLo[0], nextHi[0], nextD[0]);
      mpush (nextLo[1], nextHi[1], nextD[1]);
      mpush (nextLo[2], nextHi[2], nextD[2]);
   }
}

#undef mswap
#undef mvswap
#undef mpush
#undef mpop
#undef mmin
#undef mnextsize
#undef mnextswap
#undef MAIN_QSORT_SMALL_THRESH
#undef MAIN_QSORT_DEPTH_THRESH
#undef MAIN_QSORT_STACK_SIZE


/*---------------------------------------------*/
/* Pre:
      nblock > N_OVERSHOOT
      block32 exists for [0 .. nblock-1 +N_OVERSHOOT]
      ((UChar*)block32) [0 .. nblock-1] holds block
      ptr exists for [0 .. nblock-1]

   Post:
      ((UChar*)block32) [0 .. nblock-1] holds block
      All other areas of block32 destroyed
      ftab [0 .. 65536 ] destroyed
      ptr [0 .. nblock-1] holds sorted order
      if (*budget < 0), sorting was abandoned
*/

#define BIGFREQ(b) (ftab[((b)+1) << 8] - ftab[(b) << 8])
#define SETMASK (1 << 21)
#define CLEARMASK (~(SETMASK))

static
void mainSort ( UInt32* ptr, 
                UChar*  block,
                UInt16* quadrant, 
                UInt32* ftab,
                Int32   nblock,
                Int32   verb,
                Int32*  budget )
{
   Int32  i, j, k, ss, sb;
   Int32  runningOrder[256];
   Bool   bigDone[256];
   Int32  copyStart[256];
   Int32  copyEnd  [256];
   UChar  c1;
   Int32  numQSorted;
   UInt16 s;
   if (verb >= 4) VPrintf0 ( "        main sort initialise ...\n" );

   /*-- set up the 2-byte frequency table --*/
   for (i = 65536; i >= 0; i--) ftab[i] = 0;

   j = block[0] << 8;
   i = nblock-1;
   for (; i >= 3; i -= 4) {
      quadrant[i] = 0;
      j = (j >> 8) | ( ((UInt16)block[i]) << 8);
      ftab[j]++;
      quadrant[i-1] = 0;
      j = (j >> 8) | ( ((UInt16)block[i-1]) << 8);
      ftab[j]++;
      quadrant[i-2] = 0;
      j = (j >> 8) | ( ((UInt16)block[i-2]) << 8);
      ftab[j]++;
      quadrant[i-3] = 0;
      j = (j >> 8) | ( ((UInt16)block[i-3]) << 8);
      ftab[j]++;
   }
   for (; i >= 0; i--) {
      quadrant[i] = 0;
      j = (j >> 8) | ( ((UInt16)block[i]) << 8);
      ftab[j]++;
   }

   /*-- (emphasises close relationship of block & quadrant) --*/
   for (i = 0; i < BZ_N_OVERSHOOT; i++) {
      block   [nblock+i] = block[i];
      quadrant[nblock+i] = 0;
   }

   if (verb >= 4) VPrintf0 ( "        bucket sorting ...\n" );

   /*-- Complete the initial radix sort --*/
   for (i = 1; i <= 65536; i++) ftab[i] += ftab[i-1];

   s = block[0] << 8;
   i = nblock-1;
   for (; i >= 3; i -= 4) {
      s = (s >> 8) | (block[i] << 8);
      j = ftab[s] -1;
      ftab[s] = j;
      ptr[j] = i;
      s = (s >> 8) | (block[i-1] << 8);
      j = ftab[s] -1;
      ftab[s] = j;
      ptr[j] = i-1;
      s = (s >> 8) | (block[i-2] << 8);
      j = ftab[s] -1;
      ftab[s] = j;
      ptr[j] = i-2;
      s = (s >> 8) | (block[i-3] << 8);
      j = ftab[s] -1;
      ftab[s] = j;
      ptr[j] = i-3;
   }
   for (; i >= 0; i--) {
      s = (s >> 8) | (block[i] << 8);
      j = ftab[s] -1;
      ftab[s] = j;
      ptr[j] = i;
   }

   /*--
      Now ftab contains the first loc of every small bucket.
      Calculate the running order, from smallest to largest
      big bucket.
   --*/
   for (i = 0; i <= 255; i++) {
      bigDone     [i] = False;
      runningOrder[i] = i;
   }

   {
      Int32 vv;
      Int32 h = 1;
      do h = 3 * h + 1; while (h <= 256);
      do {
         h = h / 3;
         for (i = h; i <= 255; i++) {
            vv = runningOrder[i];
            j = i;
            while ( BIGFREQ(runningOrder[j-h]) > BIGFREQ(vv) ) {
               runningOrder[j] = runningOrder[j-h];
               j = j - h;
               if (j <= (h - 1)) goto zero;
            }
            zero:
            runningOrder[j] = vv;
         }
      } while (h != 1);
   }

   /*--
      The main sorting loop.
   --*/

   numQSorted = 0;

   for (i = 0; i <= 255; i++) {

      /*--
         Process big buckets, starting with the least full.
         Basically this is a 3-step process in which we call
         mainQSort3 to sort the small buckets [ss, j], but
         also make a big effort to avoid the calls if we can.
      --*/
      ss = runningOrder[i];

      /*--
         Step 1:
         Complete the big bucket [ss] by quicksorting
         any unsorted small buckets [ss, j], for j != ss.  
         Hopefully previous pointer-scanning phases have already
         completed many of the small buckets [ss, j], so
         we don't have to sort them at all.
      --*/
      for (j = 0; j <= 255; j++) {
         if (j != ss) {
            sb = (ss << 8) + j;
            if ( ! (ftab[sb] & SETMASK) ) {
               Int32 lo = ftab[sb]   & CLEARMASK;
               Int32 hi = (ftab[sb+1] & CLEARMASK) - 1;
               if (hi > lo) {
                  if (verb >= 4)
                     VPrintf4 ( "        qsort [0x%x, 0x%x]   "
                                "done %d   this %d\n",
                                ss, j, numQSorted, hi - lo + 1 );
                  mainQSort3 ( 
                     ptr, block, quadrant, nblock, 
                     lo, hi, BZ_N_RADIX, budget 
                  );   
                  numQSorted += (hi - lo + 1);
                  if (*budget < 0) return;
               }
            }
            ftab[sb] |= SETMASK;
         }
      }

      AssertH ( !bigDone[ss], 1006 );

      /*--
         Step 2:
         Now scan this big bucket [ss] so as to synthesise the
         sorted order for small buckets [t, ss] for all t,
         including, magically, the bucket [ss,ss] too.
         This will avoid doing Real Work in subsequent Step 1's.
      --*/
      {
         for (j = 0; j <= 255; j++) {
            copyStart[j] =  ftab[(j << 8) + ss]     & CLEARMASK;
            copyEnd  [j] = (ftab[(j << 8) + ss + 1] & CLEARMASK) - 1;
         }
         for (j = ftab[ss << 8] & CLEARMASK; j < copyStart[ss]; j++) {
            k = ptr[j]-1; if (k < 0) k += nblock;
            c1 = block[k];
            if (!bigDone[c1])
               ptr[ copyStart[c1]++ ] = k;
         }
         for (j = (ftab[(ss+1) << 8] & CLEARMASK) - 1; j > copyEnd[ss]; j--) {
            k = ptr[j]-1; if (k < 0) k += nblock;
            c1 = block[k];
            if (!bigDone[c1]) 
               ptr[ copyEnd[c1]-- ] = k;
         }
      }

      AssertH ( (copyStart[ss]-1 == copyEnd[ss])
                || 
                /* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.
                   Necessity for this case is demonstrated by compressing 
                   a sequence of approximately 48.5 million of character 
                   251; 1.0.0/1.0.1 will then die here. */
                (copyStart[ss] == 0 && copyEnd[ss] == nblock-1),
                1007 )

      for (j = 0; j <= 255; j++) ftab[(j << 8) + ss] |= SETMASK;

      /*--
         Step 3:
         The [ss] big bucket is now done.  Record this fact,
         and update the quadrant descriptors.  Remember to
         update quadrants in the overshoot area too, if
         necessary.  The "if (i < 255)" test merely skips
         this updating for the last bucket processed, since
         updating for the last bucket is pointless.

         The quadrant array provides a way to incrementally
         cache sort orderings, as they appear, so as to 
         make subsequent comparisons in fullGtU() complete
         faster.  For repetitive blocks this makes a big
         difference (but not big enough to be able to avoid
         the fallback sorting mechanism, exponential radix sort).

         The precise meaning is: at all times:

            for 0 <= i < nblock and 0 <= j <= nblock

            if block[i] != block[j], 

               then the relative values of quadrant[i] and 
                    quadrant[j] are meaningless.

               else {
                  if quadrant[i] < quadrant[j]
                     then the string starting at i lexicographically
                     precedes the string starting at j

                  else if quadrant[i] > quadrant[j]
                     then the string starting at j lexicographically
                     precedes the string starting at i

                  else
                     the relative ordering of the strings starting
                     at i and j has not yet been determined.
               }
      --*/
      bigDone[ss] = True;

      if (i < 255) {
         Int32 bbStart  = ftab[ss << 8] & CLEARMASK;
         Int32 bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;
         Int32 shifts   = 0;

         while ((bbSize >> shifts) > 65534) shifts++;

         for (j = bbSize-1; j >= 0; j--) {
            Int32 a2update     = ptr[bbStart + j];
            UInt16 qVal        = (UInt16)(j >> shifts);
            quadrant[a2update] = qVal;
            if (a2update < BZ_N_OVERSHOOT)
               quadrant[a2update + nblock] = qVal;
         }
         AssertH ( ((bbSize-1) >> shifts) <= 65535, 1002 );
      }

   }

   if (verb >= 4)
      VPrintf3 ( "        %d pointers, %d sorted, %d scanned\n",
                 nblock, numQSorted, nblock - numQSorted );
}

#undef BIGFREQ
#undef SETMASK
#undef CLEARMASK


/*---------------------------------------------*/
/* Pre:
      nblock > 0
      arr2 exists for [0 .. nblock-1 +N_OVERSHOOT]
      ((UChar*)arr2)  [0 .. nblock-1] holds block
      arr1 exists for [0 .. nblock-1]

   Post:
      ((UChar*)arr2) [0 .. nblock-1] holds block
      All other areas of block destroyed
      ftab [ 0 .. 65536 ] destroyed
      arr1 [0 .. nblock-1] holds sorted order
*/
void BZ2_blockSort ( EState* s )
{
   UInt32* ptr    = s->ptr; 
   UChar*  block  = s->block;
   UInt32* ftab   = s->ftab;
   Int32   nblock = s->nblock;
   Int32   verb   = s->verbosity;
   Int32   wfact  = s->workFactor;
   UInt16* quadrant;
   Int32   budget;
   Int32   budgetInit;
   Int32   i;

   if (nblock < 10000) {
      fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );
   } else {
      /* Calculate the location for quadrant, remembering to get
         the alignment right.  Assumes that &(block[0]) is at least
         2-byte aligned -- this should be ok since block is really
         the first section of arr2.
      */
      i = nblock+BZ_N_OVERSHOOT;
      if (i & 1) i++;
      quadrant = (UInt16*)(&(block[i]));

      /* (wfact-1) / 3 puts the default-factor-30
         transition point at very roughly the same place as 
         with v0.1 and v0.9.0.  
         Not that it particularly matters any more, since the
         resulting compressed stream is now the same regardless
         of whether or not we use the main sort or fallback sort.
      */
      if (wfact < 1  ) wfact = 1;
      if (wfact > 100) wfact = 100;
      budgetInit = nblock * ((wfact-1) / 3);
      budget = budgetInit;

      mainSort ( ptr, block, quadrant, ftab, nblock, verb, &budget );
      if (verb >= 3) 
         VPrintf3 ( "      %d work, %d block, ratio %5.2f\n",
                    budgetInit - budget,
                    nblock, 
                    (float)(budgetInit - budget) /
                    (float)(nblock==0 ? 1 : nblock) ); 
      if (budget < 0) {
         if (verb >= 2) 
            VPrintf0 ( "    too repetitive; using fallback"
                       " sorting algorithm\n" );
         fallbackSort ( s->arr1, s->arr2, ftab, nblock, verb );
      }
   }

   s->origPtr = -1;
   for (i = 0; i < s->nblock; i++)
      if (ptr[i] == 0)
         { s->origPtr = i; break; };

   AssertH( s->origPtr != -1, 1003 );
}


/*-------------------------------------------------------------*/
/*--- end                                       blocksort.c ---*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*--- Huffman coding low-level stuff                        ---*/
/*---                                             huffman.c ---*/
/*-------------------------------------------------------------*/


/*---------------------------------------------------*/
#define WEIGHTOF(zz0)  ((zz0) & 0xffffff00)
#define DEPTHOF(zz1)   ((zz1) & 0x000000ff)
#define MYMAX(zz2,zz3) ((zz2) > (zz3) ? (zz2) : (zz3))

#define ADDWEIGHTS(zw1,zw2)                           \
   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \
   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))

#define UPHEAP(z)                                     \
{                                                     \
   Int32 zz, tmp;                                     \
   zz = z; tmp = heap[zz];                            \
   while (weight[tmp] < weight[heap[zz >> 1]]) {      \
      heap[zz] = heap[zz >> 1];                       \
      zz >>= 1;                                       \
   }                                                  \
   heap[zz] = tmp;                                    \
}

#define DOWNHEAP(z)                                   \
{                                                     \
   Int32 zz, yy, tmp;                                 \
   zz = z; tmp = heap[zz];                            \
   while (True) {                                     \
      yy = zz << 1;                                   \
      if (yy > nHeap) break;                          \
      if (yy < nHeap &&                               \
          weight[heap[yy+1]] < weight[heap[yy]])      \
         yy++;                                        \
      if (weight[tmp] < weight[heap[yy]]) break;      \
      heap[zz] = heap[yy];                            \
      zz = yy;                                        \
   }                                                  \
   heap[zz] = tmp;                                    \
}


/*---------------------------------------------------*/
void BZ2_hbMakeCodeLengths ( UChar *len, 
                             Int32 *freq,
                             Int32 alphaSize,
                             Int32 maxLen )
{
   /*--
      Nodes and heap entries run from 1.  Entry 0
      for both the heap and nodes is a sentinel.
   --*/
   Int32 nNodes, nHeap, n1, n2, i, j, k;
   Bool  tooLong;

   Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];
   Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];
   Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ]; 

   for (i = 0; i < alphaSize; i++)
      weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) << 8;

   while (True) {

      nNodes = alphaSize;
      nHeap = 0;

      heap[0] = 0;
      weight[0] = 0;
      parent[0] = -2;

      for (i = 1; i <= alphaSize; i++) {
         parent[i] = -1;
         nHeap++;
         heap[nHeap] = i;
         UPHEAP(nHeap);
      }

      AssertH( nHeap < (BZ_MAX_ALPHA_SIZE+2), 2001 );
   
      while (nHeap > 1) {
         n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
         n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
         nNodes++;
         parent[n1] = parent[n2] = nNodes;
         weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);
         parent[nNodes] = -1;
         nHeap++;
         heap[nHeap] = nNodes;
         UPHEAP(nHeap);
      }

      AssertH( nNodes < (BZ_MAX_ALPHA_SIZE * 2), 2002 );

      tooLong = False;
      for (i = 1; i <= alphaSize; i++) {
         j = 0;
         k = i;
         while (parent[k] >= 0) { k = parent[k]; j++; }
         len[i-1] = j;
         if (j > maxLen) tooLong = True;
      }
      
      if (! tooLong) break;

      for (i = 1; i < alphaSize; i++) {
         j = weight[i] >> 8;
         j = 1 + (j / 2);
         weight[i] = j << 8;
      }
   }
}


/*---------------------------------------------------*/
void BZ2_hbAssignCodes ( Int32 *code,
                         UChar *length,
                         Int32 minLen,
                         Int32 maxLen,
                         Int32 alphaSize )
{
   Int32 n, vec, i;

   vec = 0;
   for (n = minLen; n <= maxLen; n++) {
      for (i = 0; i < alphaSize; i++)
         if (length[i] == n) { code[i] = vec; vec++; };
      vec <<= 1;
   }
}


/*---------------------------------------------------*/
void BZ2_hbCreateDecodeTables ( Int32 *limit,
                                Int32 *base,
                                Int32 *perm,
                                UChar *length,
                                Int32 minLen,
                                Int32 maxLen,
                                Int32 alphaSize )
{
   Int32 pp, i, j, vec;

   pp = 0;
   for (i = minLen; i <= maxLen; i++)
      for (j = 0; j < alphaSize; j++)
         if (length[j] == i) { perm[pp] = j; pp++; };

   for (i = 0; i < BZ_MAX_CODE_LEN; i++) base[i] = 0;
   for (i = 0; i < alphaSize; i++) base[length[i]+1]++;

   for (i = 1; i < BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];

   for (i = 0; i < BZ_MAX_CODE_LEN; i++) limit[i] = 0;
   vec = 0;

   for (i = minLen; i <= maxLen; i++) {
      vec += (base[i+1] - base[i]);
      limit[i] = vec-1;
      vec <<= 1;
   }
   for (i = minLen + 1; i <= maxLen; i++)
      base[i] = ((limit[i-1] + 1) << 1) - base[i];
}


/*-------------------------------------------------------------*/
/*--- end                                         huffman.c ---*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*--- Table for doing CRCs                                  ---*/
/*---                                            crctable.c ---*/
/*-------------------------------------------------------------*/


/*--
  I think this is an implementation of the AUTODIN-II,
  Ethernet & FDDI 32-bit CRC standard.  Vaguely derived
  from code by Rob Warnock, in Section 51 of the
  comp.compression FAQ.
--*/

UInt32 BZ2_crc32Table[256] = {

   /*-- Ugly, innit? --*/

   0x00000000L, 0x04c11db7L, 0x09823b6eL, 0x0d4326d9L,
   0x130476dcL, 0x17c56b6bL, 0x1a864db2L, 0x1e475005L,
   0x2608edb8L, 0x22c9f00fL, 0x2f8ad6d6L, 0x2b4bcb61L,
   0x350c9b64L, 0x31cd86d3L, 0x3c8ea00aL, 0x384fbdbdL,
   0x4c11db70L, 0x48d0c6c7L, 0x4593e01eL, 0x4152fda9L,
   0x5f15adacL, 0x5bd4b01bL, 0x569796c2L, 0x52568b75L,
   0x6a1936c8L, 0x6ed82b7fL, 0x639b0da6L, 0x675a1011L,
   0x791d4014L, 0x7ddc5da3L, 0x709f7b7aL, 0x745e66cdL,
   0x9823b6e0L, 0x9ce2ab57L, 0x91a18d8eL, 0x95609039L,
   0x8b27c03cL, 0x8fe6dd8bL, 0x82a5fb52L, 0x8664e6e5L,
   0xbe2b5b58L, 0xbaea46efL, 0xb7a96036L, 0xb3687d81L,
   0xad2f2d84L, 0xa9ee3033L, 0xa4ad16eaL, 0xa06c0b5dL,
   0xd4326d90L, 0xd0f37027L, 0xddb056feL, 0xd9714b49L,
   0xc7361b4cL, 0xc3f706fbL, 0xceb42022L, 0xca753d95L,
   0xf23a8028L, 0xf6fb9d9fL, 0xfbb8bb46L, 0xff79a6f1L,
   0xe13ef6f4L, 0xe5ffeb43L, 0xe8bccd9aL, 0xec7dd02dL,
   0x34867077L, 0x30476dc0L, 0x3d044b19L, 0x39c556aeL,
   0x278206abL, 0x23431b1cL, 0x2e003dc5L, 0x2ac12072L,
   0x128e9dcfL, 0x164f8078L, 0x1b0ca6a1L, 0x1fcdbb16L,
   0x018aeb13L, 0x054bf6a4L, 0x0808d07dL, 0x0cc9cdcaL,
   0x7897ab07L, 0x7c56b6b0L, 0x71159069L, 0x75d48ddeL,
   0x6b93dddbL, 0x6f52c06cL, 0x6211e6b5L, 0x66d0fb02L,
   0x5e9f46bfL, 0x5a5e5b08L, 0x571d7dd1L, 0x53dc6066L,
   0x4d9b3063L, 0x495a2dd4L, 0x44190b0dL, 0x40d816baL,
   0xaca5c697L, 0xa864db20L, 0xa527fdf9L, 0xa1e6e04eL,
   0xbfa1b04bL, 0xbb60adfcL, 0xb6238b25L, 0xb2e29692L,
   0x8aad2b2fL, 0x8e6c3698L, 0x832f1041L, 0x87ee0df6L,
   0x99a95df3L, 0x9d684044L, 0x902b669dL, 0x94ea7b2aL,
   0xe0b41de7L, 0xe4750050L, 0xe9362689L, 0xedf73b3eL,
   0xf3b06b3bL, 0xf771768cL, 0xfa325055L, 0xfef34de2L,
   0xc6bcf05fL, 0xc27dede8L, 0xcf3ecb31L, 0xcbffd686L,
   0xd5b88683L, 0xd1799b34L, 0xdc3abdedL, 0xd8fba05aL,
   0x690ce0eeL, 0x6dcdfd59L, 0x608edb80L, 0x644fc637L,
   0x7a089632L, 0x7ec98b85L, 0x738aad5cL, 0x774bb0ebL,
   0x4f040d56L, 0x4bc510e1L, 0x46863638L, 0x42472b8fL,
   0x5c007b8aL, 0x58c1663dL, 0x558240e4L, 0x51435d53L,
   0x251d3b9eL, 0x21dc2629L, 0x2c9f00f0L, 0x285e1d47L,
   0x36194d42L, 0x32d850f5L, 0x3f9b762cL, 0x3b5a6b9bL,
   0x0315d626L, 0x07d4cb91L, 0x0a97ed48L, 0x0e56f0ffL,
   0x1011a0faL, 0x14d0bd4dL, 0x19939b94L, 0x1d528623L,
   0xf12f560eL, 0xf5ee4bb9L, 0xf8ad6d60L, 0xfc6c70d7L,
   0xe22b20d2L, 0xe6ea3d65L, 0xeba91bbcL, 0xef68060bL,
   0xd727bbb6L, 0xd3e6a601L, 0xdea580d8L, 0xda649d6fL,
   0xc423cd6aL, 0xc0e2d0ddL, 0xcda1f604L, 0xc960ebb3L,
   0xbd3e8d7eL, 0xb9ff90c9L, 0xb4bcb610L, 0xb07daba7L,
   0xae3afba2L, 0xaafbe615L, 0xa7b8c0ccL, 0xa379dd7bL,
   0x9b3660c6L, 0x9ff77d71L, 0x92b45ba8L, 0x9675461fL,
   0x8832161aL, 0x8cf30badL, 0x81b02d74L, 0x857130c3L,
   0x5d8a9099L, 0x594b8d2eL, 0x5408abf7L, 0x50c9b640L,
   0x4e8ee645L, 0x4a4ffbf2L, 0x470cdd2bL, 0x43cdc09cL,
   0x7b827d21L, 0x7f436096L, 0x7200464fL, 0x76c15bf8L,
   0x68860bfdL, 0x6c47164aL, 0x61043093L, 0x65c52d24L,
   0x119b4be9L, 0x155a565eL, 0x18197087L, 0x1cd86d30L,
   0x029f3d35L, 0x065e2082L, 0x0b1d065bL, 0x0fdc1becL,
   0x3793a651L, 0x3352bbe6L, 0x3e119d3fL, 0x3ad08088L,
   0x2497d08dL, 0x2056cd3aL, 0x2d15ebe3L, 0x29d4f654L,
   0xc5a92679L, 0xc1683bceL, 0xcc2b1d17L, 0xc8ea00a0L,
   0xd6ad50a5L, 0xd26c4d12L, 0xdf2f6bcbL, 0xdbee767cL,
   0xe3a1cbc1L, 0xe760d676L, 0xea23f0afL, 0xeee2ed18L,
   0xf0a5bd1dL, 0xf464a0aaL, 0xf9278673L, 0xfde69bc4L,
   0x89b8fd09L, 0x8d79e0beL, 0x803ac667L, 0x84fbdbd0L,
   0x9abc8bd5L, 0x9e7d9662L, 0x933eb0bbL, 0x97ffad0cL,
   0xafb010b1L, 0xab710d06L, 0xa6322bdfL, 0xa2f33668L,
   0xbcb4666dL, 0xb8757bdaL, 0xb5365d03L, 0xb1f740b4L
};


/*-------------------------------------------------------------*/
/*--- end                                        crctable.c ---*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*--- Table for randomising repetitive blocks               ---*/
/*---                                           randtable.c ---*/
/*-------------------------------------------------------------*/


/*---------------------------------------------*/
Int32 BZ2_rNums[512] = { 
   619, 720, 127, 481, 931, 816, 813, 233, 566, 247, 
   985, 724, 205, 454, 863, 491, 741, 242, 949, 214, 
   733, 859, 335, 708, 621, 574, 73, 654, 730, 472, 
   419, 436, 278, 496, 867, 210, 399, 680, 480, 51, 
   878, 465, 811, 169, 869, 675, 611, 697, 867, 561, 
   862, 687, 507, 283, 482, 129, 807, 591, 733, 623, 
   150, 238, 59, 379, 684, 877, 625, 169, 643, 105, 
   170, 607, 520, 932, 727, 476, 693, 425, 174, 647, 
   73, 122, 335, 530, 442, 853, 695, 249, 445, 515, 
   909, 545, 703, 919, 874, 474, 882, 500, 594, 612, 
   641, 801, 220, 162, 819, 984, 589, 513, 495, 799, 
   161, 604, 958, 533, 221, 400, 386, 867, 600, 782, 
   382, 596, 414, 171, 516, 375, 682, 485, 911, 276, 
   98, 553, 163, 354, 666, 933, 424, 341, 533, 870, 
   227, 730, 475, 186, 263, 647, 537, 686, 600, 224, 
   469, 68, 770, 919, 190, 373, 294, 822, 808, 206, 
   184, 943, 795, 384, 383, 461, 404, 758, 839, 887, 
   715, 67, 618, 276, 204, 918, 873, 777, 604, 560, 
   951, 160, 578, 722, 79, 804, 96, 409, 713, 940, 
   652, 934, 970, 447, 318, 353, 859, 672, 112, 785, 
   645, 863, 803, 350, 139, 93, 354, 99, 820, 908, 
   609, 772, 154, 274, 580, 184, 79, 626, 630, 742, 
   653, 282, 762, 623, 680, 81, 927, 626, 789, 125, 
   411, 521, 938, 300, 821, 78, 343, 175, 128, 250, 
   170, 774, 972, 275, 999, 639, 495, 78, 352, 126, 
   857, 956, 358, 619, 580, 124, 737, 594, 701, 612, 
   669, 112, 134, 694, 363, 992, 809, 743, 168, 974, 
   944, 375, 748, 52, 600, 747, 642, 182, 862, 81, 
   344, 805, 988, 739, 511, 655, 814, 334, 249, 515, 
   897, 955, 664, 981, 649, 113, 974, 459, 893, 228, 
   433, 837, 553, 268, 926, 240, 102, 654, 459, 51, 
   686, 754, 806, 760, 493, 403, 415, 394, 687, 700, 
   946, 670, 656, 610, 738, 392, 760, 799, 887, 653, 
   978, 321, 576, 617, 626, 502, 894, 679, 243, 440, 
   680, 879, 194, 572, 640, 724, 926, 56, 204, 700, 
   707, 151, 457, 449, 797, 195, 791, 558, 945, 679, 
   297, 59, 87, 824, 713, 663, 412, 693, 342, 606, 
   134, 108, 571, 364, 631, 212, 174, 643, 304, 329, 
   343, 97, 430, 751, 497, 314, 983, 374, 822, 928, 
   140, 206, 73, 263, 980, 736, 876, 478, 430, 305, 
   170, 514, 364, 692, 829, 82, 855, 953, 676, 246, 
   369, 970, 294, 750, 807, 827, 150, 790, 288, 923, 
   804, 378, 215, 828, 592, 281, 565, 555, 710, 82, 
   896, 831, 547, 261, 524, 462, 293, 465, 502, 56, 
   661, 821, 976, 991, 658, 869, 905, 758, 745, 193, 
   768, 550, 608, 933, 378, 286, 215, 979, 792, 961, 
   61, 688, 793, 644, 986, 403, 106, 366, 905, 644, 
   372, 567, 466, 434, 645, 210, 389, 550, 919, 135, 
   780, 773, 635, 389, 707, 100, 626, 958, 165, 504, 
   920, 176, 193, 713, 857, 265, 203, 50, 668, 108, 
   645, 990, 626, 197, 510, 357, 358, 850, 858, 364, 
   936, 638
};


/*-------------------------------------------------------------*/
/*--- end                                       randtable.c ---*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*--- Compression machinery (not incl block sorting)        ---*/
/*---                                            compress.c ---*/
/*-------------------------------------------------------------*/


/*---------------------------------------------------*/
/*--- Bit stream I/O                              ---*/
/*---------------------------------------------------*/

/*---------------------------------------------------*/
void BZ2_bsInitWrite ( EState* s )
{
   s->bsLive = 0;
   s->bsBuff = 0;
}


/*---------------------------------------------------*/
static
void bsFinishWrite ( EState* s )
{
   while (s->bsLive > 0) {
      s->zbits[s->numZ] = (UChar)(s->bsBuff >> 24);
      s->numZ++;
      s->bsBuff <<= 8;
      s->bsLive -= 8;
   }
}


/*---------------------------------------------------*/
#define bsNEEDW(nz)                           \
{                                             \
   while (s->bsLive >= 8) {                   \
      s->zbits[s->numZ]                       \
         = (UChar)(s->bsBuff >> 24);          \
      s->numZ++;                              \
      s->bsBuff <<= 8;                        \
      s->bsLive -= 8;                         \
   }                                          \
}


/*---------------------------------------------------*/
static
__inline__
void bsW ( EState* s, Int32 n, UInt32 v )
{
   bsNEEDW ( n );
   s->bsBuff |= (v << (32 - s->bsLive - n));
   s->bsLive += n;
}


/*---------------------------------------------------*/
static
void bsPutUInt32 ( EState* s, UInt32 u )
{
   bsW ( s, 8, (u >> 24) & 0xffL );
   bsW ( s, 8, (u >> 16) & 0xffL );
   bsW ( s, 8, (u >>  8) & 0xffL );
   bsW ( s, 8,  u        & 0xffL );
}


/*---------------------------------------------------*/
static
void bsPutUChar ( EState* s, UChar c )
{
   bsW( s, 8, (UInt32)c );
}


/*---------------------------------------------------*/
/*--- The back end proper                         ---*/
/*---------------------------------------------------*/

/*---------------------------------------------------*/
static
void makeMaps_e ( EState* s )
{
   Int32 i;
   s->nInUse = 0;
   for (i = 0; i < 256; i++)
      if (s->inUse[i]) {
         s->unseqToSeq[i] = s->nInUse;
         s->nInUse++;
      }
}


/*---------------------------------------------------*/
static
void generateMTFValues ( EState* s )
{
   UChar   yy[256];
   Int32   i, j;
   Int32   zPend;
   Int32   wr;
   Int32   EOB;

   /* 
      After sorting (eg, here),
         s->arr1 [ 0 .. s->nblock-1 ] holds sorted order,
         and
         ((UChar*)s->arr2) [ 0 .. s->nblock-1 ] 
         holds the original block data.

      The first thing to do is generate the MTF values,
      and put them in
         ((UInt16*)s->arr1) [ 0 .. s->nblock-1 ].
      Because there are strictly fewer or equal MTF values
      than block values, ptr values in this area are overwritten
      with MTF values only when they are no longer needed.

      The final compressed bitstream is generated into the
      area starting at
         (UChar*) (&((UChar*)s->arr2)[s->nblock])

      These storage aliases are set up in bzCompressInit(),
      except for the last one, which is arranged in 
      compressBlock().
   */
   UInt32* ptr   = s->ptr;
   UChar* block  = s->block;
   UInt16* mtfv  = s->mtfv;

   makeMaps_e ( s );
   EOB = s->nInUse+1;

   for (i = 0; i <= EOB; i++) s->mtfFreq[i] = 0;

   wr = 0;
   zPend = 0;
   for (i = 0; i < s->nInUse; i++) yy[i] = (UChar) i;

   for (i = 0; i < s->nblock; i++) {
      UChar ll_i;
      AssertD ( wr <= i, "generateMTFValues(1)" );
      j = ptr[i]-1; if (j < 0) j += s->nblock;
      ll_i = s->unseqToSeq[block[j]];
      AssertD ( ll_i < s->nInUse, "generateMTFValues(2a)" );

      if (yy[0] == ll_i) { 
         zPend++;
      } else {

         if (zPend > 0) {
            zPend--;
            while (True) {
               if (zPend & 1) {
                  mtfv[wr] = BZ_RUNB; wr++; 
                  s->mtfFreq[BZ_RUNB]++; 
               } else {
                  mtfv[wr] = BZ_RUNA; wr++; 
                  s->mtfFreq[BZ_RUNA]++; 
               }
               if (zPend < 2) break;
               zPend = (zPend - 2) / 2;
            };
            zPend = 0;
         }
         {
            register UChar  rtmp;
            register UChar* ryy_j;
            register UChar  rll_i;
            rtmp  = yy[1];
            yy[1] = yy[0];
            ryy_j = &(yy[1]);
            rll_i = ll_i;
            while ( rll_i != rtmp ) {
               register UChar rtmp2;
               ryy_j++;
               rtmp2  = rtmp;
               rtmp   = *ryy_j;
               *ryy_j = rtmp2;
            };
            yy[0] = rtmp;
            j = ryy_j - &(yy[0]);
            mtfv[wr] = j+1; wr++; s->mtfFreq[j+1]++;
         }

      }
   }

   if (zPend > 0) {
      zPend--;
      while (True) {
         if (zPend & 1) {
            mtfv[wr] = BZ_RUNB; wr++; 
            s->mtfFreq[BZ_RUNB]++; 
         } else {
            mtfv[wr] = BZ_RUNA; wr++; 
            s->mtfFreq[BZ_RUNA]++; 
         }
         if (zPend < 2) break;
         zPend = (zPend - 2) / 2;
      };
      zPend = 0;
   }

   mtfv[wr] = EOB; wr++; s->mtfFreq[EOB]++;

   s->nMTF = wr;
}


/*---------------------------------------------------*/
#define BZ_LESSER_ICOST  0
#define BZ_GREATER_ICOST 15

static
void sendMTFValues ( EState* s )
{
   Int32 v, t, i, j, gs, ge, totc, bt, bc, iter;
   Int32 nSelectors, alphaSize, minLen, maxLen, selCtr;
   Int32 nGroups, nBytes;

   /*--
   UChar  len [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
   is a global since the decoder also needs it.

   Int32  code[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
   Int32  rfreq[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
   are also globals only used in this proc.
   Made global to keep stack frame size small.
   --*/


   UInt16 cost[BZ_N_GROUPS];
   Int32  fave[BZ_N_GROUPS];

   UInt16* mtfv = s->mtfv;

   if (s->verbosity >= 3)
      VPrintf3( "      %d in block, %d after MTF & 1-2 coding, "
                "%d+2 syms in use\n", 
                s->nblock, s->nMTF, s->nInUse );

   alphaSize = s->nInUse+2;
   for (t = 0; t < BZ_N_GROUPS; t++)
      for (v = 0; v < alphaSize; v++)
         s->len[t][v] = BZ_GREATER_ICOST;

   /*--- Decide how many coding tables to use ---*/
   AssertH ( s->nMTF > 0, 3001 );
   if (s->nMTF < 200)  nGroups = 2; else
   if (s->nMTF < 600)  nGroups = 3; else
   if (s->nMTF < 1200) nGroups = 4; else
   if (s->nMTF < 2400) nGroups = 5; else
                       nGroups = 6;

   /*--- Generate an initial set of coding tables ---*/
   { 
      Int32 nPart, remF, tFreq, aFreq;

      nPart = nGroups;
      remF  = s->nMTF;
      gs = 0;
      while (nPart > 0) {
         tFreq = remF / nPart;
         ge = gs-1;
         aFreq = 0;
         while (aFreq < tFreq && ge < alphaSize-1) {
            ge++;
            aFreq += s->mtfFreq[ge];
         }

         if (ge > gs 
             && nPart != nGroups && nPart != 1 
             && ((nGroups-nPart) % 2 == 1)) {
            aFreq -= s->mtfFreq[ge];
            ge--;
         }

         if (s->verbosity >= 3)
            VPrintf5( "      initial group %d, [%d .. %d], "
                      "has %d syms (%4.1f%%)\n",
                      nPart, gs, ge, aFreq, 
                      (100.0 * (float)aFreq) / (float)(s->nMTF) );
 
         for (v = 0; v < alphaSize; v++)
            if (v >= gs && v <= ge) 
               s->len[nPart-1][v] = BZ_LESSER_ICOST; else
               s->len[nPart-1][v] = BZ_GREATER_ICOST;
 
         nPart--;
         gs = ge+1;
         remF -= aFreq;
      }
   }

   /*--- 
      Iterate up to BZ_N_ITERS times to improve the tables.
   ---*/
   for (iter = 0; iter < BZ_N_ITERS; iter++) {

      for (t = 0; t < nGroups; t++) fave[t] = 0;

      for (t = 0; t < nGroups; t++)
         for (v = 0; v < alphaSize; v++)
            s->rfreq[t][v] = 0;

      /*---
        Set up an auxiliary length table which is used to fast-track
	the common case (nGroups == 6). 
      ---*/
      if (nGroups == 6) {
         for (v = 0; v < alphaSize; v++) {
            s->len_pack[v][0] = (s->len[1][v] << 16) | s->len[0][v];
            s->len_pack[v][1] = (s->len[3][v] << 16) | s->len[2][v];
            s->len_pack[v][2] = (s->len[5][v] << 16) | s->len[4][v];
	 }
      }

      nSelectors = 0;
      totc = 0;
      gs = 0;
      while (True) {

         /*--- Set group start & end marks. --*/
         if (gs >= s->nMTF) break;
         ge = gs + BZ_G_SIZE - 1; 
         if (ge >= s->nMTF) ge = s->nMTF-1;

         /*-- 
            Calculate the cost of this group as coded
            by each of the coding tables.
         --*/
         for (t = 0; t < nGroups; t++) cost[t] = 0;

         if (nGroups == 6 && 50 == ge-gs+1) {
            /*--- fast track the common case ---*/
            register UInt32 cost01, cost23, cost45;
            register UInt16 icv;
            cost01 = cost23 = cost45 = 0;

#           define BZ_ITER(nn)                \
               icv = mtfv[gs+(nn)];           \
               cost01 += s->len_pack[icv][0]; \
               cost23 += s->len_pack[icv][1]; \
               cost45 += s->len_pack[icv][2]; \

            BZ_ITER(0);  BZ_ITER(1);  BZ_ITER(2);  BZ_ITER(3);  BZ_ITER(4);
            BZ_ITER(5);  BZ_ITER(6);  BZ_ITER(7);  BZ_ITER(8);  BZ_ITER(9);
            BZ_ITER(10); BZ_ITER(11); BZ_ITER(12); BZ_ITER(13); BZ_ITER(14);
            BZ_ITER(15); BZ_ITER(16); BZ_ITER(17); BZ_ITER(18); BZ_ITER(19);
            BZ_ITER(20); BZ_ITER(21); BZ_ITER(22); BZ_ITER(23); BZ_ITER(24);
            BZ_ITER(25); BZ_ITER(26); BZ_ITER(27); BZ_ITER(28); BZ_ITER(29);
            BZ_ITER(30); BZ_ITER(31); BZ_ITER(32); BZ_ITER(33); BZ_ITER(34);
            BZ_ITER(35); BZ_ITER(36); BZ_ITER(37); BZ_ITER(38); BZ_ITER(39);
            BZ_ITER(40); BZ_ITER(41); BZ_ITER(42); BZ_ITER(43); BZ_ITER(44);
            BZ_ITER(45); BZ_ITER(46); BZ_ITER(47); BZ_ITER(48); BZ_ITER(49);

#           undef BZ_ITER

            cost[0] = cost01 & 0xffff; cost[1] = cost01 >> 16;
            cost[2] = cost23 & 0xffff; cost[3] = cost23 >> 16;
            cost[4] = cost45 & 0xffff; cost[5] = cost45 >> 16;

         } else {
	    /*--- slow version which correctly handles all situations ---*/
            for (i = gs; i <= ge; i++) { 
               UInt16 icv = mtfv[i];
               for (t = 0; t < nGroups; t++) cost[t] += s->len[t][icv];
            }
         }
 
         /*-- 
            Find the coding table which is best for this group,
            and record its identity in the selector table.
         --*/
         bc = 999999999; bt = -1;
         for (t = 0; t < nGroups; t++)
            if (cost[t] < bc) { bc = cost[t]; bt = t; };
         totc += bc;
         fave[bt]++;
         s->selector[nSelectors] = bt;
         nSelectors++;

         /*-- 
            Increment the symbol frequencies for the selected table.
          --*/
         if (nGroups == 6 && 50 == ge-gs+1) {
            /*--- fast track the common case ---*/

#           define BZ_ITUR(nn) s->rfreq[bt][ mtfv[gs+(nn)] ]++

            BZ_ITUR(0);  BZ_ITUR(1);  BZ_ITUR(2);  BZ_ITUR(3);  BZ_ITUR(4);
            BZ_ITUR(5);  BZ_ITUR(6);  BZ_ITUR(7);  BZ_ITUR(8);  BZ_ITUR(9);
            BZ_ITUR(10); BZ_ITUR(11); BZ_ITUR(12); BZ_ITUR(13); BZ_ITUR(14);
            BZ_ITUR(15); BZ_ITUR(16); BZ_ITUR(17); BZ_ITUR(18); BZ_ITUR(19);
            BZ_ITUR(20); BZ_ITUR(21); BZ_ITUR(22); BZ_ITUR(23); BZ_ITUR(24);
            BZ_ITUR(25); BZ_ITUR(26); BZ_ITUR(27); BZ_ITUR(28); BZ_ITUR(29);
            BZ_ITUR(30); BZ_ITUR(31); BZ_ITUR(32); BZ_ITUR(33); BZ_ITUR(34);
            BZ_ITUR(35); BZ_ITUR(36); BZ_ITUR(37); BZ_ITUR(38); BZ_ITUR(39);
            BZ_ITUR(40); BZ_ITUR(41); BZ_ITUR(42); BZ_ITUR(43); BZ_ITUR(44);
            BZ_ITUR(45); BZ_ITUR(46); BZ_ITUR(47); BZ_ITUR(48); BZ_ITUR(49);

#           undef BZ_ITUR

         } else {
	    /*--- slow version which correctly handles all situations ---*/
            for (i = gs; i <= ge; i++)
               s->rfreq[bt][ mtfv[i] ]++;
         }

         gs = ge+1;
      }
      if (s->verbosity >= 3) {
         VPrintf2 ( "      pass %d: size is %d, grp uses are ", 
                   iter+1, totc/8 );
         for (t = 0; t < nGroups; t++)
            VPrintf1 ( "%d ", fave[t] );
         VPrintf0 ( "\n" );
      }

      /*--
        Recompute the tables based on the accumulated frequencies.
      --*/
      for (t = 0; t < nGroups; t++)
         BZ2_hbMakeCodeLengths ( &(s->len[t][0]), &(s->rfreq[t][0]), 
                                 alphaSize, 20 );
   }


   AssertH( nGroups < 8, 3002 );
   AssertH( nSelectors < 32768 &&
            nSelectors <= (2 + (900000 / BZ_G_SIZE)),
            3003 );


   /*--- Compute MTF values for the selectors. ---*/
   {
      UChar pos[BZ_N_GROUPS], ll_i, tmp2, tmp;
      for (i = 0; i < nGroups; i++) pos[i] = i;
      for (i = 0; i < nSelectors; i++) {
         ll_i = s->selector[i];
         j = 0;
         tmp = pos[j];
         while ( ll_i != tmp ) {
            j++;
            tmp2 = tmp;
            tmp = pos[j];
            pos[j] = tmp2;
         };
         pos[0] = tmp;
         s->selectorMtf[i] = j;
      }
   };

   /*--- Assign actual codes for the tables. --*/
   for (t = 0; t < nGroups; t++) {
      minLen = 32;
      maxLen = 0;
      for (i = 0; i < alphaSize; i++) {
         if (s->len[t][i] > maxLen) maxLen = s->len[t][i];
         if (s->len[t][i] < minLen) minLen = s->len[t][i];
      }
      AssertH ( !(maxLen > 20), 3004 );
      AssertH ( !(minLen < 1),  3005 );
      BZ2_hbAssignCodes ( &(s->code[t][0]), &(s->len[t][0]), 
                          minLen, maxLen, alphaSize );
   }

   /*--- Transmit the mapping table. ---*/
   { 
      Bool inUse16[16];
      for (i = 0; i < 16; i++) {
          inUse16[i] = False;
          for (j = 0; j < 16; j++)
             if (s->inUse[i * 16 + j]) inUse16[i] = True;
      }
     
      nBytes = s->numZ;
      for (i = 0; i < 16; i++)
         if (inUse16[i]) bsW(s,1,1); else bsW(s,1,0);

      for (i = 0; i < 16; i++)
         if (inUse16[i])
            for (j = 0; j < 16; j++) {
               if (s->inUse[i * 16 + j]) bsW(s,1,1); else bsW(s,1,0);
            }

      if (s->verbosity >= 3) 
         VPrintf1( "      bytes: mapping %d, ", s->numZ-nBytes );
   }

   /*--- Now the selectors. ---*/
   nBytes = s->numZ;
   bsW ( s, 3, nGroups );
   bsW ( s, 15, nSelectors );
   for (i = 0; i < nSelectors; i++) { 
      for (j = 0; j < s->selectorMtf[i]; j++) bsW(s,1,1);
      bsW(s,1,0);
   }
   if (s->verbosity >= 3)
      VPrintf1( "selectors %d, ", s->numZ-nBytes );

   /*--- Now the coding tables. ---*/
   nBytes = s->numZ;

   for (t = 0; t < nGroups; t++) {
      Int32 curr = s->len[t][0];
      bsW ( s, 5, curr );
      for (i = 0; i < alphaSize; i++) {
         while (curr < s->len[t][i]) { bsW(s,2,2); curr++; /* 10 */ };
         while (curr > s->len[t][i]) { bsW(s,2,3); curr--; /* 11 */ };
         bsW ( s, 1, 0 );
      }
   }

   if (s->verbosity >= 3)
      VPrintf1 ( "code lengths %d, ", s->numZ-nBytes );

   /*--- And finally, the block data proper ---*/
   nBytes = s->numZ;
   selCtr = 0;
   gs = 0;
   while (True) {
      if (gs >= s->nMTF) break;
      ge = gs + BZ_G_SIZE - 1; 
      if (ge >= s->nMTF) ge = s->nMTF-1;
      AssertH ( s->selector[selCtr] < nGroups, 3006 );

      if (nGroups == 6 && 50 == ge-gs+1) {
            /*--- fast track the common case ---*/
            UInt16 mtfv_i;
            UChar* s_len_sel_selCtr 
               = &(s->len[s->selector[selCtr]][0]);
            Int32* s_code_sel_selCtr
               = &(s->code[s->selector[selCtr]][0]);

#           define BZ_ITAH(nn)                      \
               mtfv_i = mtfv[gs+(nn)];              \
               bsW ( s,                             \
                     s_len_sel_selCtr[mtfv_i],      \
                     s_code_sel_selCtr[mtfv_i] )

            BZ_ITAH(0);  BZ_ITAH(1);  BZ_ITAH(2);  BZ_ITAH(3);  BZ_ITAH(4);
            BZ_ITAH(5);  BZ_ITAH(6);  BZ_ITAH(7);  BZ_ITAH(8);  BZ_ITAH(9);
            BZ_ITAH(10); BZ_ITAH(11); BZ_ITAH(12); BZ_ITAH(13); BZ_ITAH(14);
            BZ_ITAH(15); BZ_ITAH(16); BZ_ITAH(17); BZ_ITAH(18); BZ_ITAH(19);
            BZ_ITAH(20); BZ_ITAH(21); BZ_ITAH(22); BZ_ITAH(23); BZ_ITAH(24);
            BZ_ITAH(25); BZ_ITAH(26); BZ_ITAH(27); BZ_ITAH(28); BZ_ITAH(29);
            BZ_ITAH(30); BZ_ITAH(31); BZ_ITAH(32); BZ_ITAH(33); BZ_ITAH(34);
            BZ_ITAH(35); BZ_ITAH(36); BZ_ITAH(37); BZ_ITAH(38); BZ_ITAH(39);
            BZ_ITAH(40); BZ_ITAH(41); BZ_ITAH(42); BZ_ITAH(43); BZ_ITAH(44);
            BZ_ITAH(45); BZ_ITAH(46); BZ_ITAH(47); BZ_ITAH(48); BZ_ITAH(49);

#           undef BZ_ITAH

      } else {
	 /*--- slow version which correctly handles all situations ---*/
         for (i = gs; i <= ge; i++) {
            bsW ( s, 
                  s->len  [s->selector[selCtr]] [mtfv[i]],
                  s->code [s->selector[selCtr]] [mtfv[i]] );
         }
      }


      gs = ge+1;
      selCtr++;
   }
   AssertH( selCtr == nSelectors, 3007 );

   if (s->verbosity >= 3)
      VPrintf1( "codes %d\n", s->numZ-nBytes );
}


/*---------------------------------------------------*/
void BZ2_compressBlock ( EState* s, Bool is_last_block )
{
   if (s->nblock > 0) {

      BZ_FINALISE_CRC ( s->blockCRC );
      s->combinedCRC = (s->combinedCRC << 1) | (s->combinedCRC >> 31);
      s->combinedCRC ^= s->blockCRC;
      if (s->blockNo > 1) s->numZ = 0;

      if (s->verbosity >= 2)
         VPrintf4( "    block %d: crc = 0x%8x, "
                   "combined CRC = 0x%8x, size = %d\n",
                   s->blockNo, s->blockCRC, s->combinedCRC, s->nblock );

      BZ2_blockSort ( s );
   }

   s->zbits = (UChar*) (&((UChar*)s->arr2)[s->nblock]);

   /*-- If this is the first block, create the stream header. --*/
   if (s->blockNo == 1) {
      BZ2_bsInitWrite ( s );
      bsPutUChar ( s, BZ_HDR_B );
      bsPutUChar ( s, BZ_HDR_Z );
      bsPutUChar ( s, BZ_HDR_h );
      bsPutUChar ( s, (UChar)(BZ_HDR_0 + s->blockSize100k) );
   }

   if (s->nblock > 0) {

      bsPutUChar ( s, 0x31 ); bsPutUChar ( s, 0x41 );
      bsPutUChar ( s, 0x59 ); bsPutUChar ( s, 0x26 );
      bsPutUChar ( s, 0x53 ); bsPutUChar ( s, 0x59 );

      /*-- Now the block's CRC, so it is in a known place. --*/
      bsPutUInt32 ( s, s->blockCRC );

      /*-- 
         Now a single bit indicating (non-)randomisation. 
         As of version 0.9.5, we use a better sorting algorithm
         which makes randomisation unnecessary.  So always set
         the randomised bit to 'no'.  Of course, the decoder
         still needs to be able to handle randomised blocks
         so as to maintain backwards compatibility with
         older versions of bzip2.
      --*/
      bsW(s,1,0);

      bsW ( s, 24, s->origPtr );
      generateMTFValues ( s );
      sendMTFValues ( s );
   }


   /*-- If this is the last block, add the stream trailer. --*/
   if (is_last_block) {

      bsPutUChar ( s, 0x17 ); bsPutUChar ( s, 0x72 );
      bsPutUChar ( s, 0x45 ); bsPutUChar ( s, 0x38 );
      bsPutUChar ( s, 0x50 ); bsPutUChar ( s, 0x90 );
      bsPutUInt32 ( s, s->combinedCRC );
      if (s->verbosity >= 2)
         VPrintf1( "    final combined CRC = 0x%x\n   ", s->combinedCRC );
      bsFinishWrite ( s );
   }
}


/*-------------------------------------------------------------*/
/*--- end                                        compress.c ---*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*--- Decompression machinery                               ---*/
/*---                                          decompress.c ---*/
/*-------------------------------------------------------------*/


/*---------------------------------------------------*/
static
void makeMaps_d ( DState* s )
{
   Int32 i;
   s->nInUse = 0;
   for (i = 0; i < 256; i++)
      if (s->inUse[i]) {
         s->seqToUnseq[s->nInUse] = i;
         s->nInUse++;
      }
}


/*---------------------------------------------------*/
#define RETURN(rrr)                               \
   { retVal = rrr; goto save_state_and_return; };

#define GET_BITS(lll,vvv,nnn)                     \
   case lll: s->state = lll;                      \
   while (True) {                                 \
      if (s->bsLive >= nnn) {                     \
         UInt32 v;                                \
         v = (s->bsBuff >>                        \
             (s->bsLive-nnn)) & ((1 << nnn)-1);   \
         s->bsLive -= nnn;                        \
         vvv = v;                                 \
         break;                                   \
      }                                           \
      if (s->strm->avail_in == 0) RETURN(BZ_OK);  \
      s->bsBuff                                   \
         = (s->bsBuff << 8) |                     \
           ((UInt32)                              \
              (*((UChar*)(s->strm->next_in))));   \
      s->bsLive += 8;                             \
      s->strm->next_in++;                         \
      s->strm->avail_in--;                        \
      s->strm->total_in_lo32++;                   \
      if (s->strm->total_in_lo32 == 0)            \
         s->strm->total_in_hi32++;                \
   }

#define GET_UCHAR(lll,uuu)                        \
   GET_BITS(lll,uuu,8)

#define GET_BIT(lll,uuu)                          \
   GET_BITS(lll,uuu,1)

/*---------------------------------------------------*/
#define GET_MTF_VAL(label1,label2,lval)           \
{                                                 \
   if (groupPos == 0) {                           \
      groupNo++;                                  \
      if (groupNo >= nSelectors)                  \
         RETURN(BZ_DATA_ERROR);                   \
      groupPos = BZ_G_SIZE;                       \
      gSel = s->selector[groupNo];                \
      gMinlen = s->minLens[gSel];                 \
      gLimit = &(s->limit[gSel][0]);              \
      gPerm = &(s->perm[gSel][0]);                \
      gBase = &(s->base[gSel][0]);                \
   }                                              \
   groupPos--;                                    \
   zn = gMinlen;                                  \
   GET_BITS(label1, zvec, zn);                    \
   while (1) {                                    \
      if (zn > 20 /* the longest code */)         \
         RETURN(BZ_DATA_ERROR);                   \
      if (zvec <= gLimit[zn]) break;              \
      zn++;                                       \
      GET_BIT(label2, zj);                        \
      zvec = (zvec << 1) | zj;                    \
   };                                             \
   if (zvec - gBase[zn] < 0                       \
       || zvec - gBase[zn] >= BZ_MAX_ALPHA_SIZE)  \
      RETURN(BZ_DATA_ERROR);                      \
   lval = gPerm[zvec - gBase[zn]];                \
}


/*---------------------------------------------------*/
Int32 BZ2_decompress ( DState* s )
{
   UChar      uc;
   Int32      retVal;
   Int32      minLen, maxLen;
   bz_stream* strm = s->strm;

   /* stuff that needs to be saved/restored */
   Int32  i;
   Int32  j;
   Int32  t;
   Int32  alphaSize;
   Int32  nGroups;
   Int32  nSelectors;
   Int32  EOB;
   Int32  groupNo;
   Int32  groupPos;
   Int32  nextSym;
   Int32  nblockMAX;
   Int32  nblock;
   Int32  es;
   Int32  N;
   Int32  curr;
   Int32  zt;
   Int32  zn; 
   Int32  zvec;
   Int32  zj;
   Int32  gSel;
   Int32  gMinlen;
   Int32* gLimit;
   Int32* gBase;
   Int32* gPerm;

   if (s->state == BZ_X_MAGIC_1) {
      /*initialise the save area*/
      s->save_i           = 0;
      s->save_j           = 0;
      s->save_t           = 0;
      s->save_alphaSize   = 0;
      s->save_nGroups     = 0;
      s->save_nSelectors  = 0;
      s->save_EOB         = 0;
      s->save_groupNo     = 0;
      s->save_groupPos    = 0;
      s->save_nextSym     = 0;
      s->save_nblockMAX   = 0;
      s->save_nblock      = 0;
      s->save_es          = 0;
      s->save_N           = 0;
      s->save_curr        = 0;
      s->save_zt          = 0;
      s->save_zn          = 0;
      s->save_zvec        = 0;
      s->save_zj          = 0;
      s->save_gSel        = 0;
      s->save_gMinlen     = 0;
      s->save_gLimit      = NULL;
      s->save_gBase       = NULL;
      s->save_gPerm       = NULL;
   }

   /*restore from the save area*/
   i           = s->save_i;
   j           = s->save_j;
   t           = s->save_t;
   alphaSize   = s->save_alphaSize;
   nGroups     = s->save_nGroups;
   nSelectors  = s->save_nSelectors;
   EOB         = s->save_EOB;
   groupNo     = s->save_groupNo;
   groupPos    = s->save_groupPos;
   nextSym     = s->save_nextSym;
   nblockMAX   = s->save_nblockMAX;
   nblock      = s->save_nblock;
   es          = s->save_es;
   N           = s->save_N;
   curr        = s->save_curr;
   zt          = s->save_zt;
   zn          = s->save_zn; 
   zvec        = s->save_zvec;
   zj          = s->save_zj;
   gSel        = s->save_gSel;
   gMinlen     = s->save_gMinlen;
   gLimit      = s->save_gLimit;
   gBase       = s->save_gBase;
   gPerm       = s->save_gPerm;

   retVal = BZ_OK;

   switch (s->state) {

      GET_UCHAR(BZ_X_MAGIC_1, uc);
      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);

      GET_UCHAR(BZ_X_MAGIC_2, uc);
      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);

      GET_UCHAR(BZ_X_MAGIC_3, uc)
      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);

      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)
      if (s->blockSize100k < (BZ_HDR_0 + 1) || 
          s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);
      s->blockSize100k -= BZ_HDR_0;

      if (s->smallDecompress) {
         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );
         s->ll4  = BZALLOC( 
                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar) 
                   );
         if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);
      } else {
         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );
         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);
      }

      GET_UCHAR(BZ_X_BLKHDR_1, uc);

      if (uc == 0x17) goto endhdr_2;
      if (uc != 0x31) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_BLKHDR_2, uc);
      if (uc != 0x41) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_BLKHDR_3, uc);
      if (uc != 0x59) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_BLKHDR_4, uc);
      if (uc != 0x26) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_BLKHDR_5, uc);
      if (uc != 0x53) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_BLKHDR_6, uc);
      if (uc != 0x59) RETURN(BZ_DATA_ERROR);

      s->currBlockNo++;
      if (s->verbosity >= 2)
         VPrintf1 ( "\n    [%d: huff+mtf ", s->currBlockNo );
 
      s->storedBlockCRC = 0;
      GET_UCHAR(BZ_X_BCRC_1, uc);
      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
      GET_UCHAR(BZ_X_BCRC_2, uc);
      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
      GET_UCHAR(BZ_X_BCRC_3, uc);
      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
      GET_UCHAR(BZ_X_BCRC_4, uc);
      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);

      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);

      s->origPtr = 0;
      GET_UCHAR(BZ_X_ORIGPTR_1, uc);
      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
      GET_UCHAR(BZ_X_ORIGPTR_2, uc);
      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
      GET_UCHAR(BZ_X_ORIGPTR_3, uc);
      s->origPtr = (s->origPtr << 8) | ((Int32)uc);

      if (s->origPtr < 0)
         RETURN(BZ_DATA_ERROR);
      if (s->origPtr > 10 + 100000*s->blockSize100k) 
         RETURN(BZ_DATA_ERROR);

      /*--- Receive the mapping table ---*/
      for (i = 0; i < 16; i++) {
         GET_BIT(BZ_X_MAPPING_1, uc);
         if (uc == 1) 
            s->inUse16[i] = True; else 
            s->inUse16[i] = False;
      }

      for (i = 0; i < 256; i++) s->inUse[i] = False;

      for (i = 0; i < 16; i++)
         if (s->inUse16[i])
            for (j = 0; j < 16; j++) {
               GET_BIT(BZ_X_MAPPING_2, uc);
               if (uc == 1) s->inUse[i * 16 + j] = True;
            }
      makeMaps_d ( s );
      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);
      alphaSize = s->nInUse+2;

      /*--- Now the selectors ---*/
      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);
      if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);
      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);
      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);
      for (i = 0; i < nSelectors; i++) {
         j = 0;
         while (True) {
            GET_BIT(BZ_X_SELECTOR_3, uc);
            if (uc == 0) break;
            j++;
            if (j >= nGroups) RETURN(BZ_DATA_ERROR);
         }
         s->selectorMtf[i] = j;
      }

      /*--- Undo the MTF values for the selectors. ---*/
      {
         UChar pos[BZ_N_GROUPS], tmp, v;
         for (v = 0; v < nGroups; v++) pos[v] = v;
   
         for (i = 0; i < nSelectors; i++) {
            v = s->selectorMtf[i];
            tmp = pos[v];
            while (v > 0) { pos[v] = pos[v-1]; v--; }
            pos[0] = tmp;
            s->selector[i] = tmp;
         }
      }

      /*--- Now the coding tables ---*/
      for (t = 0; t < nGroups; t++) {
         GET_BITS(BZ_X_CODING_1, curr, 5);
         for (i = 0; i < alphaSize; i++) {
            while (True) {
               if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);
               GET_BIT(BZ_X_CODING_2, uc);
               if (uc == 0) break;
               GET_BIT(BZ_X_CODING_3, uc);
               if (uc == 0) curr++; else curr--;
            }
            s->len[t][i] = curr;
         }
      }

      /*--- Create the Huffman decoding tables ---*/
      for (t = 0; t < nGroups; t++) {
         minLen = 32;
         maxLen = 0;
         for (i = 0; i < alphaSize; i++) {
            if (s->len[t][i] > maxLen) maxLen = s->len[t][i];
            if (s->len[t][i] < minLen) minLen = s->len[t][i];
         }
         BZ2_hbCreateDecodeTables ( 
            &(s->limit[t][0]), 
            &(s->base[t][0]), 
            &(s->perm[t][0]), 
            &(s->len[t][0]),
            minLen, maxLen, alphaSize
         );
         s->minLens[t] = minLen;
      }

      /*--- Now the MTF values ---*/

      EOB      = s->nInUse+1;
      nblockMAX = 100000 * s->blockSize100k;
      groupNo  = -1;
      groupPos = 0;

      for (i = 0; i <= 255; i++) s->unzftab[i] = 0;

      /*-- MTF init --*/
      {
         Int32 ii, jj, kk;
         kk = MTFA_SIZE-1;
         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {
            for (jj = MTFL_SIZE-1; jj >= 0; jj--) {
               s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);
               kk--;
            }
            s->mtfbase[ii] = kk + 1;
         }
      }
      /*-- end MTF init --*/

      nblock = 0;
      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);

      while (True) {

         if (nextSym == EOB) break;

         if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {

            es = -1;
            N = 1;
            do {
               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else
               if (nextSym == BZ_RUNB) es = es + (1+1) * N;
               N = N * 2;
               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);
            }
               while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);

            es++;
            uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];
            s->unzftab[uc] += es;

            if (s->smallDecompress)
               while (es > 0) {
                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
                  s->ll16[nblock] = (UInt16)uc;
                  nblock++;
                  es--;
               }
            else
               while (es > 0) {
                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
                  s->tt[nblock] = (UInt32)uc;
                  nblock++;
                  es--;
               };

            continue;

         } else {

            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);

            /*-- uc = MTF ( nextSym-1 ) --*/
            {
               Int32 ii, jj, kk, pp, lno, off;
               UInt32 nn;
               nn = (UInt32)(nextSym - 1);

               if (nn < MTFL_SIZE) {
                  /* avoid general-case expense */
                  pp = s->mtfbase[0];
                  uc = s->mtfa[pp+nn];
                  while (nn > 3) {
                     Int32 z = pp+nn;
                     s->mtfa[(z)  ] = s->mtfa[(z)-1];
                     s->mtfa[(z)-1] = s->mtfa[(z)-2];
                     s->mtfa[(z)-2] = s->mtfa[(z)-3];
                     s->mtfa[(z)-3] = s->mtfa[(z)-4];
                     nn -= 4;
                  }
                  while (nn > 0) { 
                     s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--; 
                  };
                  s->mtfa[pp] = uc;
               } else { 
                  /* general case */
                  lno = nn / MTFL_SIZE;
                  off = nn % MTFL_SIZE;
                  pp = s->mtfbase[lno] + off;
                  uc = s->mtfa[pp];
                  while (pp > s->mtfbase[lno]) { 
                     s->mtfa[pp] = s->mtfa[pp-1]; pp--; 
                  };
                  s->mtfbase[lno]++;
                  while (lno > 0) {
                     s->mtfbase[lno]--;
                     s->mtfa[s->mtfbase[lno]] 
                        = s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];
                     lno--;
                  }
                  s->mtfbase[0]--;
                  s->mtfa[s->mtfbase[0]] = uc;
                  if (s->mtfbase[0] == 0) {
                     kk = MTFA_SIZE-1;
                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {
                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) {
                           s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];
                           kk--;
                        }
                        s->mtfbase[ii] = kk + 1;
                     }
                  }
               }
            }
            /*-- end uc = MTF ( nextSym-1 ) --*/

            s->unzftab[s->seqToUnseq[uc]]++;
            if (s->smallDecompress)
               s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else
               s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);
            nblock++;

            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);
            continue;
         }
      }

      /* Now we know what nblock is, we can do a better sanity
         check on s->origPtr.
      */
      if (s->origPtr < 0 || s->origPtr >= nblock)
         RETURN(BZ_DATA_ERROR);

      s->state_out_len = 0;
      s->state_out_ch  = 0;
      BZ_INITIALISE_CRC ( s->calculatedBlockCRC );
      s->state = BZ_X_OUTPUT;
      if (s->verbosity >= 2) VPrintf0 ( "rt+rld" );

      /*-- Set up cftab to facilitate generation of T^(-1) --*/
      s->cftab[0] = 0;
      for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];
      for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];

      if (s->smallDecompress) {

         /*-- Make a copy of cftab, used in generation of T --*/
         for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];

         /*-- compute the T vector --*/
         for (i = 0; i < nblock; i++) {
            uc = (UChar)(s->ll16[i]);
            SET_LL(i, s->cftabCopy[uc]);
            s->cftabCopy[uc]++;
         }

         /*-- Compute T^(-1) by pointer reversal on T --*/
         i = s->origPtr;
         j = GET_LL(i);
         do {
            Int32 tmp = GET_LL(j);
            SET_LL(j, i);
            i = j;
            j = tmp;
         }
            while (i != s->origPtr);

         s->tPos = s->origPtr;
         s->nblock_used = 0;
         if (s->blockRandomised) {
            BZ_RAND_INIT_MASK;
            BZ_GET_SMALL(s->k0); s->nblock_used++;
            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; 
         } else {
            BZ_GET_SMALL(s->k0); s->nblock_used++;
         }

      } else {

         /*-- compute the T^(-1) vector --*/
         for (i = 0; i < nblock; i++) {
            uc = (UChar)(s->tt[i] & 0xff);
            s->tt[s->cftab[uc]] |= (i << 8);
            s->cftab[uc]++;
         }

         s->tPos = s->tt[s->origPtr] >> 8;
         s->nblock_used = 0;
         if (s->blockRandomised) {
            BZ_RAND_INIT_MASK;
            BZ_GET_FAST(s->k0); s->nblock_used++;
            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; 
         } else {
            BZ_GET_FAST(s->k0); s->nblock_used++;
         }

      }

      RETURN(BZ_OK);



    endhdr_2:

      GET_UCHAR(BZ_X_ENDHDR_2, uc);
      if (uc != 0x72) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_ENDHDR_3, uc);
      if (uc != 0x45) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_ENDHDR_4, uc);
      if (uc != 0x38) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_ENDHDR_5, uc);
      if (uc != 0x50) RETURN(BZ_DATA_ERROR);
      GET_UCHAR(BZ_X_ENDHDR_6, uc);
      if (uc != 0x90) RETURN(BZ_DATA_ERROR);

      s->storedCombinedCRC = 0;
      GET_UCHAR(BZ_X_CCRC_1, uc);
      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
      GET_UCHAR(BZ_X_CCRC_2, uc);
      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
      GET_UCHAR(BZ_X_CCRC_3, uc);
      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
      GET_UCHAR(BZ_X_CCRC_4, uc);
      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);

      s->state = BZ_X_IDLE;
      RETURN(BZ_STREAM_END);

      default: AssertH ( False, 4001 );
   }

   AssertH ( False, 4002 );

   save_state_and_return:

   s->save_i           = i;
   s->save_j           = j;
   s->save_t           = t;
   s->save_alphaSize   = alphaSize;
   s->save_nGroups     = nGroups;
   s->save_nSelectors  = nSelectors;
   s->save_EOB         = EOB;
   s->save_groupNo     = groupNo;
   s->save_groupPos    = groupPos;
   s->save_nextSym     = nextSym;
   s->save_nblockMAX   = nblockMAX;
   s->save_nblock      = nblock;
   s->save_es          = es;
   s->save_N           = N;
   s->save_curr        = curr;
   s->save_zt          = zt;
   s->save_zn          = zn;
   s->save_zvec        = zvec;
   s->save_zj          = zj;
   s->save_gSel        = gSel;
   s->save_gMinlen     = gMinlen;
   s->save_gLimit      = gLimit;
   s->save_gBase       = gBase;
   s->save_gPerm       = gPerm;

   return retVal;   
}


/*-------------------------------------------------------------*/
/*--- end                                      decompress.c ---*/
/*-------------------------------------------------------------*/

/*-------------------------------------------------------------*/
/*--- Library top-level functions.                          ---*/
/*---                                               bzlib.c ---*/
/*-------------------------------------------------------------*/

/*---------------------------------------------------*/
/*--- Compression stuff                           ---*/
/*---------------------------------------------------*/


/*---------------------------------------------------*/
#ifndef BZ_NO_STDIO
void BZ2_bz__AssertH__fail ( int errcode )
{
   fprintf(stderr, 
      "\n\nbzip2/libbzip2: internal error number %d.\n"
      "This is a bug in bzip2/libbzip2, %s.\n"
      "Please report it to me at: jseward@acm.org.  If this happened\n"
      "when you were using some program which uses libbzip2 as a\n"
      "component, you should also report this bug to the author(s)\n"
      "of that program.  Please make an effort to report this bug;\n"
      "timely and accurate bug reports eventually lead to higher\n"
      "quality software.  Thanks.  Julian Seward, 30 December 2001.\n\n",
      errcode,
      BZ2_bzlibVersion()
   );

   if (errcode == 1007) {
   fprintf(stderr,
      "\n*** A special note about internal error number 1007 ***\n"
      "\n"
      "Experience suggests that a common cause of i.e. 1007\n"
      "is unreliable memory or other hardware.  The 1007 assertion\n"
      "just happens to cross-check the results of huge numbers of\n"
      "memory reads/writes, and so acts (unintendedly) as a stress\n"
      "test of your memory system.\n"
      "\n"
      "I suggest the following: try compressing the file again,\n"
      "possibly monitoring progress in detail with the -vv flag.\n"
      "\n"
      "* If the error cannot be reproduced, and/or happens at different\n"
      "  points in compression, you may have a flaky memory system.\n"
      "  Try a memory-test program.  I have used Memtest86\n"
      "  (www.memtest86.com).  At the time of writing it is free (GPLd).\n"
      "  Memtest86 tests memory much more thorougly than your BIOSs\n"
      "  power-on test, and may find failures that the BIOS doesn't.\n"
      "\n"
      "* If the error can be repeatably reproduced, this is a bug in\n"
      "  bzip2, and I would very much like to hear about it.  Please\n"
      "  let me know, and, ideally, save a copy of the file causing the\n"
      "  problem -- without which I will be unable to investigate it.\n"
      "\n"
   );
   }

   exit(3);
}
#endif


/*---------------------------------------------------*/
static
int bz_config_ok ( void )
{
   if (sizeof(int)   != 4) return 0;
   if (sizeof(short) != 2) return 0;
   if (sizeof(char)  != 1) return 0;
   return 1;
}


/*---------------------------------------------------*/
static
void* default_bzalloc ( void* opaque, Int32 items, Int32 size )
{
   void* v = malloc ( items * size );
   return v;
}

static
void default_bzfree ( void* opaque, void* addr )
{
   if (addr != NULL) free ( addr );
}


/*---------------------------------------------------*/
static
void prepare_new_block ( EState* s )
{
   Int32 i;
   s->nblock = 0;
   s->numZ = 0;
   s->state_out_pos = 0;
   BZ_INITIALISE_CRC ( s->blockCRC );
   for (i = 0; i < 256; i++) s->inUse[i] = False;
   s->blockNo++;
}


/*---------------------------------------------------*/
static
void init_RL ( EState* s )
{
   s->state_in_ch  = 256;
   s->state_in_len = 0;
}


static
Bool isempty_RL ( EState* s )
{
   if (s->state_in_ch < 256 && s->state_in_len > 0)
      return False; else
      return True;
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzCompressInit) 
                    ( bz_stream* strm, 
                     int        blockSize100k,
                     int        verbosity,
                     int        workFactor )
{
   Int32   n;
   EState* s;

   if (!bz_config_ok()) return BZ_CONFIG_ERROR;

   if (strm == NULL || 
       blockSize100k < 1 || blockSize100k > 9 ||
       workFactor < 0 || workFactor > 250)
     return BZ_PARAM_ERROR;

   if (workFactor == 0) workFactor = 30;
   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;
   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;

   s = BZALLOC( sizeof(EState) );
   if (s == NULL) return BZ_MEM_ERROR;
   s->strm = strm;

   s->arr1 = NULL;
   s->arr2 = NULL;
   s->ftab = NULL;

   n       = 100000 * blockSize100k;
   s->arr1 = BZALLOC( n                  * sizeof(UInt32) );
   s->arr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );
   s->ftab = BZALLOC( 65537              * sizeof(UInt32) );

   if (s->arr1 == NULL || s->arr2 == NULL || s->ftab == NULL) {
      if (s->arr1 != NULL) BZFREE(s->arr1);
      if (s->arr2 != NULL) BZFREE(s->arr2);
      if (s->ftab != NULL) BZFREE(s->ftab);
      if (s       != NULL) BZFREE(s);
      return BZ_MEM_ERROR;
   }

   s->blockNo           = 0;
   s->state             = BZ_S_INPUT;
   s->mode              = BZ_M_RUNNING;
   s->combinedCRC       = 0;
   s->blockSize100k     = blockSize100k;
   s->nblockMAX         = 100000 * blockSize100k - 19;
   s->verbosity         = verbosity;
   s->workFactor        = workFactor;

   s->block             = (UChar*)s->arr2;
   s->mtfv              = (UInt16*)s->arr1;
   s->zbits             = NULL;
   s->ptr               = (UInt32*)s->arr1;

   strm->state          = s;
   strm->total_in_lo32  = 0;
   strm->total_in_hi32  = 0;
   strm->total_out_lo32 = 0;
   strm->total_out_hi32 = 0;
   init_RL ( s );
   prepare_new_block ( s );
   return BZ_OK;
}


/*---------------------------------------------------*/
static
void add_pair_to_block ( EState* s )
{
   Int32 i;
   UChar ch = (UChar)(s->state_in_ch);
   for (i = 0; i < s->state_in_len; i++) {
      BZ_UPDATE_CRC( s->blockCRC, ch );
   }
   s->inUse[s->state_in_ch] = True;
   switch (s->state_in_len) {
      case 1:
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         break;
      case 2:
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         break;
      case 3:
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         break;
      default:
         s->inUse[s->state_in_len-4] = True;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = (UChar)ch; s->nblock++;
         s->block[s->nblock] = ((UChar)(s->state_in_len-4));
         s->nblock++;
         break;
   }
}


/*---------------------------------------------------*/
static
void flush_RL ( EState* s )
{
   if (s->state_in_ch < 256) add_pair_to_block ( s );
   init_RL ( s );
}


/*---------------------------------------------------*/
#define ADD_CHAR_TO_BLOCK(zs,zchh0)               \
{                                                 \
   UInt32 zchh = (UInt32)(zchh0);                 \
   /*-- fast track the common case --*/           \
   if (zchh != zs->state_in_ch &&                 \
       zs->state_in_len == 1) {                   \
      UChar ch = (UChar)(zs->state_in_ch);        \
      BZ_UPDATE_CRC( zs->blockCRC, ch );          \
      zs->inUse[zs->state_in_ch] = True;          \
      zs->block[zs->nblock] = (UChar)ch;          \
      zs->nblock++;                               \
      zs->state_in_ch = zchh;                     \
   }                                              \
   else                                           \
   /*-- general, uncommon cases --*/              \
   if (zchh != zs->state_in_ch ||                 \
      zs->state_in_len == 255) {                  \
      if (zs->state_in_ch < 256)                  \
         add_pair_to_block ( zs );                \
      zs->state_in_ch = zchh;                     \
      zs->state_in_len = 1;                       \
   } else {                                       \
      zs->state_in_len++;                         \
   }                                              \
}


/*---------------------------------------------------*/
static
Bool copy_input_until_stop ( EState* s )
{
   Bool progress_in = False;

   if (s->mode == BZ_M_RUNNING) {

      /*-- fast track the common case --*/
      while (True) {
         /*-- block full? --*/
         if (s->nblock >= s->nblockMAX) break;
         /*-- no input? --*/
         if (s->strm->avail_in == 0) break;
         progress_in = True;
         ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) ); 
         s->strm->next_in++;
         s->strm->avail_in--;
         s->strm->total_in_lo32++;
         if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;
      }

   } else {

      /*-- general, uncommon case --*/
      while (True) {
         /*-- block full? --*/
         if (s->nblock >= s->nblockMAX) break;
         /*-- no input? --*/
         if (s->strm->avail_in == 0) break;
         /*-- flush/finish end? --*/
         if (s->avail_in_expect == 0) break;
         progress_in = True;
         ADD_CHAR_TO_BLOCK ( s, (UInt32)(*((UChar*)(s->strm->next_in))) ); 
         s->strm->next_in++;
         s->strm->avail_in--;
         s->strm->total_in_lo32++;
         if (s->strm->total_in_lo32 == 0) s->strm->total_in_hi32++;
         s->avail_in_expect--;
      }
   }
   return progress_in;
}


/*---------------------------------------------------*/
static
Bool copy_output_until_stop ( EState* s )
{
   Bool progress_out = False;

   while (True) {

      /*-- no output space? --*/
      if (s->strm->avail_out == 0) break;

      /*-- block done? --*/
      if (s->state_out_pos >= s->numZ) break;

      progress_out = True;
      *(s->strm->next_out) = s->zbits[s->state_out_pos];
      s->state_out_pos++;
      s->strm->avail_out--;
      s->strm->next_out++;
      s->strm->total_out_lo32++;
      if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
   }

   return progress_out;
}


/*---------------------------------------------------*/
static
Bool handle_compress ( bz_stream* strm )
{
   Bool progress_in  = False;
   Bool progress_out = False;
   EState* s = strm->state;
   
   while (True) {

      if (s->state == BZ_S_OUTPUT) {
         progress_out |= copy_output_until_stop ( s );
         if (s->state_out_pos < s->numZ) break;
         if (s->mode == BZ_M_FINISHING && 
             s->avail_in_expect == 0 &&
             isempty_RL(s)) break;
         prepare_new_block ( s );
         s->state = BZ_S_INPUT;
         if (s->mode == BZ_M_FLUSHING && 
             s->avail_in_expect == 0 &&
             isempty_RL(s)) break;
      }

      if (s->state == BZ_S_INPUT) {
         progress_in |= copy_input_until_stop ( s );
         if (s->mode != BZ_M_RUNNING && s->avail_in_expect == 0) {
            flush_RL ( s );
            BZ2_compressBlock ( s, (Bool)(s->mode == BZ_M_FINISHING) );
            s->state = BZ_S_OUTPUT;
         }
         else
         if (s->nblock >= s->nblockMAX) {
            BZ2_compressBlock ( s, False );
            s->state = BZ_S_OUTPUT;
         }
         else
         if (s->strm->avail_in == 0) {
            break;
         }
      }

   }

   return progress_in || progress_out;
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzCompress) ( bz_stream *strm, int action )
{
   Bool progress;
   EState* s;
   if (strm == NULL) return BZ_PARAM_ERROR;
   s = strm->state;
   if (s == NULL) return BZ_PARAM_ERROR;
   if (s->strm != strm) return BZ_PARAM_ERROR;

   preswitch:
   switch (s->mode) {

      case BZ_M_IDLE:
         return BZ_SEQUENCE_ERROR;

      case BZ_M_RUNNING:
         if (action == BZ_RUN) {
            progress = handle_compress ( strm );
            return progress ? BZ_RUN_OK : BZ_PARAM_ERROR;
         } 
         else
	 if (action == BZ_FLUSH) {
            s->avail_in_expect = strm->avail_in;
            s->mode = BZ_M_FLUSHING;
            goto preswitch;
         }
         else
         if (action == BZ_FINISH) {
            s->avail_in_expect = strm->avail_in;
            s->mode = BZ_M_FINISHING;
            goto preswitch;
         }
         else 
            return BZ_PARAM_ERROR;

      case BZ_M_FLUSHING:
         if (action != BZ_FLUSH) return BZ_SEQUENCE_ERROR;
         if (s->avail_in_expect != s->strm->avail_in) 
            return BZ_SEQUENCE_ERROR;
         progress = handle_compress ( strm );
         if (s->avail_in_expect > 0 || !isempty_RL(s) ||
             s->state_out_pos < s->numZ) return BZ_FLUSH_OK;
         s->mode = BZ_M_RUNNING;
         return BZ_RUN_OK;

      case BZ_M_FINISHING:
         if (action != BZ_FINISH) return BZ_SEQUENCE_ERROR;
         if (s->avail_in_expect != s->strm->avail_in) 
            return BZ_SEQUENCE_ERROR;
         progress = handle_compress ( strm );
         if (!progress) return BZ_SEQUENCE_ERROR;
         if (s->avail_in_expect > 0 || !isempty_RL(s) ||
             s->state_out_pos < s->numZ) return BZ_FINISH_OK;
         s->mode = BZ_M_IDLE;
         return BZ_STREAM_END;
   }
   return BZ_OK; /*--not reached--*/
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzCompressEnd)  ( bz_stream *strm )
{
   EState* s;
   if (strm == NULL) return BZ_PARAM_ERROR;
   s = strm->state;
   if (s == NULL) return BZ_PARAM_ERROR;
   if (s->strm != strm) return BZ_PARAM_ERROR;

   if (s->arr1 != NULL) BZFREE(s->arr1);
   if (s->arr2 != NULL) BZFREE(s->arr2);
   if (s->ftab != NULL) BZFREE(s->ftab);
   BZFREE(strm->state);

   strm->state = NULL;   

   return BZ_OK;
}


/*---------------------------------------------------*/
/*--- Decompression stuff                         ---*/
/*---------------------------------------------------*/

/*---------------------------------------------------*/
int BZ_API(BZ2_bzDecompressInit) 
                     ( bz_stream* strm, 
                       int        verbosity,
                       int        small )
{
   DState* s;

   if (!bz_config_ok()) return BZ_CONFIG_ERROR;

   if (strm == NULL) return BZ_PARAM_ERROR;
   if (small != 0 && small != 1) return BZ_PARAM_ERROR;
   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;

   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;
   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;

   s = BZALLOC( sizeof(DState) );
   if (s == NULL) return BZ_MEM_ERROR;
   s->strm                  = strm;
   strm->state              = s;
   s->state                 = BZ_X_MAGIC_1;
   s->bsLive                = 0;
   s->bsBuff                = 0;
   s->calculatedCombinedCRC = 0;
   strm->total_in_lo32      = 0;
   strm->total_in_hi32      = 0;
   strm->total_out_lo32     = 0;
   strm->total_out_hi32     = 0;
   s->smallDecompress       = (Bool)small;
   s->ll4                   = NULL;
   s->ll16                  = NULL;
   s->tt                    = NULL;
   s->currBlockNo           = 0;
   s->verbosity             = verbosity;

   return BZ_OK;
}


/*---------------------------------------------------*/
static
void unRLE_obuf_to_output_FAST ( DState* s )
{
   UChar k1;

   if (s->blockRandomised) {

      while (True) {
         /* try to finish existing run */
         while (True) {
            if (s->strm->avail_out == 0) return;
            if (s->state_out_len == 0) break;
            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
            s->state_out_len--;
            s->strm->next_out++;
            s->strm->avail_out--;
            s->strm->total_out_lo32++;
            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
         }
   
         /* can a new run be started? */
         if (s->nblock_used == s->save_nblock+1) return;
               
   
         s->state_out_len = 1;
         s->state_out_ch = s->k0;
         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         s->state_out_len = 2;
         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         s->state_out_len = 3;
         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         s->state_out_len = ((Int32)k1) + 4;
         BZ_GET_FAST(s->k0); BZ_RAND_UPD_MASK; 
         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;
      }

   } else {

      /* restore */
      UInt32        c_calculatedBlockCRC = s->calculatedBlockCRC;
      UChar         c_state_out_ch       = s->state_out_ch;
      Int32         c_state_out_len      = s->state_out_len;
      Int32         c_nblock_used        = s->nblock_used;
      Int32         c_k0                 = s->k0;
      UInt32*       c_tt                 = s->tt;
      UInt32        c_tPos               = s->tPos;
      char*         cs_next_out          = s->strm->next_out;
      unsigned int  cs_avail_out         = s->strm->avail_out;
      /* end restore */

      UInt32       avail_out_INIT = cs_avail_out;
      Int32        s_save_nblockPP = s->save_nblock+1;
      unsigned int total_out_lo32_old;

      while (True) {

         /* try to finish existing run */
         if (c_state_out_len > 0) {
            while (True) {
               if (cs_avail_out == 0) goto return_notr;
               if (c_state_out_len == 1) break;
               *( (UChar*)(cs_next_out) ) = c_state_out_ch;
               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );
               c_state_out_len--;
               cs_next_out++;
               cs_avail_out--;
            }
            s_state_out_len_eq_one:
            {
               if (cs_avail_out == 0) { 
                  c_state_out_len = 1; goto return_notr;
               };
               *( (UChar*)(cs_next_out) ) = c_state_out_ch;
               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );
               cs_next_out++;
               cs_avail_out--;
            }
         }   
         /* can a new run be started? */
         if (c_nblock_used == s_save_nblockPP) {
            c_state_out_len = 0; goto return_notr;
         };   
         c_state_out_ch = c_k0;
         BZ_GET_FAST_C(k1); c_nblock_used++;
         if (k1 != c_k0) { 
            c_k0 = k1; goto s_state_out_len_eq_one; 
         };
         if (c_nblock_used == s_save_nblockPP) 
            goto s_state_out_len_eq_one;
   
         c_state_out_len = 2;
         BZ_GET_FAST_C(k1); c_nblock_used++;
         if (c_nblock_used == s_save_nblockPP) continue;
         if (k1 != c_k0) { c_k0 = k1; continue; };
   
         c_state_out_len = 3;
         BZ_GET_FAST_C(k1); c_nblock_used++;
         if (c_nblock_used == s_save_nblockPP) continue;
         if (k1 != c_k0) { c_k0 = k1; continue; };
   
         BZ_GET_FAST_C(k1); c_nblock_used++;
         c_state_out_len = ((Int32)k1) + 4;
         BZ_GET_FAST_C(c_k0); c_nblock_used++;
      }

      return_notr:
      total_out_lo32_old = s->strm->total_out_lo32;
      s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);
      if (s->strm->total_out_lo32 < total_out_lo32_old)
         s->strm->total_out_hi32++;

      /* save */
      s->calculatedBlockCRC = c_calculatedBlockCRC;
      s->state_out_ch       = c_state_out_ch;
      s->state_out_len      = c_state_out_len;
      s->nblock_used        = c_nblock_used;
      s->k0                 = c_k0;
      s->tt                 = c_tt;
      s->tPos               = c_tPos;
      s->strm->next_out     = cs_next_out;
      s->strm->avail_out    = cs_avail_out;
      /* end save */
   }
}



/*---------------------------------------------------*/
Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )
{
   Int32 nb, na, mid;
   nb = 0;
   na = 256;
   do {
      mid = (nb + na) >> 1;
      if (indx >= cftab[mid]) nb = mid; else na = mid;
   }
   while (na - nb != 1);
   return nb;
}


/*---------------------------------------------------*/
static
void unRLE_obuf_to_output_SMALL ( DState* s )
{
   UChar k1;

   if (s->blockRandomised) {

      while (True) {
         /* try to finish existing run */
         while (True) {
            if (s->strm->avail_out == 0) return;
            if (s->state_out_len == 0) break;
            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
            s->state_out_len--;
            s->strm->next_out++;
            s->strm->avail_out--;
            s->strm->total_out_lo32++;
            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
         }
   
         /* can a new run be started? */
         if (s->nblock_used == s->save_nblock+1) return;
               
   
         s->state_out_len = 1;
         s->state_out_ch = s->k0;
         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         s->state_out_len = 2;
         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         s->state_out_len = 3;
         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
         k1 ^= BZ_RAND_MASK; s->nblock_used++;
         s->state_out_len = ((Int32)k1) + 4;
         BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK; 
         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;
      }

   } else {

      while (True) {
         /* try to finish existing run */
         while (True) {
            if (s->strm->avail_out == 0) return;
            if (s->state_out_len == 0) break;
            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
            s->state_out_len--;
            s->strm->next_out++;
            s->strm->avail_out--;
            s->strm->total_out_lo32++;
            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
         }
   
         /* can a new run be started? */
         if (s->nblock_used == s->save_nblock+1) return;
   
         s->state_out_len = 1;
         s->state_out_ch = s->k0;
         BZ_GET_SMALL(k1); s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         s->state_out_len = 2;
         BZ_GET_SMALL(k1); s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         s->state_out_len = 3;
         BZ_GET_SMALL(k1); s->nblock_used++;
         if (s->nblock_used == s->save_nblock+1) continue;
         if (k1 != s->k0) { s->k0 = k1; continue; };
   
         BZ_GET_SMALL(k1); s->nblock_used++;
         s->state_out_len = ((Int32)k1) + 4;
         BZ_GET_SMALL(s->k0); s->nblock_used++;
      }

   }
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzDecompress) ( bz_stream *strm )
{
   DState* s;
   if (strm == NULL) return BZ_PARAM_ERROR;
   s = strm->state;
   if (s == NULL) return BZ_PARAM_ERROR;
   if (s->strm != strm) return BZ_PARAM_ERROR;

   while (True) {
      if (s->state == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;
      if (s->state == BZ_X_OUTPUT) {
         if (s->smallDecompress)
            unRLE_obuf_to_output_SMALL ( s ); else
            unRLE_obuf_to_output_FAST  ( s );
         if (s->nblock_used == s->save_nblock+1 && s->state_out_len == 0) {
            BZ_FINALISE_CRC ( s->calculatedBlockCRC );
            if (s->verbosity >= 3) 
               VPrintf2 ( " {0x%x, 0x%x}", s->storedBlockCRC, 
                          s->calculatedBlockCRC );
            if (s->verbosity >= 2) VPrintf0 ( "]" );
            if (s->calculatedBlockCRC != s->storedBlockCRC)
               return BZ_DATA_ERROR;
            s->calculatedCombinedCRC 
               = (s->calculatedCombinedCRC << 1) | 
                    (s->calculatedCombinedCRC >> 31);
            s->calculatedCombinedCRC ^= s->calculatedBlockCRC;
            s->state = BZ_X_BLKHDR_1;
         } else {
            return BZ_OK;
         }
      }
      if (s->state >= BZ_X_MAGIC_1) {
         Int32 r = BZ2_decompress ( s );
         if (r == BZ_STREAM_END) {
            if (s->verbosity >= 3)
               VPrintf2 ( "\n    combined CRCs: stored = 0x%x, computed = 0x%x", 
                          s->storedCombinedCRC, s->calculatedCombinedCRC );
            if (s->calculatedCombinedCRC != s->storedCombinedCRC)
               return BZ_DATA_ERROR;
            return r;
         }
         if (s->state != BZ_X_OUTPUT) return r;
      }
   }

   AssertH ( 0, 6001 );

   return 0;  /*NOTREACHED*/
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )
{
   DState* s;
   if (strm == NULL) return BZ_PARAM_ERROR;
   s = strm->state;
   if (s == NULL) return BZ_PARAM_ERROR;
   if (s->strm != strm) return BZ_PARAM_ERROR;

   if (s->tt   != NULL) BZFREE(s->tt);
   if (s->ll16 != NULL) BZFREE(s->ll16);
   if (s->ll4  != NULL) BZFREE(s->ll4);

   BZFREE(strm->state);
   strm->state = NULL;

   return BZ_OK;
}


#ifndef BZ_NO_STDIO
/*---------------------------------------------------*/
/*--- File I/O stuff                              ---*/
/*---------------------------------------------------*/

#define BZ_SETERR(eee)                    \
{                                         \
   if (bzerror != NULL) *bzerror = eee;   \
   if (bzf != NULL) bzf->lastErr = eee;   \
}

typedef 
   struct {
      FILE*     handle;
      Char      buf[BZ_MAX_UNUSED];
      Int32     bufN;
      Bool      writing;
      bz_stream strm;
      Int32     lastErr;
      Bool      initialisedOk;
   }
   bzFile;


/*---------------------------------------------*/



/*---------------------------------------------------*/
BZFILE* BZ_API(BZ2_bzWriteOpen) 
                    ( int*  bzerror,      
                      FILE* f, 
                      int   blockSize100k, 
                      int   verbosity,
                      int   workFactor )
{
   Int32   ret;
   bzFile* bzf = NULL;

   BZ_SETERR(BZ_OK);

   if (f == NULL ||
       (blockSize100k < 1 || blockSize100k > 9) ||
       (workFactor < 0 || workFactor > 250) ||
       (verbosity < 0 || verbosity > 4))
      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };

   if (ferror(f))
      { BZ_SETERR(BZ_IO_ERROR); return NULL; };

   bzf = malloc ( sizeof(bzFile) );
   if (bzf == NULL)
      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };

   BZ_SETERR(BZ_OK);
   bzf->initialisedOk = False;
   bzf->bufN          = 0;
   bzf->handle        = f;
   bzf->writing       = True;
   bzf->strm.bzalloc  = NULL;
   bzf->strm.bzfree   = NULL;
   bzf->strm.opaque   = NULL;

   if (workFactor == 0) workFactor = 30;
   ret = BZ2_bzCompressInit ( &(bzf->strm), blockSize100k, 
                              verbosity, workFactor );
   if (ret != BZ_OK)
      { BZ_SETERR(ret); free(bzf); return NULL; };

   bzf->strm.avail_in = 0;
   bzf->initialisedOk = True;
   return bzf;   
}



/*---------------------------------------------------*/
void BZ_API(BZ2_bzWrite)
             ( int*    bzerror, 
               BZFILE* b, 
               void*   buf, 
               int     len )
{
   Int32 n, n2, ret;
   bzFile* bzf = (bzFile*)b;

   BZ_SETERR(BZ_OK);
   if (bzf == NULL || buf == NULL || len < 0)
      { BZ_SETERR(BZ_PARAM_ERROR); return; };
   if (!(bzf->writing))
      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
   if (ferror(bzf->handle))
      { BZ_SETERR(BZ_IO_ERROR); return; };

   if (len == 0)
      { BZ_SETERR(BZ_OK); return; };

   bzf->strm.avail_in = len;
   bzf->strm.next_in  = buf;

   while (True) {
      bzf->strm.avail_out = BZ_MAX_UNUSED;
      bzf->strm.next_out = bzf->buf;
      ret = BZ2_bzCompress ( &(bzf->strm), BZ_RUN );
      if (ret != BZ_RUN_OK)
         { BZ_SETERR(ret); return; };

      if (bzf->strm.avail_out < BZ_MAX_UNUSED) {
         n = BZ_MAX_UNUSED - bzf->strm.avail_out;
         n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar), 
                       n, bzf->handle );
         if (n != n2 || ferror(bzf->handle))
            { BZ_SETERR(BZ_IO_ERROR); return; };
      }

      if (bzf->strm.avail_in == 0)
         { BZ_SETERR(BZ_OK); return; };
   }
}


/*---------------------------------------------------*/
void BZ_API(BZ2_bzWriteClose)
                  ( int*          bzerror, 
                    BZFILE*       b, 
                    int           abandon,
                    unsigned int* nbytes_in,
                    unsigned int* nbytes_out )
{
   BZ2_bzWriteClose64 ( bzerror, b, abandon, 
                        nbytes_in, NULL, nbytes_out, NULL );
}


void BZ_API(BZ2_bzWriteClose64)
                  ( int*          bzerror, 
                    BZFILE*       b, 
                    int           abandon,
                    unsigned int* nbytes_in_lo32,
                    unsigned int* nbytes_in_hi32,
                    unsigned int* nbytes_out_lo32,
                    unsigned int* nbytes_out_hi32 )
{
   Int32   n, n2, ret;
   bzFile* bzf = (bzFile*)b;

   if (bzf == NULL)
      { BZ_SETERR(BZ_OK); return; };
   if (!(bzf->writing))
      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
   if (ferror(bzf->handle))
      { BZ_SETERR(BZ_IO_ERROR); return; };

   if (nbytes_in_lo32 != NULL) *nbytes_in_lo32 = 0;
   if (nbytes_in_hi32 != NULL) *nbytes_in_hi32 = 0;
   if (nbytes_out_lo32 != NULL) *nbytes_out_lo32 = 0;
   if (nbytes_out_hi32 != NULL) *nbytes_out_hi32 = 0;

   if ((!abandon) && bzf->lastErr == BZ_OK) {
      while (True) {
         bzf->strm.avail_out = BZ_MAX_UNUSED;
         bzf->strm.next_out = bzf->buf;
         ret = BZ2_bzCompress ( &(bzf->strm), BZ_FINISH );
         if (ret != BZ_FINISH_OK && ret != BZ_STREAM_END)
            { BZ_SETERR(ret); return; };

         if (bzf->strm.avail_out < BZ_MAX_UNUSED) {
            n = BZ_MAX_UNUSED - bzf->strm.avail_out;
            n2 = fwrite ( (void*)(bzf->buf), sizeof(UChar), 
                          n, bzf->handle );
            if (n != n2 || ferror(bzf->handle))
               { BZ_SETERR(BZ_IO_ERROR); return; };
         }

         if (ret == BZ_STREAM_END) break;
      }
   }

   if ( !abandon && !ferror ( bzf->handle ) ) {
      fflush ( bzf->handle );
      if (ferror(bzf->handle))
         { BZ_SETERR(BZ_IO_ERROR); return; };
   }

   if (nbytes_in_lo32 != NULL)
      *nbytes_in_lo32 = bzf->strm.total_in_lo32;
   if (nbytes_in_hi32 != NULL)
      *nbytes_in_hi32 = bzf->strm.total_in_hi32;
   if (nbytes_out_lo32 != NULL)
      *nbytes_out_lo32 = bzf->strm.total_out_lo32;
   if (nbytes_out_hi32 != NULL)
      *nbytes_out_hi32 = bzf->strm.total_out_hi32;

   BZ_SETERR(BZ_OK);
   BZ2_bzCompressEnd ( &(bzf->strm) );
   free ( bzf );
}


/*---------------------------------------------------*/
BZFILE* BZ_API(BZ2_bzReadOpen) 
                   ( int*  bzerror, 
                     FILE* f, 
                     int   verbosity,
                     int   small,
                     void* unused,
                     int   nUnused )
{
   bzFile* bzf = NULL;
   int     ret;

   BZ_SETERR(BZ_OK);

   if (f == NULL || 
       (small != 0 && small != 1) ||
       (verbosity < 0 || verbosity > 4) ||
       (unused == NULL && nUnused != 0) ||
       (unused != NULL && (nUnused < 0 || nUnused > BZ_MAX_UNUSED)))
      { BZ_SETERR(BZ_PARAM_ERROR); return NULL; };

   if (ferror(f))
      { BZ_SETERR(BZ_IO_ERROR); return NULL; };

   bzf = malloc ( sizeof(bzFile) );
   if (bzf == NULL) 
      { BZ_SETERR(BZ_MEM_ERROR); return NULL; };

   BZ_SETERR(BZ_OK);

   bzf->initialisedOk = False;
   bzf->handle        = f;
   bzf->bufN          = 0;
   bzf->writing       = False;
   bzf->strm.bzalloc  = NULL;
   bzf->strm.bzfree   = NULL;
   bzf->strm.opaque   = NULL;
   
   while (nUnused > 0) {
      bzf->buf[bzf->bufN] = *((UChar*)(unused)); bzf->bufN++;
      unused = ((void*)( 1 + ((UChar*)(unused))  ));
      nUnused--;
   }

   ret = BZ2_bzDecompressInit ( &(bzf->strm), verbosity, small );
   if (ret != BZ_OK)
      { BZ_SETERR(ret); free(bzf); return NULL; };

   bzf->strm.avail_in = bzf->bufN;
   bzf->strm.next_in  = bzf->buf;

   bzf->initialisedOk = True;
   return bzf;   
}


/*---------------------------------------------------*/
void BZ_API(BZ2_bzReadClose) ( int *bzerror, BZFILE *b )
{
   bzFile* bzf = (bzFile*)b;

   BZ_SETERR(BZ_OK);
   if (bzf == NULL)
      { BZ_SETERR(BZ_OK); return; };

   if (bzf->writing)
      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };

   if (bzf->initialisedOk)
      (void)BZ2_bzDecompressEnd ( &(bzf->strm) );
   free ( bzf );
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzRead) 
           ( int*    bzerror, 
             BZFILE* b, 
             void*   buf, 
             int     len )
{
   Int32   n, ret;
   bzFile* bzf = (bzFile*)b;

   BZ_SETERR(BZ_OK);

   if (bzf == NULL || buf == NULL || len < 0)
      { BZ_SETERR(BZ_PARAM_ERROR); return 0; };

   if (bzf->writing)
      { BZ_SETERR(BZ_SEQUENCE_ERROR); return 0; };

   if (len == 0)
      { BZ_SETERR(BZ_OK); return 0; };

   bzf->strm.avail_out = len;
   bzf->strm.next_out = buf;

   while (True) {

      if (ferror(bzf->handle)) 
         { BZ_SETERR(BZ_IO_ERROR); return 0; };

      if (bzf->strm.avail_in == 0 && !myfeof(bzf->handle)) {
         n = fread ( bzf->buf, sizeof(UChar), 
                     BZ_MAX_UNUSED, bzf->handle );
         if (ferror(bzf->handle))
            { BZ_SETERR(BZ_IO_ERROR); return 0; };
         bzf->bufN = n;
         bzf->strm.avail_in = bzf->bufN;
         bzf->strm.next_in = bzf->buf;
      }

      ret = BZ2_bzDecompress ( &(bzf->strm) );

      if (ret != BZ_OK && ret != BZ_STREAM_END)
         { BZ_SETERR(ret); return 0; };

      if (ret == BZ_OK && myfeof(bzf->handle) && 
          bzf->strm.avail_in == 0 && bzf->strm.avail_out > 0)
         { BZ_SETERR(BZ_UNEXPECTED_EOF); return 0; };

      if (ret == BZ_STREAM_END)
         { BZ_SETERR(BZ_STREAM_END);
           return len - bzf->strm.avail_out; };
      if (bzf->strm.avail_out == 0)
         { BZ_SETERR(BZ_OK); return len; };
      
   }

   return 0; /*not reached*/
}


/*---------------------------------------------------*/
void BZ_API(BZ2_bzReadGetUnused) 
                     ( int*    bzerror, 
                       BZFILE* b, 
                       void**  unused, 
                       int*    nUnused )
{
   bzFile* bzf = (bzFile*)b;
   if (bzf == NULL)
      { BZ_SETERR(BZ_PARAM_ERROR); return; };
   if (bzf->lastErr != BZ_STREAM_END)
      { BZ_SETERR(BZ_SEQUENCE_ERROR); return; };
   if (unused == NULL || nUnused == NULL)
      { BZ_SETERR(BZ_PARAM_ERROR); return; };

   BZ_SETERR(BZ_OK);
   *nUnused = bzf->strm.avail_in;
   *unused = bzf->strm.next_in;
}
#endif


/*---------------------------------------------------*/
/*--- Misc convenience stuff                      ---*/
/*---------------------------------------------------*/

/*---------------------------------------------------*/
int BZ_API(BZ2_bzBuffToBuffCompress) 
                         ( char*         dest, 
                           unsigned int* destLen,
                           char*         source, 
                           unsigned int  sourceLen,
                           int           blockSize100k, 
                           int           verbosity, 
                           int           workFactor )
{
   bz_stream strm;
   int ret;

   if (dest == NULL || destLen == NULL || 
       source == NULL ||
       blockSize100k < 1 || blockSize100k > 9 ||
       verbosity < 0 || verbosity > 4 ||
       workFactor < 0 || workFactor > 250) 
      return BZ_PARAM_ERROR;

   if (workFactor == 0) workFactor = 30;
   strm.bzalloc = NULL;
   strm.bzfree = NULL;
   strm.opaque = NULL;
   ret = BZ2_bzCompressInit ( &strm, blockSize100k, 
                              verbosity, workFactor );
   if (ret != BZ_OK) return ret;

   strm.next_in = source;
   strm.next_out = dest;
   strm.avail_in = sourceLen;
   strm.avail_out = *destLen;

   ret = BZ2_bzCompress ( &strm, BZ_FINISH );
   if (ret == BZ_FINISH_OK) goto output_overflow;
   if (ret != BZ_STREAM_END) goto errhandler;

   /* normal termination */
   *destLen -= strm.avail_out;   
   BZ2_bzCompressEnd ( &strm );
   return BZ_OK;

   output_overflow:
   BZ2_bzCompressEnd ( &strm );
   return BZ_OUTBUFF_FULL;

   errhandler:
   BZ2_bzCompressEnd ( &strm );
   return ret;
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzBuffToBuffDecompress) 
                           ( char*         dest, 
                             unsigned int* destLen,
                             char*         source, 
                             unsigned int  sourceLen,
                             int           small,
                             int           verbosity )
{
   bz_stream strm;
   int ret;

   if (dest == NULL || destLen == NULL || 
       source == NULL ||
       (small != 0 && small != 1) ||
       verbosity < 0 || verbosity > 4) 
          return BZ_PARAM_ERROR;

   strm.bzalloc = NULL;
   strm.bzfree = NULL;
   strm.opaque = NULL;
   ret = BZ2_bzDecompressInit ( &strm, verbosity, small );
   if (ret != BZ_OK) return ret;

   strm.next_in = source;
   strm.next_out = dest;
   strm.avail_in = sourceLen;
   strm.avail_out = *destLen;

   ret = BZ2_bzDecompress ( &strm );
   if (ret == BZ_OK) goto output_overflow_or_eof;
   if (ret != BZ_STREAM_END) goto errhandler;

   /* normal termination */
   *destLen -= strm.avail_out;
   BZ2_bzDecompressEnd ( &strm );
   return BZ_OK;

   output_overflow_or_eof:
   if (strm.avail_out > 0) {
      BZ2_bzDecompressEnd ( &strm );
      return BZ_UNEXPECTED_EOF;
   } else {
      BZ2_bzDecompressEnd ( &strm );
      return BZ_OUTBUFF_FULL;
   };      

   errhandler:
   BZ2_bzDecompressEnd ( &strm );
   return ret; 
}


/*---------------------------------------------------*/
/*--
   Code contributed by Yoshioka Tsuneo
   (QWF00133@niftyserve.or.jp/tsuneo-y@is.aist-nara.ac.jp),
   to support better zlib compatibility.
   This code is not _officially_ part of libbzip2 (yet);
   I haven't tested it, documented it, or considered the
   threading-safeness of it.
   If this code breaks, please contact both Yoshioka and me.
--*/
/*---------------------------------------------------*/

/*---------------------------------------------------*/
/*--
   return version like "0.9.0c".
--*/
const char * BZ_API(BZ2_bzlibVersion)(void)
{
   return BZ_VERSION;
}


#ifndef BZ_NO_STDIO
/*---------------------------------------------------*/

static
BZFILE * bzopen_or_bzdopen
               ( const char *path,   /* no use when bzdopen */
                 int fd,             /* no use when bzdopen */
                 const char *mode,
                 int open_mode)      /* bzopen: 0, bzdopen:1 */
{
   int    bzerr;
   char   unused[BZ_MAX_UNUSED];
   int    blockSize100k = 9;
   int    writing       = 0;
   char   mode2[10]     = "";
   FILE   *fp           = NULL;
   BZFILE *bzfp         = NULL;
   int    verbosity     = 0;
   int    workFactor    = 30;
   int    smallMode     = 0;
   int    nUnused       = 0; 

   if (mode == NULL) return NULL;
   while (*mode) {
      switch (*mode) {
      case 'r':
         writing = 0; break;
      case 'w':
         writing = 1; break;
      case 's':
         smallMode = 1; break;
      default:
         if (isdigit((int)(*mode))) {
            blockSize100k = *mode-BZ_HDR_0;
         }
      }
      mode++;
   }
   strcat(mode2, writing ? "w" : "r" );
   strcat(mode2,"b");   /* binary mode */

   if (open_mode==0) {
      if (path==NULL || strcmp(path,"")==0) {
        fp = (writing ? stdout : stdin);
      } else {
        fp = fopen(path,mode2);
      }
   } else {
#ifdef BZ_STRICT_ANSI
      fp = NULL;
#else
      fp = fdopen(fd,mode2);
#endif
   }
   if (fp == NULL) return NULL;

   if (writing) {
      /* Guard against total chaos and anarchy -- JRS */
      if (blockSize100k < 1) blockSize100k = 1;
      if (blockSize100k > 9) blockSize100k = 9; 
      bzfp = BZ2_bzWriteOpen(&bzerr,fp,blockSize100k,
                             verbosity,workFactor);
   } else {
      bzfp = BZ2_bzReadOpen(&bzerr,fp,verbosity,smallMode,
                            unused,nUnused);
   }
   if (bzfp == NULL) {
      if (fp != stdin && fp != stdout) fclose(fp);
      return NULL;
   }
   return bzfp;
}


/*---------------------------------------------------*/
/*--
   open file for read or write.
      ex) bzopen("file","w9")
      case path="" or NULL => use stdin or stdout.
--*/
BZFILE * BZ_API(BZ2_bzopen)
               ( const char *path,
                 const char *mode )
{
   return bzopen_or_bzdopen(path,-1,mode,/*bzopen*/0);
}


/*---------------------------------------------------*/
BZFILE * BZ_API(BZ2_bzdopen)
               ( int fd,
                 const char *mode )
{
   return bzopen_or_bzdopen(NULL,fd,mode,/*bzdopen*/1);
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzread) (BZFILE* b, void* buf, int len )
{
   int bzerr, nread;
   if (((bzFile*)b)->lastErr == BZ_STREAM_END) return 0;
   nread = BZ2_bzRead(&bzerr,b,buf,len);
   if (bzerr == BZ_OK || bzerr == BZ_STREAM_END) {
      return nread;
   } else {
      return -1;
   }
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzwrite) (BZFILE* b, void* buf, int len )
{
   int bzerr;

   BZ2_bzWrite(&bzerr,b,buf,len);
   if(bzerr == BZ_OK){
      return len;
   }else{
      return -1;
   }
}


/*---------------------------------------------------*/
int BZ_API(BZ2_bzflush) (BZFILE *b)
{
   /* do nothing now... */
   return 0;
}


/*---------------------------------------------------*/
void BZ_API(BZ2_bzclose) (BZFILE* b)
{
   int bzerr;
   FILE *fp = ((bzFile *)b)->handle;
   
   if (b==NULL) {return;}
   if(((bzFile*)b)->writing){
      BZ2_bzWriteClose(&bzerr,b,0,NULL,NULL);
      if(bzerr != BZ_OK){
         BZ2_bzWriteClose(NULL,b,1,NULL,NULL);
      }
   }else{
      BZ2_bzReadClose(&bzerr,b);
   }
   if(fp!=stdin && fp!=stdout){
      fclose(fp);
   }
}


/*---------------------------------------------------*/
/*--
   return last error code 
--*/
static char *bzerrorstrings[] = {
       "OK"
      ,"SEQUENCE_ERROR"
      ,"PARAM_ERROR"
      ,"MEM_ERROR"
      ,"DATA_ERROR"
      ,"DATA_ERROR_MAGIC"
      ,"IO_ERROR"
      ,"UNEXPECTED_EOF"
      ,"OUTBUFF_FULL"
      ,"CONFIG_ERROR"
      ,"???"   /* for future */
      ,"???"   /* for future */
      ,"???"   /* for future */
      ,"???"   /* for future */
      ,"???"   /* for future */
      ,"???"   /* for future */
};


const char * BZ_API(BZ2_bzerror) (BZFILE *b, int *errnum)
{
   int err = ((bzFile *)b)->lastErr;

   if(err>0) err = 0;
   *errnum = err;
   return bzerrorstrings[err*-1];
}
#endif


/*-------------------------------------------------------------*/
/*--- end                                           bzlib.c ---*/
/*-------------------------------------------------------------*/

/*-----------------------------------------------------------*/
/*--- A block-sorting, lossless compressor        bzip2.c ---*/
/*-----------------------------------------------------------*/



/*----------------------------------------------------*/
/*--- IMPORTANT                                    ---*/
/*----------------------------------------------------*/

/*--
   WARNING:
      This program and library (attempts to) compress data by 
      performing several non-trivial transformations on it.  
      Unless you are 100% familiar with *all* the algorithms 
      contained herein, and with the consequences of modifying them, 
      you should NOT meddle with the compression or decompression 
      machinery.  Incorrect changes can and very likely *will* 
      lead to disasterous loss of data.

   DISCLAIMER:
      I TAKE NO RESPONSIBILITY FOR ANY LOSS OF DATA ARISING FROM THE
      USE OF THIS PROGRAM, HOWSOEVER CAUSED.

      Every compression of a file implies an assumption that the
      compressed file can be decompressed to reproduce the original.
      Great efforts in design, coding and testing have been made to
      ensure that this program works correctly.  However, the
      complexity of the algorithms, and, in particular, the presence
      of various special cases in the code which occur with very low
      but non-zero probability make it impossible to rule out the
      possibility of bugs remaining in the program.  DO NOT COMPRESS
      ANY DATA WITH THIS PROGRAM AND/OR LIBRARY UNLESS YOU ARE PREPARED 
      TO ACCEPT THE POSSIBILITY, HOWEVER SMALL, THAT THE DATA WILL 
      NOT BE RECOVERABLE.

      That is not to say this program is inherently unreliable.
      Indeed, I very much hope the opposite is true.  bzip2/libbzip2
      has been carefully constructed and extensively tested.

   PATENTS:
      To the best of my knowledge, bzip2/libbzip2 does not use any 
      patented algorithms.  However, I do not have the resources 
      available to carry out a full patent search.  Therefore I cannot 
      give any guarantee of the above statement.
--*/



/*----------------------------------------------------*/
/*--- and now for something much more pleasant :-) ---*/
/*----------------------------------------------------*/

/*---------------------------------------------*/
/*--
  Place a 1 beside your platform, and 0 elsewhere.
--*/

/*--
  Generic 32-bit Unix.
  Also works on 64-bit Unix boxes.
  This is the default.
--*/
#define BZ_UNIX      1

/*--
  Win32, as seen by Jacob Navia's excellent
  port of (Chris Fraser & David Hanson)'s excellent
  lcc compiler.  Or with MS Visual C.
  This is selected automatically if compiled by a compiler which
  defines _WIN32, not including the Cygwin GCC.
--*/
#define BZ_LCCWIN32  0

#if defined(_WIN32) && !defined(__CYGWIN__)
#undef  BZ_LCCWIN32
#define BZ_LCCWIN32 1
#undef  BZ_UNIX
#define BZ_UNIX 0
#endif


/*---------------------------------------------*/
/*--
  Some stuff for all platforms.
--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <math.h>
#include <errno.h>
#include <ctype.h>

#define ERROR_IF_EOF(i)       { if ((i) == EOF)  ioError(); }
#define ERROR_IF_NOT_ZERO(i)  { if ((i) != 0)    ioError(); }
#define ERROR_IF_MINUS_ONE(i) { if ((i) == (-1)) ioError(); }


/*---------------------------------------------*/
/*--
   Platform-specific stuff.
--*/

#if BZ_UNIX
#   include <fcntl.h>
#   include <sys/types.h>
#   include <utime.h>
#   include <unistd.h>
#   include <sys/stat.h>
#   include <sys/times.h>

#   define PATH_SEP    '/'
#   define MY_LSTAT    lstat
#   define MY_STAT     stat
#   define MY_S_ISREG  S_ISREG
#   define MY_S_ISDIR  S_ISDIR

#   define APPEND_FILESPEC(root, name) \
      root=snocString((root), (name))

#   define APPEND_FLAG(root, name) \
      root=snocString((root), (name))

#   define SET_BINARY_MODE(fd) /**/

#   ifdef __GNUC__
#      define NORETURN __attribute__ ((noreturn))
#   else
#      define NORETURN /**/
#   endif

#   ifdef __DJGPP__
#     include <io.h>
#     include <fcntl.h>
#     undef MY_LSTAT
#     undef MY_STAT
#     define MY_LSTAT stat
#     define MY_STAT stat
#     undef SET_BINARY_MODE
#     define SET_BINARY_MODE(fd)                        \
        do {                                            \
           int retVal = setmode ( fileno ( fd ),        \
                                  O_BINARY );           \
           ERROR_IF_MINUS_ONE ( retVal );               \
        } while ( 0 )
#   endif

#   ifdef __CYGWIN__
#     include <io.h>
#     include <fcntl.h>
#     undef SET_BINARY_MODE
#     define SET_BINARY_MODE(fd)                        \
        do {                                            \
           int retVal = setmode ( fileno ( fd ),        \
                                  O_BINARY );           \
           ERROR_IF_MINUS_ONE ( retVal );               \
        } while ( 0 )
#   endif
#endif /* BZ_UNIX */



#if BZ_LCCWIN32
#   include <io.h>
#   include <fcntl.h>
#   include <sys\stat.h>

#   define NORETURN       /**/
#   define PATH_SEP       '\\'
#   define MY_LSTAT       _stat
#   define MY_STAT        _stat
#   define MY_S_ISREG(x)  ((x) & _S_IFREG)
#   define MY_S_ISDIR(x)  ((x) & _S_IFDIR)

#   define APPEND_FLAG(root, name) \
      root=snocString((root), (name))

#   define APPEND_FILESPEC(root, name)                \
      root = snocString ((root), (name))

#   define SET_BINARY_MODE(fd)                        \
      do {                                            \
         int retVal = setmode ( fileno ( fd ),        \
                                O_BINARY );           \
         ERROR_IF_MINUS_ONE ( retVal );               \
      } while ( 0 )

#endif /* BZ_LCCWIN32 */


/*---------------------------------------------*/
/*--
  Some more stuff for all platforms :-)
--*/
                                       
#define True  ((Bool)1)
#define False ((Bool)0)

/*--
  IntNative is your platform's `native' int size.
  Only here to avoid probs with 64-bit platforms.
--*/
typedef int IntNative;


/*---------------------------------------------------*/
/*--- Misc (file handling) data decls             ---*/
/*---------------------------------------------------*/

Int32   verbosity;
Bool    keepInputFiles, smallMode, deleteOutputOnInterrupt;
Bool    forceOverwrite, testFailsExist, unzFailsExist, noisy;
Int32   numFileNames, numFilesProcessed, blockSize100k;
Int32   exitValue;

/*-- source modes; F==file, I==stdin, O==stdout --*/
#define SM_I2O           1
#define SM_F2O           2
#define SM_F2F           3

/*-- operation modes --*/
#define OM_Z             1
#define OM_UNZ           2
#define OM_TEST          3

Int32   opMode;
Int32   srcMode;

#define FILE_NAME_LEN 1034

Int32   longestFileName;
Char    inName [FILE_NAME_LEN];
Char    outName[FILE_NAME_LEN];
Char    tmpName[FILE_NAME_LEN];
Char    *progName;
Char    progNameReally[FILE_NAME_LEN];
FILE    *outputHandleJustInCase;
Int32   workFactor;

static void    panic                 ( Char* )   NORETURN;
static void    ioError               ( void )    NORETURN;
static void    outOfMemory           ( void )    NORETURN;
static void    configError           ( void )    NORETURN;
static void    crcError              ( void )    NORETURN;
static void    cleanUpAndFail        ( Int32 )   NORETURN;
static void    compressedStreamEOF   ( void )    NORETURN;

static void    copyFileName ( Char*, Char* );
static void*   myMalloc     ( Int32 );



/*---------------------------------------------------*/
/*--- An implementation of 64-bit ints.  Sigh.    ---*/
/*--- Roll on widespread deployment of ANSI C9X ! ---*/
/*---------------------------------------------------*/

typedef
   struct { UChar b[8]; } 
   UInt64;


static
void uInt64_from_UInt32s ( UInt64* n, UInt32 lo32, UInt32 hi32 )
{
   n->b[7] = (UChar)((hi32 >> 24) & 0xFF);
   n->b[6] = (UChar)((hi32 >> 16) & 0xFF);
   n->b[5] = (UChar)((hi32 >> 8)  & 0xFF);
   n->b[4] = (UChar) (hi32        & 0xFF);
   n->b[3] = (UChar)((lo32 >> 24) & 0xFF);
   n->b[2] = (UChar)((lo32 >> 16) & 0xFF);
   n->b[1] = (UChar)((lo32 >> 8)  & 0xFF);
   n->b[0] = (UChar) (lo32        & 0xFF);
}


static
double uInt64_to_double ( UInt64* n )
{
   Int32  i;
   double base = 1.0;
   double sum  = 0.0;
   for (i = 0; i < 8; i++) {
      sum  += base * (double)(n->b[i]);
      base *= 256.0;
   }
   return sum;
}


static
Bool uInt64_isZero ( UInt64* n )
{
   Int32 i;
   for (i = 0; i < 8; i++)
      if (n->b[i] != 0) return 0;
   return 1;
}


/* Divide *n by 10, and return the remainder.  */
static 
Int32 uInt64_qrm10 ( UInt64* n )
{
   UInt32 rem, tmp;
   Int32  i;
   rem = 0;
   for (i = 7; i >= 0; i--) {
      tmp = rem * 256 + n->b[i];
      n->b[i] = tmp / 10;
      rem = tmp % 10;
   }
   return rem;
}


/* ... and the Whole Entire Point of all this UInt64 stuff is
   so that we can supply the following function.
*/
static
void uInt64_toAscii ( char* outbuf, UInt64* n )
{
   Int32  i, q;
   UChar  buf[32];
   Int32  nBuf   = 0;
   UInt64 n_copy = *n;
   do {
      q = uInt64_qrm10 ( &n_copy );
      buf[nBuf] = q + '0';
      nBuf++;
   } while (!uInt64_isZero(&n_copy));
   outbuf[nBuf] = 0;
   for (i = 0; i < nBuf; i++) 
      outbuf[i] = buf[nBuf-i-1];
}


/*---------------------------------------------------*/
/*--- Processing of complete files and streams    ---*/
/*---------------------------------------------------*/

/*---------------------------------------------*/

/*---------------------------------------------*/




/*---------------------------------------------*/



/*---------------------------------------------*/



/*---------------------------------------------------*/
/*--- Error [non-] handling grunge                ---*/
/*---------------------------------------------------*/

/*---------------------------------------------*/
static
void setExit ( Int32 v )
{
   if (v > exitValue) exitValue = v;
}


/*---------------------------------------------*/
static 
void cadvise ( void )
{
   if (noisy)
   fprintf (
      stderr,
      "\nIt is possible that the compressed file(s) have become corrupted.\n"
        "You can use the -tvv option to test integrity of such files.\n\n"
        "You can use the `bzip2recover' program to attempt to recover\n"
        "data from undamaged sections of corrupted files.\n\n"
    );
}


/*---------------------------------------------*/
static 
void showFileNames ( void )
{
   if (noisy)
   fprintf (
      stderr,
      "\tInput file = %s, output file = %s\n",
      inName, outName 
   );
}


/*---------------------------------------------*/
static 
void cleanUpAndFail ( Int32 ec )
{
   IntNative      retVal;
   struct MY_STAT statBuf;

   if ( srcMode == SM_F2F 
        && opMode != OM_TEST
        && deleteOutputOnInterrupt ) {

      /* Check whether input file still exists.  Delete output file
         only if input exists to avoid loss of data.  Joerg Prante, 5
         January 2002.  (JRS 06-Jan-2002: other changes in 1.0.2 mean
         this is less likely to happen.  But to be ultra-paranoid, we
         do the check anyway.)  */
      retVal = MY_STAT ( inName, &statBuf );
      if (retVal == 0) {
         if (noisy)
            fprintf ( stderr, 
                      "%s: Deleting output file %s, if it exists.\n",
                      progName, outName );
         if (outputHandleJustInCase != NULL)
            fclose ( outputHandleJustInCase );
         retVal = remove ( outName );
         if (retVal != 0)
            fprintf ( stderr,
                      "%s: WARNING: deletion of output file "
                      "(apparently) failed.\n",
                      progName );
      } else {
         fprintf ( stderr,
                   "%s: WARNING: deletion of output file suppressed\n",
                    progName );
         fprintf ( stderr,
                   "%s:    since input file no longer exists.  Output file\n",
                   progName );
         fprintf ( stderr,
                   "%s:    `%s' may be incomplete.\n",
                   progName, outName );
         fprintf ( stderr, 
                   "%s:    I suggest doing an integrity test (bzip2 -tv)"
                   " of it.\n",
                   progName );
      }
   }

   if (noisy && numFileNames > 0 && numFilesProcessed < numFileNames) {
      fprintf ( stderr, 
                "%s: WARNING: some files have not been processed:\n"
                "%s:    %d specified on command line, %d not processed yet.\n\n",
                progName, progName,
                numFileNames, numFileNames - numFilesProcessed );
   }
   setExit(ec);
   exit(exitValue);
}


/*---------------------------------------------*/
static 
void panic ( Char* s )
{
   fprintf ( stderr,
             "\n%s: PANIC -- internal consistency error:\n"
             "\t%s\n"
             "\tThis is a BUG.  Please report it to me at:\n"
             "\tjseward@acm.org\n",
             progName, s );
   showFileNames();
   cleanUpAndFail( 3 );
}


/*---------------------------------------------*/
static 
void crcError ( void )
{
   fprintf ( stderr,
             "\n%s: Data integrity error when decompressing.\n",
             progName );
   showFileNames();
   cadvise();
   cleanUpAndFail( 2 );
}


/*---------------------------------------------*/
static 
void compressedStreamEOF ( void )
{
  if (noisy) {
    fprintf ( stderr,
	      "\n%s: Compressed file ends unexpectedly;\n\t"
	      "perhaps it is corrupted?  *Possible* reason follows.\n",
	      progName );
    perror ( progName );
    showFileNames();
    cadvise();
  }
  cleanUpAndFail( 2 );
}


/*---------------------------------------------*/
static 
void ioError ( void )
{
   fprintf ( stderr,
             "\n%s: I/O or other error, bailing out.  "
             "Possible reason follows.\n",
             progName );
   perror ( progName );
   showFileNames();
   cleanUpAndFail( 1 );
}


/*---------------------------------------------*/
static 
void mySignalCatcher ( IntNative n )
{
   fprintf ( stderr,
             "\n%s: Control-C or similar caught, quitting.\n",
             progName );
   cleanUpAndFail(1);
}


/*---------------------------------------------*/
static 
void mySIGSEGVorSIGBUScatcher ( IntNative n )
{
   if (opMode == OM_Z)
      fprintf ( 
      stderr,
      "\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n"
      "\n"
      "   Possible causes are (most likely first):\n"
      "   (1) This computer has unreliable memory or cache hardware\n"
      "       (a surprisingly common problem; try a different machine.)\n"
      "   (2) A bug in the compiler used to create this executable\n"
      "       (unlikely, if you didn't compile bzip2 yourself.)\n"
      "   (3) A real bug in bzip2 -- I hope this should never be the case.\n"
      "   The user's manual, Section 4.3, has more info on (1) and (2).\n"
      "   \n"
      "   If you suspect this is a bug in bzip2, or are unsure about (1)\n"
      "   or (2), feel free to report it to me at: jseward@acm.org.\n"
      "   Section 4.3 of the user's manual describes the info a useful\n"
      "   bug report should have.  If the manual is available on your\n"
      "   system, please try and read it before mailing me.  If you don't\n"
      "   have the manual or can't be bothered to read it, mail me anyway.\n"
      "\n",
      progName );
      else
      fprintf ( 
      stderr,
      "\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n"
      "\n"
      "   Possible causes are (most likely first):\n"
      "   (1) The compressed data is corrupted, and bzip2's usual checks\n"
      "       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n"
      "   (2) This computer has unreliable memory or cache hardware\n"
      "       (a surprisingly common problem; try a different machine.)\n"
      "   (3) A bug in the compiler used to create this executable\n"
      "       (unlikely, if you didn't compile bzip2 yourself.)\n"
      "   (4) A real bug in bzip2 -- I hope this should never be the case.\n"
      "   The user's manual, Section 4.3, has more info on (2) and (3).\n"
      "   \n"
      "   If you suspect this is a bug in bzip2, or are unsure about (2)\n"
      "   or (3), feel free to report it to me at: jseward@acm.org.\n"
      "   Section 4.3 of the user's manual describes the info a useful\n"
      "   bug report should have.  If the manual is available on your\n"
      "   system, please try and read it before mailing me.  If you don't\n"
      "   have the manual or can't be bothered to read it, mail me anyway.\n"
      "\n",
      progName );

   showFileNames();
   if (opMode == OM_Z)
      cleanUpAndFail( 3 ); else
      { cadvise(); cleanUpAndFail( 2 ); }
}


/*---------------------------------------------*/
static 
void outOfMemory ( void )
{
   fprintf ( stderr,
             "\n%s: couldn't allocate enough memory\n",
             progName );
   showFileNames();
   cleanUpAndFail(1);
}


/*---------------------------------------------*/
static 
void configError ( void )
{
   fprintf ( stderr,
             "bzip2: I'm not configured correctly for this platform!\n"
             "\tI require Int32, Int16 and Char to have sizes\n"
             "\tof 4, 2 and 1 bytes to run properly, and they don't.\n"
             "\tProbably you can fix this by defining them correctly,\n"
             "\tand recompiling.  Bye!\n" );
   setExit(3);
   exit(exitValue);
}


/*---------------------------------------------------*/
/*--- The main driver machinery                   ---*/
/*---------------------------------------------------*/

/* All rather crufty.  The main problem is that input files
   are stat()d multiple times before use.  This should be
   cleaned up. 
*/

/*---------------------------------------------*/
static 
void pad ( Char *s )
{
   Int32 i;
   if ( (Int32)strlen(s) >= longestFileName ) return;
   for (i = 1; i <= longestFileName - (Int32)strlen(s); i++)
      fprintf ( stderr, " " );
}


/*---------------------------------------------*/
static 
void copyFileName ( Char* to, Char* from ) 
{
   if ( strlen(from) > FILE_NAME_LEN-10 )  {
      fprintf (
         stderr,
         "bzip2: file name\n`%s'\n"
         "is suspiciously (more than %d chars) long.\n"
         "Try using a reasonable file name instead.  Sorry! :-)\n",
         from, FILE_NAME_LEN-10
      );
      setExit(1);
      exit(exitValue);
   }

  strncpy(to,from,FILE_NAME_LEN-10);
  to[FILE_NAME_LEN-10]='\0';
}


/*---------------------------------------------*/
static 
Bool fileExists ( Char* name )
{
   FILE *tmp   = fopen ( name, "rb" );
   Bool exists = (tmp != NULL);
   if (tmp != NULL) fclose ( tmp );
   return exists;
}


/*---------------------------------------------*/
/* Open an output file safely with O_EXCL and good permissions.
   This avoids a race condition in versions < 1.0.2, in which
   the file was first opened and then had its interim permissions
   set safely.  We instead use open() to create the file with
   the interim permissions required. (--- --- rw-).

   For non-Unix platforms, if we are not worrying about
   security issues, simple this simply behaves like fopen.
*/



/*---------------------------------------------*/
/*--
  if in doubt, return True
--*/
static 
Bool notAStandardFile ( Char* name )
{
   IntNative      i;
   struct MY_STAT statBuf;

   i = MY_LSTAT ( name, &statBuf );
   if (i != 0) return True;
   if (MY_S_ISREG(statBuf.st_mode)) return False;
   return True;
}


/*---------------------------------------------*/
/*--
  rac 11/21/98 see if file has hard links to it
--*/
static 
Int32 countHardLinks ( Char* name )
{  
   IntNative      i;
   struct MY_STAT statBuf;

   i = MY_LSTAT ( name, &statBuf );
   if (i != 0) return 0;
   return (statBuf.st_nlink - 1);
}


/*---------------------------------------------*/
/* Copy modification date, access date, permissions and owner from the
   source to destination file.  We have to copy this meta-info off
   into fileMetaInfo before starting to compress / decompress it,
   because doing it afterwards means we get the wrong access time.

   To complicate matters, in compress() and decompress() below, the
   sequence of tests preceding the call to saveInputFileMetaInfo()
   involves calling fileExists(), which in turn establishes its result
   by attempting to fopen() the file, and if successful, immediately
   fclose()ing it again.  So we have to assume that the fopen() call
   does not cause the access time field to be updated.

   Reading of the man page for stat() (man 2 stat) on RedHat 7.2 seems
   to imply that merely doing open() will not affect the access time.
   Therefore we merely need to hope that the C library only does
   open() as a result of fopen(), and not any kind of read()-ahead
   cleverness.

   It sounds pretty fragile to me.  Whether this carries across
   robustly to arbitrary Unix-like platforms (or even works robustly
   on this one, RedHat 7.2) is unknown to me.  Nevertheless ...  
*/
#if BZ_UNIX
static 
struct MY_STAT fileMetaInfo;
#endif

static 
void saveInputFileMetaInfo ( Char *srcName )
{
#  if BZ_UNIX
   IntNative retVal;
   /* Note use of stat here, not lstat. */
   retVal = MY_STAT( srcName, &fileMetaInfo );
   ERROR_IF_NOT_ZERO ( retVal );
#  endif
}


static 
void applySavedMetaInfoToOutputFile ( Char *dstName )
{
#  if BZ_UNIX
   IntNative      retVal;
   struct utimbuf uTimBuf;

   uTimBuf.actime = fileMetaInfo.st_atime;
   uTimBuf.modtime = fileMetaInfo.st_mtime;

   retVal = chmod ( dstName, fileMetaInfo.st_mode );
   ERROR_IF_NOT_ZERO ( retVal );

   retVal = utime ( dstName, &uTimBuf );
   ERROR_IF_NOT_ZERO ( retVal );

   retVal = chown ( dstName, fileMetaInfo.st_uid, fileMetaInfo.st_gid );
   /* chown() will in many cases return with EPERM, which can
      be safely ignored.
   */
#  endif
}


/*---------------------------------------------*/
static 
Bool containsDubiousChars ( Char* name )
{
#  if BZ_UNIX
   /* On unix, files can contain any characters and the file expansion
    * is performed by the shell.
    */
   return False;
#  else /* ! BZ_UNIX */
   /* On non-unix (Win* platforms), wildcard characters are not allowed in 
    * filenames.
    */
   for (; *name != '\0'; name++)
      if (*name == '?' || *name == '*') return True;
   return False;
#  endif /* BZ_UNIX */
}


/*---------------------------------------------*/
#define BZ_N_SUFFIX_PAIRS 4

Char* zSuffix[BZ_N_SUFFIX_PAIRS] 
   = { ".bz2", ".bz", ".tbz2", ".tbz" };
Char* unzSuffix[BZ_N_SUFFIX_PAIRS] 
   = { "", "", ".tar", ".tar" };

static 
Bool hasSuffix ( Char* s, Char* suffix )
{
   Int32 ns = strlen(s);
   Int32 nx = strlen(suffix);
   if (ns < nx) return False;
   if (strcmp(s + ns - nx, suffix) == 0) return True;
   return False;
}

static 
Bool mapSuffix ( Char* name, 
                 Char* oldSuffix, Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
   return True;
}


/*---------------------------------------------*/
static 
void compress ( Char *name )
{
   FILE  *inStr;
   FILE  *outStr;
   Int32 n, i;
   struct MY_STAT statBuf;

   deleteOutputOnInterrupt = False;

   if (name == NULL && srcMode != SM_I2O)
      panic ( "compress: bad modes\n" );

   switch (srcMode) {
      case SM_I2O: 
         copyFileName ( inName, "(stdin)" );
         copyFileName ( outName, "(stdout)" ); 
         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, ".bz2" ); 
         break;
      case SM_F2O: 
         copyFileName ( inName, name );
         copyFileName ( outName, "(stdout)" ); 
         break;
   }

   if ( srcMode != SM_I2O && containsDubiousChars ( inName ) ) {
      if (noisy)
      fprintf ( stderr, "%s: There are no files matching `%s'.\n",
                progName, inName );
      setExit(1);
      return;
   }
   if ( srcMode != SM_I2O && !fileExists ( inName ) ) {
      fprintf ( stderr, "%s: Can't open input file %s: %s.\n",
                progName, inName, strerror(errno) );
      setExit(1);
      return;
   }
   for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++) {
      if (hasSuffix(inName, zSuffix[i])) {
         if (noisy)
         fprintf ( stderr, 
                   "%s: Input file %s already has %s suffix.\n",
                   progName, inName, zSuffix[i] );
         setExit(1);
         return;
      }
   }
   if ( srcMode == SM_F2F || srcMode == SM_F2O ) {
      MY_STAT(inName, &statBuf);
      if ( MY_S_ISDIR(statBuf.st_mode) ) {
         fprintf( stderr,
                  "%s: Input file %s is a directory.\n",
                  progName,inName);
         setExit(1);
         return;
      }
   }
   if ( srcMode == SM_F2F && !forceOverwrite && notAStandardFile ( inName )) {
      if (noisy)
      fprintf ( stderr, "%s: Input file %s is not a normal file.\n",
                progName, inName );
      setExit(1);
      return;
   }
   if ( srcMode == SM_F2F && fileExists ( outName ) ) {
      if (forceOverwrite) {
	 remove(outName);
      } else {
	 fprintf ( stderr, "%s: Output file %s already exists.\n",
		   progName, outName );
	 setExit(1);
	 return;
      }
   }
   if ( srcMode == SM_F2F && !forceOverwrite &&
        (n=countHardLinks ( inName )) > 0) {
      fprintf ( stderr, "%s: Input file %s has %d other link%s.\n",
                progName, inName, n, n > 1 ? "s" : "" );
      setExit(1);
      return;
   }

   if ( srcMode == SM_F2F ) {
      /* Save the file's meta-info before we open it.  Doing it later
         means we mess up the access times. */
      saveInputFileMetaInfo ( inName );
   }

   switch ( srcMode ) {

      case SM_I2O:
         inStr = stdin;
         outStr = stdout;
         if ( isatty ( fileno ( stdout ) ) ) {
            fprintf ( stderr,
                      "%s: I won't write compressed data to a terminal.\n",
                      progName );
            fprintf ( stderr, "%s: For help, type: `%s --help'.\n",
                              progName, progName );
            setExit(1);
            return;
         };
         break;

      case SM_F2O:
         inStr = fopen ( inName, "rb" );
         outStr = stdout;
         if ( isatty ( fileno ( stdout ) ) ) {
            fprintf ( stderr,
                      "%s: I won't write compressed data to a terminal.\n",
                      progName );
            fprintf ( stderr, "%s: For help, type: `%s --help'.\n",
                              progName, progName );
            if ( inStr != NULL ) fclose ( inStr );
            setExit(1);
            return;
         };
         if ( inStr == NULL ) {
            fprintf ( stderr, "%s: Can't open input file %s: %s.\n",
                      progName, inName, strerror(errno) );
            setExit(1);
            return;
         };
         break;

      case SM_F2F:
         inStr = fopen ( inName, "rb" );
         outStr = fopen_output_safely ( outName, "wb" );
         if ( outStr == NULL) {
            fprintf ( stderr, "%s: Can't create output file %s: %s.\n",
                      progName, outName, strerror(errno) );
            if ( inStr != NULL ) fclose ( inStr );
            setExit(1);
            return;
         }
         if ( inStr == NULL ) {
            fprintf ( stderr, "%s: Can't open input file %s: %s.\n",
                      progName, inName, strerror(errno) );
            if ( outStr != NULL ) fclose ( outStr );
            setExit(1);
            return;
         };
         break;

      default:
         panic ( "compress: bad srcMode" );
         break;
   }

   if (verbosity >= 1) {
      fprintf ( stderr,  "  %s: ", inName );
      pad ( inName );
      fflush ( stderr );
   }

   /*--- Now the input and output handles are sane.  Do the Biz. ---*/
   outputHandleJustInCase = outStr;
   deleteOutputOnInterrupt = True;
   compressStream ( inStr, outStr );
   outputHandleJustInCase = NULL;

   /*--- If there was an I/O error, we won't get here. ---*/
   if ( srcMode == SM_F2F ) {
      applySavedMetaInfoToOutputFile ( outName );
      deleteOutputOnInterrupt = False;
      if ( !keepInputFiles ) {
         IntNative retVal = remove ( inName );
         ERROR_IF_NOT_ZERO ( retVal );
      }
   }

   deleteOutputOnInterrupt = False;
}


/*---------------------------------------------*/
static 
void uncompress ( Char *name )
{
   FILE  *inStr;
   FILE  *outStr;
   Int32 n, i;
   Bool  magicNumberOK;
   Bool  cantGuess;
   struct MY_STAT statBuf;

   deleteOutputOnInterrupt = False;

   if (name == NULL && srcMode != SM_I2O)
      panic ( "uncompress: bad modes\n" );

   cantGuess = False;
   switch (srcMode) {
      case SM_I2O: 
         copyFileName ( inName, "(stdin)" );
         copyFileName ( outName, "(stdout)" ); 
         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, ".out" );
         break;
      case SM_F2O: 
         copyFileName ( inName, name );
         copyFileName ( outName, "(stdout)" ); 
         break;
   }

   zzz:
   if ( srcMode != SM_I2O && containsDubiousChars ( inName ) ) {
      if (noisy)
      fprintf ( stderr, "%s: There are no files matching `%s'.\n",
                progName, inName );
      setExit(1);
      return;
   }
   if ( srcMode != SM_I2O && !fileExists ( inName ) ) {
      fprintf ( stderr, "%s: Can't open input file %s: %s.\n",
                progName, inName, strerror(errno) );
      setExit(1);
      return;
   }
   if ( srcMode == SM_F2F || srcMode == SM_F2O ) {
      MY_STAT(inName, &statBuf);
      if ( MY_S_ISDIR(statBuf.st_mode) ) {
         fprintf( stderr,
                  "%s: Input file %s is a directory.\n",
                  progName,inName);
         setExit(1);
         return;
      }
   }
   if ( srcMode == SM_F2F && !forceOverwrite && notAStandardFile ( inName )) {
      if (noisy)
      fprintf ( stderr, "%s: Input file %s is not a normal file.\n",
                progName, inName );
      setExit(1);
      return;
   }
   if ( /* srcMode == SM_F2F implied && */ cantGuess ) {
      if (noisy)
      fprintf ( stderr, 
                "%s: Can't guess original name for %s -- using %s\n",
                progName, inName, outName );
      /* just a warning, no return */
   }   
   if ( srcMode == SM_F2F && fileExists ( outName ) ) {
      if (forceOverwrite) {
	remove(outName);
      } else {
        fprintf ( stderr, "%s: Output file %s already exists.\n",
                  progName, outName );
        setExit(1);
        return;
      }
   }
   if ( srcMode == SM_F2F && !forceOverwrite &&
        (n=countHardLinks ( inName ) ) > 0) {
      fprintf ( stderr, "%s: Input file %s has %d other link%s.\n",
                progName, inName, n, n > 1 ? "s" : "" );
      setExit(1);
      return;
   }

   if ( srcMode == SM_F2F ) {
      /* Save the file's meta-info before we open it.  Doing it later
         means we mess up the access times. */
      saveInputFileMetaInfo ( inName );
   }

   switch ( srcMode ) {

      case SM_I2O:
         inStr = stdin;
         outStr = stdout;
         if ( isatty ( fileno ( stdin ) ) ) {
            fprintf ( stderr,
                      "%s: I won't read compressed data from a terminal.\n",
                      progName );
            fprintf ( stderr, "%s: For help, type: `%s --help'.\n",
                              progName, progName );
            setExit(1);
            return;
         };
         break;

      case SM_F2O:
         inStr = fopen ( inName, "rb" );
         outStr = stdout;
         if ( inStr == NULL ) {
            fprintf ( stderr, "%s: Can't open input file %s:%s.\n",
                      progName, inName, strerror(errno) );
            if ( inStr != NULL ) fclose ( inStr );
            setExit(1);
            return;
         };
         break;

      case SM_F2F:
         inStr = fopen ( inName, "rb" );
         outStr = fopen_output_safely ( outName, "wb" );
         if ( outStr == NULL) {
            fprintf ( stderr, "%s: Can't create output file %s: %s.\n",
                      progName, outName, strerror(errno) );
            if ( inStr != NULL ) fclose ( inStr );
            setExit(1);
            return;
         }
         if ( inStr == NULL ) {
            fprintf ( stderr, "%s: Can't open input file %s: %s.\n",
                      progName, inName, strerror(errno) );
            if ( outStr != NULL ) fclose ( outStr );
            setExit(1);
            return;
         };
         break;

      default:
         panic ( "uncompress: bad srcMode" );
         break;
   }

   if (verbosity >= 1) {
      fprintf ( stderr, "  %s: ", inName );
      pad ( inName );
      fflush ( stderr );
   }

   /*--- Now the input and output handles are sane.  Do the Biz. ---*/
   outputHandleJustInCase = outStr;
   deleteOutputOnInterrupt = True;
   magicNumberOK = uncompressStream ( inStr, outStr );
   outputHandleJustInCase = NULL;

   /*--- If there was an I/O error, we won't get here. ---*/
   if ( magicNumberOK ) {
      if ( srcMode == SM_F2F ) {
         applySavedMetaInfoToOutputFile ( outName );
         deleteOutputOnInterrupt = False;
         if ( !keepInputFiles ) {
            IntNative retVal = remove ( inName );
            ERROR_IF_NOT_ZERO ( retVal );
         }
      }
   } else {
      unzFailsExist = True;
      deleteOutputOnInterrupt = False;
      if ( srcMode == SM_F2F ) {
         IntNative retVal = remove ( outName );
         ERROR_IF_NOT_ZERO ( retVal );
      }
   }
   deleteOutputOnInterrupt = False;

   if ( magicNumberOK ) {
      if (verbosity >= 1)
         fprintf ( stderr, "done\n" );
   } else {
      setExit(2);
      if (verbosity >= 1)
         fprintf ( stderr, "not a bzip2 file.\n" ); else
         fprintf ( stderr,
                   "%s: %s is not a bzip2 file.\n",
                   progName, inName );
   }

}


/*---------------------------------------------*/
static 
void testf ( Char *name )
{
   FILE *inStr;
   Bool allOK;
   struct MY_STAT statBuf;

   deleteOutputOnInterrupt = False;

   if (name == NULL && srcMode != SM_I2O)
      panic ( "testf: bad modes\n" );

   copyFileName ( outName, "(none)" );
   switch (srcMode) {
      case SM_I2O: copyFileName ( inName, "(stdin)" ); break;
      case SM_F2F: copyFileName ( inName, name ); break;
      case SM_F2O: copyFileName ( inName, name ); break;
   }

   if ( srcMode != SM_I2O && containsDubiousChars ( inName ) ) {
      if (noisy)
      fprintf ( stderr, "%s: There are no files matching `%s'.\n",
                progName, inName );
      setExit(1);
      return;
   }
   if ( srcMode != SM_I2O && !fileExists ( inName ) ) {
      fprintf ( stderr, "%s: Can't open input %s: %s.\n",
                progName, inName, strerror(errno) );
      setExit(1);
      return;
   }
   if ( srcMode != SM_I2O ) {
      MY_STAT(inName, &statBuf);
      if ( MY_S_ISDIR(statBuf.st_mode) ) {
         fprintf( stderr,
                  "%s: Input file %s is a directory.\n",
                  progName,inName);
         setExit(1);
         return;
      }
   }

   switch ( srcMode ) {

      case SM_I2O:
         if ( isatty ( fileno ( stdin ) ) ) {
            fprintf ( stderr,
                      "%s: I won't read compressed data from a terminal.\n",
                      progName );
            fprintf ( stderr, "%s: For help, type: `%s --help'.\n",
                              progName, progName );
            setExit(1);
            return;
         };
         inStr = stdin;
         break;

      case SM_F2O: case SM_F2F:
         inStr = fopen ( inName, "rb" );
         if ( inStr == NULL ) {
            fprintf ( stderr, "%s: Can't open input file %s:%s.\n",
                      progName, inName, strerror(errno) );
            setExit(1);
            return;
         };
         break;

      default:
         panic ( "testf: bad srcMode" );
         break;
   }

   if (verbosity >= 1) {
      fprintf ( stderr, "  %s: ", inName );
      pad ( inName );
      fflush ( stderr );
   }

   /*--- Now the input handle is sane.  Do the Biz. ---*/
   outputHandleJustInCase = NULL;
   allOK = testStream ( inStr );

   if (allOK && verbosity >= 1) fprintf ( stderr, "ok\n" );
   if (!allOK) testFailsExist = True;
}


/*---------------------------------------------*/
static 
void license ( void )
{
   fprintf ( stderr,

    "bzip2, a block-sorting file compressor.  "
    "Version %s.\n"
    "   \n"
    "   Copyright (C) 1996-2002 by Julian Seward.\n"
    "   \n"
    "   This program is free software; you can redistribute it and/or modify\n"
    "   it under the terms set out in the LICENSE file, which is included\n"
    "   in the bzip2-1.0 source distribution.\n"
    "   \n"
    "   This program is distributed in the hope that it will be useful,\n"
    "   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
    "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
    "   LICENSE file for more details.\n"
    "   \n",
    BZ2_bzlibVersion()
   );
}


/*---------------------------------------------*/
static 
void usage ( Char *fullProgName )
{
   fprintf (
      stderr,
      "bzip2, a block-sorting file compressor.  "
      "Version %s.\n"
      "\n   usage: %s [flags and input files in any order]\n"
      "\n"
      "   -h --help           print this message\n"
      "   -d --decompress     force decompression\n"
      "   -z --compress       force compression\n"
      "   -k --keep           keep (don't delete) input files\n"
      "   -f --force          overwrite existing output files\n"
      "   -t --test           test compressed file integrity\n"
      "   -c --stdout         output to standard out\n"
      "   -q --quiet          suppress noncritical error messages\n"
      "   -v --verbose        be verbose (a 2nd -v gives more)\n"
      "   -L --license        display software version & license\n"
      "   -V --version        display software version & license\n"
      "   -s --small          use less memory (at most 2500k)\n"
      "   -1 .. -9            set block size to 100k .. 900k\n"
      "   --fast              alias for -1\n"
      "   --best              alias for -9\n"
      "\n"
      "   If invoked as `bzip2', default action is to compress.\n"
      "              as `bunzip2',  default action is to decompress.\n"
      "              as `bzcat', default action is to decompress to stdout.\n"
      "\n"
      "   If no file names are given, bzip2 compresses or decompresses\n"
      "   from standard input to standard output.  You can combine\n"
      "   short flags, so `-v -4' means the same as -v4 or -4v, &c.\n"
#     if BZ_UNIX
      "\n"
#     endif
      ,

      BZ2_bzlibVersion(),
      fullProgName
   );
}


/*---------------------------------------------*/
static 
void redundant ( Char* flag )
{
   fprintf ( 
      stderr, 
      "%s: %s is redundant in versions 0.9.5 and above\n",
      progName, flag );
}


/*---------------------------------------------*/
/*--
  All the garbage from here to main() is purely to
  implement a linked list of command-line arguments,
  into which main() copies argv[1 .. argc-1].

  The purpose of this exercise is to facilitate 
  the expansion of wildcard characters * and ? in 
  filenames for OSs which don't know how to do it
  themselves, like MSDOS, Windows 95 and NT.

  The actual Dirty Work is done by the platform-
  specific macro APPEND_FILESPEC.
--*/

typedef
   struct zzzz {
      Char        *name;
      struct zzzz *link;
   }
   Cell;


/*---------------------------------------------*/
static 
void *myMalloc ( Int32 n )
{
   void* p;

   p = malloc ( (size_t)n );
   if (p == NULL) outOfMemory ();
   return p;
}


/*---------------------------------------------*/
static 
Cell *mkCell ( void )
{
   Cell *c;

   c = (Cell*) myMalloc ( sizeof ( Cell ) );
   c->name = NULL;
   c->link = NULL;
   return c;
}


/*---------------------------------------------*/
static 
Cell *snocString ( Cell *root, Char *name )
{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
      return tmp;
   } else {
      Cell *tmp = root;
      while (tmp->link != NULL) tmp = tmp->link;
      tmp->link = snocString ( tmp->link, name );
      return root;
   }
}


/*---------------------------------------------*/
static 
void addFlagsFromEnvVar ( Cell** argList, Char* varName ) 
{
   Int32 i, j, k;
   Char *envbase, *p;

   envbase = getenv(varName);
   if (envbase != NULL) {
      p = envbase;
      i = 0;
      while (True) {
         if (p[i] == 0) break;
         p += i;
         i = 0;
         while (isspace((Int32)(p[0]))) p++;
         while (p[i] != 0 && !isspace((Int32)(p[i]))) i++;
         if (i > 0) {
            k = i; if (k > FILE_NAME_LEN-10) k = FILE_NAME_LEN-10;
            for (j = 0; j < k; j++) tmpName[j] = p[j];
            tmpName[k] = 0;
            APPEND_FLAG(*argList, tmpName);
         }
      }
   }
}


/*---------------------------------------------*/
#define ISFLAG(s) (strcmp(aa->name, (s))==0)

IntNative main ( IntNative argc, Char *argv[] )
{
   Int32  i, j;
   Char   *tmp;
   Cell   *argList;
   Cell   *aa;
   Bool   decode;

   /*-- Be really really really paranoid :-) --*/
   if (sizeof(Int32) != 4 || sizeof(UInt32) != 4  ||
       sizeof(Int16) != 2 || sizeof(UInt16) != 2  ||
       sizeof(Char)  != 1 || sizeof(UChar)  != 1)
      configError();

   /*-- Initialise --*/
   outputHandleJustInCase  = NULL;
   smallMode               = False;
   keepInputFiles          = False;
   forceOverwrite          = False;
   noisy                   = True;
   verbosity               = 0;
   blockSize100k           = 9;
   testFailsExist          = False;
   unzFailsExist           = False;
   numFileNames            = 0;
   numFilesProcessed       = 0;
   workFactor              = 30;
   deleteOutputOnInterrupt = False;
   exitValue               = 0;
   i = j = 0; /* avoid bogus warning from egcs-1.1.X */

   /*-- Set up signal handlers for mem access errors --*/
   signal (SIGSEGV, mySIGSEGVorSIGBUScatcher);
#  if BZ_UNIX
#  ifndef __DJGPP__
   signal (SIGBUS,  mySIGSEGVorSIGBUScatcher);
#  endif
#  endif

   copyFileName ( inName,  "(none)" );
   copyFileName ( outName, "(none)" );

   copyFileName ( progNameReally, argv[0] );
   progName = &progNameReally[0];
   for (tmp = &progNameReally[0]; *tmp != '\0'; tmp++)
      if (*tmp == PATH_SEP) progName = tmp + 1;


   /*-- Copy flags from env var BZIP2, and 
        expand filename wildcards in arg list.
   --*/
   argList = NULL;
   addFlagsFromEnvVar ( &argList,  "BZIP2" );
   addFlagsFromEnvVar ( &argList,  "BZIP" );
   for (i = 1; i <= argc-1; i++)
      APPEND_FILESPEC(argList, argv[i]);


   /*-- Find the length of the longest filename --*/
   longestFileName = 7;
   numFileNames    = 0;
   decode          = True;
   for (aa = argList; aa != NULL; aa = aa->link) {
      if (ISFLAG("--")) { decode = False; continue; }
      if (aa->name[0] == '-' && decode) continue;
      numFileNames++;
      if (longestFileName < (Int32)strlen(aa->name) )
         longestFileName = (Int32)strlen(aa->name);
   }


   /*-- Determine source modes; flag handling may change this too. --*/
   if (numFileNames == 0)
      srcMode = SM_I2O; else srcMode = SM_F2F;


   /*-- Determine what to do (compress/uncompress/test/cat). --*/
   /*-- Note that subsequent flag handling may change this. --*/
   opMode = OM_Z;

   if ( (strstr ( progName, "unzip" ) != 0) ||
        (strstr ( progName, "UNZIP" ) != 0) )
      opMode = OM_UNZ;

   if ( (strstr ( progName, "z2cat" ) != 0) ||
        (strstr ( progName, "Z2CAT" ) != 0) ||
        (strstr ( progName, "zcat" ) != 0)  ||
        (strstr ( progName, "ZCAT" ) != 0) )  {
      opMode = OM_UNZ;
      srcMode = (numFileNames == 0) ? SM_I2O : SM_F2O;
   }


   /*-- Look at the flags. --*/
   for (aa = argList; aa != NULL; aa = aa->link) {
      if (ISFLAG("--")) break;
      if (aa->name[0] == '-' && aa->name[1] != '-') {
         for (j = 1; aa->name[j] != '\0'; j++) {
            switch (aa->name[j]) {
               case 'c': srcMode          = SM_F2O; break;
               case 'd': opMode           = OM_UNZ; break;
               case 'z': opMode           = OM_Z; break;
               case 'f': forceOverwrite   = True; break;
               case 't': opMode           = OM_TEST; break;
               case 'k': keepInputFiles   = True; break;
               case 's': smallMode        = True; break;
               case 'q': noisy            = False; break;
               case '1': blockSize100k    = 1; break;
               case '2': blockSize100k    = 2; break;
               case '3': blockSize100k    = 3; break;
               case '4': blockSize100k    = 4; break;
               case '5': blockSize100k    = 5; break;
               case '6': blockSize100k    = 6; break;
               case '7': blockSize100k    = 7; break;
               case '8': blockSize100k    = 8; break;
               case '9': blockSize100k    = 9; break;
               case 'V':
               case 'L': license();            break;
               case 'v': verbosity++; break;
               case 'h': usage ( progName );
                         exit ( 0 );
                         break;
               default:  fprintf ( stderr, "%s: Bad flag `%s'\n",
                                   progName, aa->name );
                         usage ( progName );
                         exit ( 1 );
                         break;
            }
         }
      }
   }
   
   /*-- And again ... --*/
   for (aa = argList; aa != NULL; aa = aa->link) {
      if (ISFLAG("--")) break;
      if (ISFLAG("--stdout"))            srcMode          = SM_F2O;  else
      if (ISFLAG("--decompress"))        opMode           = OM_UNZ;  else
      if (ISFLAG("--compress"))          opMode           = OM_Z;    else
      if (ISFLAG("--force"))             forceOverwrite   = True;    else
      if (ISFLAG("--test"))              opMode           = OM_TEST; else
      if (ISFLAG("--keep"))              keepInputFiles   = True;    else
      if (ISFLAG("--small"))             smallMode        = True;    else
      if (ISFLAG("--quiet"))             noisy            = False;   else
      if (ISFLAG("--version"))           license();                  else
      if (ISFLAG("--license"))           license();                  else
      if (ISFLAG("--exponential"))       workFactor = 1;             else 
      if (ISFLAG("--repetitive-best"))   redundant(aa->name);        else
      if (ISFLAG("--repetitive-fast"))   redundant(aa->name);        else
      if (ISFLAG("--fast"))              blockSize100k = 1;          else
      if (ISFLAG("--best"))              blockSize100k = 9;          else
      if (ISFLAG("--verbose"))           verbosity++;                else
      if (ISFLAG("--help"))              { usage ( progName ); exit ( 0 ); }
         else
         if (strncmp ( aa->name, "--", 2) == 0) {
            fprintf ( stderr, "%s: Bad flag `%s'\n", progName, aa->name );
            usage ( progName );
            exit ( 1 );
         }
   }

   if (verbosity > 4) verbosity = 4;
   if (opMode == OM_Z && smallMode && blockSize100k > 2) 
      blockSize100k = 2;

   if (opMode == OM_TEST && srcMode == SM_F2O) {
      fprintf ( stderr, "%s: -c and -t cannot be used together.\n",
                progName );
      exit ( 1 );
   }

   if (srcMode == SM_F2O && numFileNames == 0)
      srcMode = SM_I2O;

   if (opMode != OM_Z) blockSize100k = 0;

   if (srcMode == SM_F2F) {
      signal (SIGINT,  mySignalCatcher);
      signal (SIGTERM, mySignalCatcher);
#     if BZ_UNIX
      signal (SIGHUP,  mySignalCatcher);
#     endif
   }

   if (opMode == OM_Z) {
     if (srcMode == SM_I2O) {
        compress ( NULL );
     } else {
        decode = True;
        for (aa = argList; aa != NULL; aa = aa->link) {
           if (ISFLAG("--")) { decode = False; continue; }
           if (aa->name[0] == '-' && decode) continue;
           numFilesProcessed++;
           compress ( aa->name );
        }
     }
   } 
   else

   if (opMode == OM_UNZ) {
      unzFailsExist = False;
      if (srcMode == SM_I2O) {
         uncompress ( NULL );
      } else {
         decode = True;
         for (aa = argList; aa != NULL; aa = aa->link) {
            if (ISFLAG("--")) { decode = False; continue; }
            if (aa->name[0] == '-' && decode) continue;
            numFilesProcessed++;
            uncompress ( aa->name );
         }      
      }
      if (unzFailsExist) { 
         setExit(2); 
         exit(exitValue);
      }
   } 

   else {
      testFailsExist = False;
      if (srcMode == SM_I2O) {
         testf ( NULL );
      } else {
         decode = True;
         for (aa = argList; aa != NULL; aa = aa->link) {
	    if (ISFLAG("--")) { decode = False; continue; }
            if (aa->name[0] == '-' && decode) continue;
            numFilesProcessed++;
            testf ( aa->name );
	 }
      }
      if (testFailsExist && noisy) {
         fprintf ( stderr,
           "\n"
           "You can use the `bzip2recover' program to attempt to recover\n"
           "data from undamaged sections of corrupted files.\n\n"
         );
         setExit(2);
         exit(exitValue);
      }
   }

   /* Free the argument list memory to mollify leak detectors 
      (eg) Purify, Checker.  Serves no other useful purpose.
   */
   aa = argList;
   while (aa != NULL) {
      Cell* aa2 = aa->link;
      if (aa->name != NULL) free(aa->name);
      free(aa);
      aa = aa2;
   }

   return exitValue;
}


/*-----------------------------------------------------------*/
/*--- end                                         bzip2.c ---*/
/*-----------------------------------------------------------*/79428.51user 1151.35system 17:26:52elapsed 128%CPU (0avgtext+0avgdata 61424maxresident)k
80584inputs+136614296outputs (706major+502519331minor)pagefaults 0swaps
